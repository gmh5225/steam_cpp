// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_storebrowse.steamclient.proto

#include "steammessages_storebrowse.steamclient.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr StoreItemID::StoreItemID(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u)
  , packageid_(0u)
  , bundleid_(0u)
  , tagid_(0u)
  , creatorid_(0u)
  , hubcategoryid_(0u){}
struct StoreItemIDDefaultTypeInternal {
  constexpr StoreItemIDDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItemIDDefaultTypeInternal() {}
  union {
    StoreItemID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItemIDDefaultTypeInternal _StoreItemID_default_instance_;
constexpr StoreBrowseContext::StoreBrowseContext(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : language_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , country_code_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , elanguage_(0)
  , steam_realm_(0){}
struct StoreBrowseContextDefaultTypeInternal {
  constexpr StoreBrowseContextDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreBrowseContextDefaultTypeInternal() {}
  union {
    StoreBrowseContext _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreBrowseContextDefaultTypeInternal _StoreBrowseContext_default_instance_;
constexpr StoreBrowseItemDataRequest::StoreBrowseItemDataRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : include_assets_(false)
  , include_release_(false)
  , include_platforms_(false)
  , include_all_purchase_options_(false)
  , include_screenshots_(false)
  , include_trailers_(false)
  , include_ratings_(false)
  , include_reviews_(false)
  , include_tag_count_(0)
  , include_basic_info_(false)
  , include_supported_languages_(false)
  , include_full_description_(false){}
struct StoreBrowseItemDataRequestDefaultTypeInternal {
  constexpr StoreBrowseItemDataRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreBrowseItemDataRequestDefaultTypeInternal() {}
  union {
    StoreBrowseItemDataRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreBrowseItemDataRequestDefaultTypeInternal _StoreBrowseItemDataRequest_default_instance_;
constexpr CStoreBrowse_GetItems_Request::CStoreBrowse_GetItems_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ids_()
  , context_(nullptr)
  , data_request_(nullptr){}
struct CStoreBrowse_GetItems_RequestDefaultTypeInternal {
  constexpr CStoreBrowse_GetItems_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetItems_RequestDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetItems_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetItems_RequestDefaultTypeInternal _CStoreBrowse_GetItems_Request_default_instance_;
constexpr StoreGameRating::StoreGameRating(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : descriptors_()
  , type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , rating_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , interactive_elements_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , image_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , image_target_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , required_age_(0)
  , use_age_gate_(false){}
struct StoreGameRatingDefaultTypeInternal {
  constexpr StoreGameRatingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreGameRatingDefaultTypeInternal() {}
  union {
    StoreGameRating _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreGameRatingDefaultTypeInternal _StoreGameRating_default_instance_;
constexpr StoreItem_RelatedItems::StoreItem_RelatedItems(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parent_appid_(0u){}
struct StoreItem_RelatedItemsDefaultTypeInternal {
  constexpr StoreItem_RelatedItemsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_RelatedItemsDefaultTypeInternal() {}
  union {
    StoreItem_RelatedItems _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_RelatedItemsDefaultTypeInternal _StoreItem_RelatedItems_default_instance_;
constexpr StoreItem_Categories::StoreItem_Categories(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : supported_player_categoryids_()
  , feature_categoryids_()
  , controller_categoryids_(){}
struct StoreItem_CategoriesDefaultTypeInternal {
  constexpr StoreItem_CategoriesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_CategoriesDefaultTypeInternal() {}
  union {
    StoreItem_Categories _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_CategoriesDefaultTypeInternal _StoreItem_Categories_default_instance_;
constexpr StoreItem_Reviews_StoreReviewSummary::StoreItem_Reviews_StoreReviewSummary(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : review_score_label_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , review_count_(0u)
  , percent_positive_(0)
  , review_score_(0)
{}
struct StoreItem_Reviews_StoreReviewSummaryDefaultTypeInternal {
  constexpr StoreItem_Reviews_StoreReviewSummaryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_Reviews_StoreReviewSummaryDefaultTypeInternal() {}
  union {
    StoreItem_Reviews_StoreReviewSummary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_Reviews_StoreReviewSummaryDefaultTypeInternal _StoreItem_Reviews_StoreReviewSummary_default_instance_;
constexpr StoreItem_Reviews::StoreItem_Reviews(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : summary_filtered_(nullptr)
  , summary_unfiltered_(nullptr){}
struct StoreItem_ReviewsDefaultTypeInternal {
  constexpr StoreItem_ReviewsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_ReviewsDefaultTypeInternal() {}
  union {
    StoreItem_Reviews _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_ReviewsDefaultTypeInternal _StoreItem_Reviews_default_instance_;
constexpr StoreItem_BasicInfo_CreatorHomeLink::StoreItem_BasicInfo_CreatorHomeLink(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , creator_clan_account_id_(0u){}
struct StoreItem_BasicInfo_CreatorHomeLinkDefaultTypeInternal {
  constexpr StoreItem_BasicInfo_CreatorHomeLinkDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_BasicInfo_CreatorHomeLinkDefaultTypeInternal() {}
  union {
    StoreItem_BasicInfo_CreatorHomeLink _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_BasicInfo_CreatorHomeLinkDefaultTypeInternal _StoreItem_BasicInfo_CreatorHomeLink_default_instance_;
constexpr StoreItem_BasicInfo::StoreItem_BasicInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : publishers_()
  , developers_()
  , franchises_()
  , short_description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , capsule_headline_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct StoreItem_BasicInfoDefaultTypeInternal {
  constexpr StoreItem_BasicInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_BasicInfoDefaultTypeInternal() {}
  union {
    StoreItem_BasicInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_BasicInfoDefaultTypeInternal _StoreItem_BasicInfo_default_instance_;
constexpr StoreItem_Tag::StoreItem_Tag(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tagid_(0u)
  , weight_(0u){}
struct StoreItem_TagDefaultTypeInternal {
  constexpr StoreItem_TagDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_TagDefaultTypeInternal() {}
  union {
    StoreItem_Tag _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_TagDefaultTypeInternal _StoreItem_Tag_default_instance_;
constexpr StoreItem_Assets::StoreItem_Assets(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : asset_url_format_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , main_capsule_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , small_capsule_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , header_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , package_header_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , page_background_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , hero_capsule_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , hero_capsule_2x_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , library_capsule_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , library_capsule_2x_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , library_hero_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , library_hero_2x_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , community_icon_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , clan_avatar_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct StoreItem_AssetsDefaultTypeInternal {
  constexpr StoreItem_AssetsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_AssetsDefaultTypeInternal() {}
  union {
    StoreItem_Assets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_AssetsDefaultTypeInternal _StoreItem_Assets_default_instance_;
constexpr StoreItem_ReleaseInfo::StoreItem_ReleaseInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : custom_release_date_message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , coming_soon_display_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , steam_release_date_(0u)
  , original_release_date_(0u)
  , original_steam_release_date_(0u)
  , is_coming_soon_(false)
  , is_preload_(false)
  , is_abridged_release_date_(false)
  , is_early_access_(false)
  , mac_release_date_(0u)
  , linux_release_date_(0u){}
struct StoreItem_ReleaseInfoDefaultTypeInternal {
  constexpr StoreItem_ReleaseInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_ReleaseInfoDefaultTypeInternal() {}
  union {
    StoreItem_ReleaseInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_ReleaseInfoDefaultTypeInternal _StoreItem_ReleaseInfo_default_instance_;
constexpr StoreItem_Platforms_VRSupport::StoreItem_Platforms_VRSupport(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vrhmd_(false)
  , vrhmd_only_(false)
  , htc_vive_(false)
  , oculus_rift_(false)
  , windows_mr_(false)
  , valve_index_(false){}
struct StoreItem_Platforms_VRSupportDefaultTypeInternal {
  constexpr StoreItem_Platforms_VRSupportDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_Platforms_VRSupportDefaultTypeInternal() {}
  union {
    StoreItem_Platforms_VRSupport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_Platforms_VRSupportDefaultTypeInternal _StoreItem_Platforms_VRSupport_default_instance_;
constexpr StoreItem_Platforms::StoreItem_Platforms(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vr_support_(nullptr)
  , windows_(false)
  , mac_(false)
  , steamos_linux_(false)
  , steam_deck_compat_category_(0)
{}
struct StoreItem_PlatformsDefaultTypeInternal {
  constexpr StoreItem_PlatformsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_PlatformsDefaultTypeInternal() {}
  union {
    StoreItem_Platforms _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_PlatformsDefaultTypeInternal _StoreItem_Platforms_default_instance_;
constexpr StoreItem_PurchaseOption_Discount::StoreItem_PurchaseOption_Discount(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : discount_description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , discount_amount_(int64_t{0})
  , discount_end_date_(0u){}
struct StoreItem_PurchaseOption_DiscountDefaultTypeInternal {
  constexpr StoreItem_PurchaseOption_DiscountDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_PurchaseOption_DiscountDefaultTypeInternal() {}
  union {
    StoreItem_PurchaseOption_Discount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_PurchaseOption_DiscountDefaultTypeInternal _StoreItem_PurchaseOption_Discount_default_instance_;
constexpr StoreItem_PurchaseOption::StoreItem_PurchaseOption(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : active_discounts_()
  , user_active_discounts_()
  , inactive_discounts_()
  , purchase_option_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , formatted_final_price_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , formatted_original_price_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , packageid_(0)
  , bundleid_(0)
  , final_price_in_cents_(int64_t{0})
  , original_price_in_cents_(int64_t{0})
  , user_final_price_in_cents_(int64_t{0})
  , discount_pct_(0)
  , user_discount_pct_(0)
  , bundle_discount_pct_(0)
  , user_can_purchase_(false)
  , user_can_purchase_as_gift_(false)
  , is_commercial_license_(false)
  , should_suppress_discount_pct_(false)
  , hide_discount_pct_for_compliance_(false)
  , included_game_count_(0)
  , lowest_recent_price_in_cents_(int64_t{0}){}
struct StoreItem_PurchaseOptionDefaultTypeInternal {
  constexpr StoreItem_PurchaseOptionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_PurchaseOptionDefaultTypeInternal() {}
  union {
    StoreItem_PurchaseOption _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_PurchaseOptionDefaultTypeInternal _StoreItem_PurchaseOption_default_instance_;
constexpr StoreItem_Screenshots_Screenshot::StoreItem_Screenshots_Screenshot(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : filename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ordinal_(0){}
struct StoreItem_Screenshots_ScreenshotDefaultTypeInternal {
  constexpr StoreItem_Screenshots_ScreenshotDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_Screenshots_ScreenshotDefaultTypeInternal() {}
  union {
    StoreItem_Screenshots_Screenshot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_Screenshots_ScreenshotDefaultTypeInternal _StoreItem_Screenshots_Screenshot_default_instance_;
constexpr StoreItem_Screenshots::StoreItem_Screenshots(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : all_ages_screenshots_()
  , mature_content_screenshots_(){}
struct StoreItem_ScreenshotsDefaultTypeInternal {
  constexpr StoreItem_ScreenshotsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_ScreenshotsDefaultTypeInternal() {}
  union {
    StoreItem_Screenshots _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_ScreenshotsDefaultTypeInternal _StoreItem_Screenshots_default_instance_;
constexpr StoreItem_Trailers_VideoSource::StoreItem_Trailers_VideoSource(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : filename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct StoreItem_Trailers_VideoSourceDefaultTypeInternal {
  constexpr StoreItem_Trailers_VideoSourceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_Trailers_VideoSourceDefaultTypeInternal() {}
  union {
    StoreItem_Trailers_VideoSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_Trailers_VideoSourceDefaultTypeInternal _StoreItem_Trailers_VideoSource_default_instance_;
constexpr StoreItem_Trailers_Trailer::StoreItem_Trailers_Trailer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : trailer_480p_()
  , trailer_max_()
  , microtrailer_()
  , trailer_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , trailer_url_format_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , screenshot_medium_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , screenshot_full_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , trailer_base_id_(0){}
struct StoreItem_Trailers_TrailerDefaultTypeInternal {
  constexpr StoreItem_Trailers_TrailerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_Trailers_TrailerDefaultTypeInternal() {}
  union {
    StoreItem_Trailers_Trailer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_Trailers_TrailerDefaultTypeInternal _StoreItem_Trailers_Trailer_default_instance_;
constexpr StoreItem_Trailers::StoreItem_Trailers(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : highlights_()
  , other_trailers_(){}
struct StoreItem_TrailersDefaultTypeInternal {
  constexpr StoreItem_TrailersDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_TrailersDefaultTypeInternal() {}
  union {
    StoreItem_Trailers _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_TrailersDefaultTypeInternal _StoreItem_Trailers_default_instance_;
constexpr StoreItem_SupportedLanguage::StoreItem_SupportedLanguage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : elanguage_(0)
  , supported_(false)
  , full_audio_(false)
  , subtitles_(false){}
struct StoreItem_SupportedLanguageDefaultTypeInternal {
  constexpr StoreItem_SupportedLanguageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_SupportedLanguageDefaultTypeInternal() {}
  union {
    StoreItem_SupportedLanguage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_SupportedLanguageDefaultTypeInternal _StoreItem_SupportedLanguage_default_instance_;
constexpr StoreItem_FreeWeekend::StoreItem_FreeWeekend(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , start_time_(0u)
  , end_time_(0u){}
struct StoreItem_FreeWeekendDefaultTypeInternal {
  constexpr StoreItem_FreeWeekendDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItem_FreeWeekendDefaultTypeInternal() {}
  union {
    StoreItem_FreeWeekend _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItem_FreeWeekendDefaultTypeInternal _StoreItem_FreeWeekend_default_instance_;
constexpr StoreItem::StoreItem(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : included_types_()
  , included_appids_()
  , content_descriptorids_()
  , tagids_()
  , tags_()
  , purchase_options_()
  , accessories_()
  , supported_languages_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , store_url_path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , store_url_path_override_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , internal_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , full_description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , related_items_(nullptr)
  , categories_(nullptr)
  , reviews_(nullptr)
  , basic_info_(nullptr)
  , assets_(nullptr)
  , release_(nullptr)
  , platforms_(nullptr)
  , game_rating_(nullptr)
  , best_purchase_option_(nullptr)
  , screenshots_(nullptr)
  , trailers_(nullptr)
  , free_weekend_(nullptr)
  , id_(0u)
  , success_(0u)
  , appid_(0u)
  , visible_(false)
  , unvailable_for_country_restriction_(false)
  , is_free_(false)
  , is_early_access_(false)
  , type_(0)

  , unlisted_(false)
  , game_count_(0u)
  , item_type_(-1)
{}
struct StoreItemDefaultTypeInternal {
  constexpr StoreItemDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreItemDefaultTypeInternal() {}
  union {
    StoreItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreItemDefaultTypeInternal _StoreItem_default_instance_;
constexpr CStoreBrowse_GetItems_Response::CStoreBrowse_GetItems_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : store_items_(){}
struct CStoreBrowse_GetItems_ResponseDefaultTypeInternal {
  constexpr CStoreBrowse_GetItems_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetItems_ResponseDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetItems_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetItems_ResponseDefaultTypeInternal _CStoreBrowse_GetItems_Response_default_instance_;
constexpr CStoreBrowse_GetStoreCategories_Request::CStoreBrowse_GetStoreCategories_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : language_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , elanguage_(-1){}
struct CStoreBrowse_GetStoreCategories_RequestDefaultTypeInternal {
  constexpr CStoreBrowse_GetStoreCategories_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetStoreCategories_RequestDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetStoreCategories_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetStoreCategories_RequestDefaultTypeInternal _CStoreBrowse_GetStoreCategories_Request_default_instance_;
constexpr CStoreBrowse_GetStoreCategories_Response_Category::CStoreBrowse_GetStoreCategories_Response_Category(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : internal_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , display_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , image_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , categoryid_(0u)
  , type_(0)

  , show_in_search_(false){}
struct CStoreBrowse_GetStoreCategories_Response_CategoryDefaultTypeInternal {
  constexpr CStoreBrowse_GetStoreCategories_Response_CategoryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetStoreCategories_Response_CategoryDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetStoreCategories_Response_Category _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetStoreCategories_Response_CategoryDefaultTypeInternal _CStoreBrowse_GetStoreCategories_Response_Category_default_instance_;
constexpr CStoreBrowse_GetStoreCategories_Response::CStoreBrowse_GetStoreCategories_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : categories_(){}
struct CStoreBrowse_GetStoreCategories_ResponseDefaultTypeInternal {
  constexpr CStoreBrowse_GetStoreCategories_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetStoreCategories_ResponseDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetStoreCategories_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetStoreCategories_ResponseDefaultTypeInternal _CStoreBrowse_GetStoreCategories_Response_default_instance_;
constexpr CStoreBrowse_GetDLCForApps_Request::CStoreBrowse_GetDLCForApps_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appids_()
  , context_(nullptr)
  , store_page_filter_(nullptr)
  , steamid_(uint64_t{0u}){}
struct CStoreBrowse_GetDLCForApps_RequestDefaultTypeInternal {
  constexpr CStoreBrowse_GetDLCForApps_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetDLCForApps_RequestDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetDLCForApps_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetDLCForApps_RequestDefaultTypeInternal _CStoreBrowse_GetDLCForApps_Request_default_instance_;
constexpr CStoreBrowse_GetDLCForApps_Response_DLCData::CStoreBrowse_GetDLCForApps_Response_DLCData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u)
  , parentappid_(0u)
  , release_date_(0u)
  , coming_soon_(false)
  , free_(false)
  , price_(int64_t{0})
  , discount_(0u){}
struct CStoreBrowse_GetDLCForApps_Response_DLCDataDefaultTypeInternal {
  constexpr CStoreBrowse_GetDLCForApps_Response_DLCDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetDLCForApps_Response_DLCDataDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetDLCForApps_Response_DLCData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetDLCForApps_Response_DLCDataDefaultTypeInternal _CStoreBrowse_GetDLCForApps_Response_DLCData_default_instance_;
constexpr CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u)
  , playtime_(0u)
  , last_played_(0u){}
struct CStoreBrowse_GetDLCForApps_Response_PlaytimeForAppDefaultTypeInternal {
  constexpr CStoreBrowse_GetDLCForApps_Response_PlaytimeForAppDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetDLCForApps_Response_PlaytimeForAppDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetDLCForApps_Response_PlaytimeForAppDefaultTypeInternal _CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp_default_instance_;
constexpr CStoreBrowse_GetDLCForApps_Response::CStoreBrowse_GetDLCForApps_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dlc_data_()
  , playtime_(){}
struct CStoreBrowse_GetDLCForApps_ResponseDefaultTypeInternal {
  constexpr CStoreBrowse_GetDLCForApps_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetDLCForApps_ResponseDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetDLCForApps_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetDLCForApps_ResponseDefaultTypeInternal _CStoreBrowse_GetDLCForApps_Response_default_instance_;
constexpr CStoreBrowse_GetDLCForAppsSolr_Request::CStoreBrowse_GetDLCForAppsSolr_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appids_()
  , flavor_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , context_(nullptr)
  , store_page_filter_(nullptr)
  , count_(0u){}
struct CStoreBrowse_GetDLCForAppsSolr_RequestDefaultTypeInternal {
  constexpr CStoreBrowse_GetDLCForAppsSolr_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetDLCForAppsSolr_RequestDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetDLCForAppsSolr_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetDLCForAppsSolr_RequestDefaultTypeInternal _CStoreBrowse_GetDLCForAppsSolr_Request_default_instance_;
constexpr CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dlc_appids_()
  , parent_appid_(0u){}
struct CStoreBrowse_GetDLCForAppsSolr_Response_DLCListDefaultTypeInternal {
  constexpr CStoreBrowse_GetDLCForAppsSolr_Response_DLCListDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetDLCForAppsSolr_Response_DLCListDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetDLCForAppsSolr_Response_DLCList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetDLCForAppsSolr_Response_DLCListDefaultTypeInternal _CStoreBrowse_GetDLCForAppsSolr_Response_DLCList_default_instance_;
constexpr CStoreBrowse_GetDLCForAppsSolr_Response::CStoreBrowse_GetDLCForAppsSolr_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : dlc_lists_(){}
struct CStoreBrowse_GetDLCForAppsSolr_ResponseDefaultTypeInternal {
  constexpr CStoreBrowse_GetDLCForAppsSolr_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStoreBrowse_GetDLCForAppsSolr_ResponseDefaultTypeInternal() {}
  union {
    CStoreBrowse_GetDLCForAppsSolr_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStoreBrowse_GetDLCForAppsSolr_ResponseDefaultTypeInternal _CStoreBrowse_GetDLCForAppsSolr_Response_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[37];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_steammessages_5fstorebrowse_2esteamclient_2eproto[4];
static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* file_level_service_descriptors_steammessages_5fstorebrowse_2esteamclient_2eproto[1];

const uint32_t TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::StoreItemID, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItemID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItemID, appid_),
  PROTOBUF_FIELD_OFFSET(::StoreItemID, packageid_),
  PROTOBUF_FIELD_OFFSET(::StoreItemID, bundleid_),
  PROTOBUF_FIELD_OFFSET(::StoreItemID, tagid_),
  PROTOBUF_FIELD_OFFSET(::StoreItemID, creatorid_),
  PROTOBUF_FIELD_OFFSET(::StoreItemID, hubcategoryid_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::StoreBrowseContext, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseContext, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreBrowseContext, language_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseContext, elanguage_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseContext, country_code_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseContext, steam_realm_),
  0,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_assets_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_release_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_platforms_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_all_purchase_options_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_screenshots_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_trailers_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_ratings_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_tag_count_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_reviews_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_basic_info_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_supported_languages_),
  PROTOBUF_FIELD_OFFSET(::StoreBrowseItemDataRequest, include_full_description_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  8,
  7,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetItems_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetItems_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetItems_Request, ids_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetItems_Request, context_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetItems_Request, data_request_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::StoreGameRating, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreGameRating, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreGameRating, type_),
  PROTOBUF_FIELD_OFFSET(::StoreGameRating, rating_),
  PROTOBUF_FIELD_OFFSET(::StoreGameRating, descriptors_),
  PROTOBUF_FIELD_OFFSET(::StoreGameRating, interactive_elements_),
  PROTOBUF_FIELD_OFFSET(::StoreGameRating, required_age_),
  PROTOBUF_FIELD_OFFSET(::StoreGameRating, use_age_gate_),
  PROTOBUF_FIELD_OFFSET(::StoreGameRating, image_url_),
  PROTOBUF_FIELD_OFFSET(::StoreGameRating, image_target_),
  0,
  1,
  ~0u,
  2,
  5,
  6,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::StoreItem_RelatedItems, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_RelatedItems, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_RelatedItems, parent_appid_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Categories, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Categories, supported_player_categoryids_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Categories, feature_categoryids_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Categories, controller_categoryids_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Reviews_StoreReviewSummary, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Reviews_StoreReviewSummary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Reviews_StoreReviewSummary, review_count_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Reviews_StoreReviewSummary, percent_positive_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Reviews_StoreReviewSummary, review_score_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Reviews_StoreReviewSummary, review_score_label_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::StoreItem_Reviews, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Reviews, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Reviews, summary_filtered_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Reviews, summary_unfiltered_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo_CreatorHomeLink, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo_CreatorHomeLink, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo_CreatorHomeLink, name_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo_CreatorHomeLink, creator_clan_account_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo, short_description_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo, publishers_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo, developers_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo, franchises_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_BasicInfo, capsule_headline_),
  0,
  ~0u,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::StoreItem_Tag, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Tag, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Tag, tagid_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Tag, weight_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, asset_url_format_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, main_capsule_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, small_capsule_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, header_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, package_header_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, page_background_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, hero_capsule_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, hero_capsule_2x_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, library_capsule_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, library_capsule_2x_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, library_hero_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, library_hero_2x_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, community_icon_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Assets, clan_avatar_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, steam_release_date_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, original_release_date_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, original_steam_release_date_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, is_coming_soon_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, is_preload_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, custom_release_date_message_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, is_abridged_release_date_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, coming_soon_display_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, is_early_access_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, mac_release_date_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_ReleaseInfo, linux_release_date_),
  2,
  3,
  4,
  5,
  6,
  0,
  7,
  1,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms_VRSupport, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms_VRSupport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms_VRSupport, vrhmd_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms_VRSupport, vrhmd_only_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms_VRSupport, htc_vive_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms_VRSupport, oculus_rift_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms_VRSupport, windows_mr_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms_VRSupport, valve_index_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms, windows_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms, mac_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms, steamos_linux_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms, vr_support_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Platforms, steam_deck_compat_category_),
  1,
  2,
  3,
  0,
  4,
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption_Discount, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption_Discount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption_Discount, discount_amount_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption_Discount, discount_description_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption_Discount, discount_end_date_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, packageid_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, bundleid_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, purchase_option_name_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, final_price_in_cents_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, original_price_in_cents_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, user_final_price_in_cents_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, formatted_final_price_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, formatted_original_price_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, discount_pct_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, user_discount_pct_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, bundle_discount_pct_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, active_discounts_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, user_active_discounts_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, inactive_discounts_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, user_can_purchase_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, user_can_purchase_as_gift_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, is_commercial_license_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, should_suppress_discount_pct_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, hide_discount_pct_for_compliance_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, included_game_count_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_PurchaseOption, lowest_recent_price_in_cents_),
  3,
  4,
  0,
  5,
  6,
  7,
  1,
  2,
  8,
  9,
  10,
  ~0u,
  ~0u,
  ~0u,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  PROTOBUF_FIELD_OFFSET(::StoreItem_Screenshots_Screenshot, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Screenshots_Screenshot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Screenshots_Screenshot, filename_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Screenshots_Screenshot, ordinal_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Screenshots, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Screenshots, all_ages_screenshots_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Screenshots, mature_content_screenshots_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_VideoSource, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_VideoSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_VideoSource, filename_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_VideoSource, type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_Trailer, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_Trailer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_Trailer, trailer_name_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_Trailer, trailer_url_format_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_Trailer, trailer_480p_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_Trailer, trailer_max_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_Trailer, microtrailer_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_Trailer, screenshot_medium_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_Trailer, screenshot_full_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers_Trailer, trailer_base_id_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers, highlights_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_Trailers, other_trailers_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_SupportedLanguage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_SupportedLanguage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_SupportedLanguage, elanguage_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_SupportedLanguage, supported_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_SupportedLanguage, full_audio_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_SupportedLanguage, subtitles_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::StoreItem_FreeWeekend, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_FreeWeekend, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem_FreeWeekend, start_time_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_FreeWeekend, end_time_),
  PROTOBUF_FIELD_OFFSET(::StoreItem_FreeWeekend, text_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::StoreItem, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StoreItem, item_type_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, id_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, success_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, visible_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, unvailable_for_country_restriction_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, name_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, store_url_path_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, appid_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, type_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, included_types_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, included_appids_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, is_free_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, is_early_access_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, related_items_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, content_descriptorids_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, tagids_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, categories_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, reviews_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, basic_info_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, tags_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, assets_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, release_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, platforms_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, game_rating_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, best_purchase_option_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, purchase_options_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, accessories_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, screenshots_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, trailers_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, supported_languages_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, store_url_path_override_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, free_weekend_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, unlisted_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, game_count_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, internal_name_),
  PROTOBUF_FIELD_OFFSET(::StoreItem, full_description_),
  27,
  17,
  18,
  20,
  21,
  0,
  1,
  19,
  24,
  ~0u,
  ~0u,
  22,
  23,
  5,
  ~0u,
  ~0u,
  6,
  7,
  8,
  ~0u,
  9,
  10,
  11,
  12,
  13,
  ~0u,
  ~0u,
  14,
  15,
  ~0u,
  2,
  16,
  25,
  26,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetItems_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetItems_Response, store_items_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Request, language_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Request, elanguage_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Response_Category, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Response_Category, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Response_Category, categoryid_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Response_Category, type_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Response_Category, internal_name_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Response_Category, display_name_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Response_Category, image_url_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Response_Category, show_in_search_),
  3,
  4,
  0,
  1,
  2,
  5,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetStoreCategories_Response, categories_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Request, context_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Request, store_page_filter_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Request, appids_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Request, steamid_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_DLCData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_DLCData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_DLCData, appid_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_DLCData, parentappid_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_DLCData, release_date_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_DLCData, coming_soon_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_DLCData, price_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_DLCData, discount_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_DLCData, free_),
  0,
  1,
  2,
  3,
  5,
  6,
  4,
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp, appid_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp, playtime_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp, last_played_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response, dlc_data_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForApps_Response, playtime_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Request, context_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Request, appids_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Request, flavor_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Request, count_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Request, store_page_filter_),
  1,
  ~0u,
  0,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList, parent_appid_),
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList, dlc_appids_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStoreBrowse_GetDLCForAppsSolr_Response, dlc_lists_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, -1, sizeof(::StoreItemID)},
  { 18, 28, -1, sizeof(::StoreBrowseContext)},
  { 32, 50, -1, sizeof(::StoreBrowseItemDataRequest)},
  { 62, 71, -1, sizeof(::CStoreBrowse_GetItems_Request)},
  { 74, 88, -1, sizeof(::StoreGameRating)},
  { 96, 103, -1, sizeof(::StoreItem_RelatedItems)},
  { 104, -1, -1, sizeof(::StoreItem_Categories)},
  { 113, 123, -1, sizeof(::StoreItem_Reviews_StoreReviewSummary)},
  { 127, 135, -1, sizeof(::StoreItem_Reviews)},
  { 137, 145, -1, sizeof(::StoreItem_BasicInfo_CreatorHomeLink)},
  { 147, 158, -1, sizeof(::StoreItem_BasicInfo)},
  { 163, 171, -1, sizeof(::StoreItem_Tag)},
  { 173, 193, -1, sizeof(::StoreItem_Assets)},
  { 207, 224, -1, sizeof(::StoreItem_ReleaseInfo)},
  { 235, 247, -1, sizeof(::StoreItem_Platforms_VRSupport)},
  { 253, 264, -1, sizeof(::StoreItem_Platforms)},
  { 269, 278, -1, sizeof(::StoreItem_PurchaseOption_Discount)},
  { 281, 308, -1, sizeof(::StoreItem_PurchaseOption)},
  { 329, 337, -1, sizeof(::StoreItem_Screenshots_Screenshot)},
  { 339, -1, -1, sizeof(::StoreItem_Screenshots)},
  { 347, 355, -1, sizeof(::StoreItem_Trailers_VideoSource)},
  { 357, 371, -1, sizeof(::StoreItem_Trailers_Trailer)},
  { 379, -1, -1, sizeof(::StoreItem_Trailers)},
  { 387, 397, -1, sizeof(::StoreItem_SupportedLanguage)},
  { 401, 410, -1, sizeof(::StoreItem_FreeWeekend)},
  { 413, 455, -1, sizeof(::StoreItem)},
  { 491, -1, -1, sizeof(::CStoreBrowse_GetItems_Response)},
  { 498, 506, -1, sizeof(::CStoreBrowse_GetStoreCategories_Request)},
  { 508, 520, -1, sizeof(::CStoreBrowse_GetStoreCategories_Response_Category)},
  { 526, -1, -1, sizeof(::CStoreBrowse_GetStoreCategories_Response)},
  { 533, 543, -1, sizeof(::CStoreBrowse_GetDLCForApps_Request)},
  { 547, 560, -1, sizeof(::CStoreBrowse_GetDLCForApps_Response_DLCData)},
  { 567, 576, -1, sizeof(::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp)},
  { 579, -1, -1, sizeof(::CStoreBrowse_GetDLCForApps_Response)},
  { 587, 598, -1, sizeof(::CStoreBrowse_GetDLCForAppsSolr_Request)},
  { 603, 611, -1, sizeof(::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList)},
  { 613, -1, -1, sizeof(::CStoreBrowse_GetDLCForAppsSolr_Response)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItemID_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreBrowseContext_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreBrowseItemDataRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetItems_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreGameRating_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_RelatedItems_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Categories_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Reviews_StoreReviewSummary_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Reviews_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_BasicInfo_CreatorHomeLink_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_BasicInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Tag_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Assets_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_ReleaseInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Platforms_VRSupport_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Platforms_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_PurchaseOption_Discount_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_PurchaseOption_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Screenshots_Screenshot_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Screenshots_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Trailers_VideoSource_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Trailers_Trailer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_Trailers_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_SupportedLanguage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_FreeWeekend_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StoreItem_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetItems_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetStoreCategories_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetStoreCategories_Response_Category_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetStoreCategories_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetDLCForApps_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetDLCForApps_Response_DLCData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetDLCForApps_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetDLCForAppsSolr_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetDLCForAppsSolr_Response_DLCList_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStoreBrowse_GetDLCForAppsSolr_Response_default_instance_),
};

const char descriptor_table_protodef_steammessages_5fstorebrowse_2esteamclient_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n+steammessages_storebrowse.steamclient."
  "proto\032\030steammessages_base.proto\032,steamme"
  "ssages_unified_base.steamclient.proto\032\027e"
  "nums_productinfo.proto\032\013enums.proto\032\021con"
  "tenthubs.proto\"z\n\013StoreItemID\022\r\n\005appid\030\001"
  " \001(\r\022\021\n\tpackageid\030\002 \001(\r\022\020\n\010bundleid\030\003 \001("
  "\r\022\r\n\005tagid\030\004 \001(\r\022\021\n\tcreatorid\030\005 \001(\r\022\025\n\rh"
  "ubcategoryid\030\006 \001(\r\"\254\001\n\022StoreBrowseContex"
  "t\022\020\n\010language\030\001 \001(\t\022 \n\telanguage\030\002 \001(\005B\r"
  "\202\265\030\tELanguage\022<\n\014country_code\030\003 \001(\tB&\202\265\030"
  "\"2-character country code; required\022$\n\013s"
  "team_realm\030\004 \001(\005B\017\202\265\030\013ESteamRealm\"\261\004\n\032St"
  "oreBrowseItemDataRequest\022\026\n\016include_asse"
  "ts\030\001 \001(\010\022\027\n\017include_release\030\002 \001(\010\022\031\n\021inc"
  "lude_platforms\030\003 \001(\010\022$\n\034include_all_purc"
  "hase_options\030\004 \001(\010\022\033\n\023include_screenshot"
  "s\030\005 \001(\010\022\030\n\020include_trailers\030\006 \001(\010\022\027\n\017inc"
  "lude_ratings\030\007 \001(\010\022O\n\021include_tag_count\030"
  "\010 \001(\005B4\202\265\0300Count of tags to return, as t"
  "agids.  Maximum 20.\022\027\n\017include_reviews\030\t"
  " \001(\010\022P\n\022include_basic_info\030\n \001(\010B4\202\265\0300In"
  "clude short description, publisher, deve"
  "lopers\022s\n\033include_supported_languages\030\013 "
  "\001(\010BN\202\265\030Jincludes the games support for "
  "languages: supported, full_audio, subtit"
  "les\022 \n\030include_full_description\030\014 \001(\010\"\223\001"
  "\n\035CStoreBrowse_GetItems_Request\022\031\n\003ids\030\001"
  " \003(\0132\014.StoreItemID\022$\n\007context\030\002 \001(\0132\023.St"
  "oreBrowseContext\0221\n\014data_request\030\003 \001(\0132\033"
  ".StoreBrowseItemDataRequest\"\370\003\n\017StoreGam"
  "eRating\022%\n\004type\030\001 \001(\tB\027\202\265\030\023\'esrb\', \'pegi"
  "\', ...\0225\n\006rating\030\002 \001(\tB%\202\265\030!\'t\' for teen"
  ", \'m\' for mature, ...\022^\n\013descriptors\030\003 \003"
  "(\tBI\202\265\030EAdditional descriptors like \'Int"
  "ense Violence\', \'Strong Language\',...\022/\n"
  "\024interactive_elements\030\004 \001(\tB\021\202\265\030\rESRB-sp"
  "ecific\022Q\n\014required_age\030\n \001(\005B;\202\265\0307Age in"
  " years.  Store pages will prompt with an"
  " age gate\022\024\n\014use_age_gate\030\013 \001(\010\022<\n\timage"
  "_url\030\024 \001(\tB)\202\265\030%An image corresponding t"
  "o the rating.\022O\n\014image_target\030\025 \001(\tB9\202\265\030"
  "5URL where the image should link for mor"
  "e information.\"\357P\n\tStoreItem\022<\n\titem_typ"
  "e\030\001 \001(\0162\017.EStoreItemType:\030k_EStoreItemTy"
  "pe_Invalid\022\n\n\002id\030\002 \001(\r\0222\n\007success\030\003 \001(\rB"
  "!\202\265\030\035EResult of this lookup action\022\017\n\007vi"
  "sible\030\004 \001(\010\022}\n\"unvailable_for_country_re"
  "striction\030\005 \001(\010BQ\202\265\030MIndicates this app "
  "is visible in other regions, but not the"
  " requested reagion\022\014\n\004name\030\006 \001(\t\022`\n\016stor"
  "e_url_path\030\007 \001(\tBH\202\265\030DThe URL of this it"
  "em\'s store page, to be appended to STORE"
  "_BASE_URL.\022T\n\005appid\030\t \001(\rBE\202\265\030AIf this i"
  "s an app, or a single-app package, the s"
  "teamworks appid.\022\316\001\n\004type\030\n \001(\0162\016.EStore"
  "AppType:\024k_EStoreAppType_GameB\231\001\202\265\030\224\001Typ"
  "e of app (Game, Software, Music).  For p"
  "ackages/bundles, this will be the most i"
  "nteresting type (eg Game + Soundtrack bu"
  "ndle will have type Game)\022]\n\016included_ty"
  "pes\030\013 \003(\0162\016.EStoreAppTypeB5\202\265\0301For packa"
  "ges/bundles, all types of included items"
  "\022F\n\017included_appids\030\014 \003(\rB-\202\265\030)For packa"
  "ges/bundles, all included appids\022\017\n\007is_f"
  "ree\030\r \001(\010\022\027\n\017is_early_access\030\016 \001(\010\022.\n\rre"
  "lated_items\030\017 \001(\0132\027.StoreItem.RelatedIte"
  "ms\0224\n\025content_descriptorids\030\024 \003(\0162\025.ECon"
  "tentDescriptorID\022\016\n\006tagids\030\025 \003(\r\022)\n\ncate"
  "gories\030\026 \001(\0132\025.StoreItem.Categories\022#\n\007r"
  "eviews\030\027 \001(\0132\022.StoreItem.Reviews\022(\n\nbasi"
  "c_info\030\030 \001(\0132\024.StoreItem.BasicInfo\022\034\n\004ta"
  "gs\030\031 \003(\0132\016.StoreItem.Tag\022!\n\006assets\030\036 \001(\013"
  "2\021.StoreItem.Assets\022\'\n\007release\030\037 \001(\0132\026.S"
  "toreItem.ReleaseInfo\022\'\n\tplatforms\030  \001(\0132"
  "\024.StoreItem.Platforms\022^\n\013game_rating\030! \001"
  "(\0132\020.StoreGameRatingB7\202\265\0303Local ratings "
  "agency information, like ESRB or PEGI\022\214\001"
  "\n\024best_purchase_option\030( \001(\0132\031.StoreItem"
  ".PurchaseOptionBS\202\265\030OThe cheapest way fo"
  "r the user to acquire this app or packag"
  "e (may be a bundle).\022\256\001\n\020purchase_option"
  "s\030) \003(\0132\031.StoreItem.PurchaseOptionBy\202\265\030u"
  "Different ways to buy this app or packag"
  "es (packages can be purchased directly, "
  "but may also be included in bundles).\022\213\001"
  "\n\013accessories\030* \003(\0132\031.StoreItem.Purchase"
  "OptionB[\202\265\030WAdditional packages or bundl"
  "es associated with an app, but that do n"
  "ot contain the app.\022+\n\013screenshots\0302 \001(\013"
  "2\026.StoreItem.Screenshots\022%\n\010trailers\0303 \001"
  "(\0132\023.StoreItem.Trailers\0229\n\023supported_lan"
  "guages\0304 \003(\0132\034.StoreItem.SupportedLangua"
  "ge\022\336\001\n\027store_url_path_override\0305 \001(\tB\274\001\202"
  "\265\030\267\001Navigate to this URL (relative to st"
  "ore home) when the store capsule for thi"
  "s item is clicked, instead of the defaul"
  "t /app/... URL. Used by advertising apps"
  " that point to a sale page.\022Y\n\014free_week"
  "end\0306 \001(\0132\026.StoreItem.FreeWeekendB+\202\265\030\'I"
  "nformation about a free weekend offer.\022Q"
  "\n\010unlisted\0307 \001(\010B\?\202\265\030;If true, item is o"
  "nly accessible on store via a direct lin"
  "k\022L\n\ngame_count\0308 \001(\rB8\202\265\0304For creators "
  "and tags, how many games belong to them\022"
  "Y\n\rinternal_name\0309 \001(\tBB\202\265\030>For hub cate"
  "gories, the internal name (handle) of th"
  "e category\022G\n\020full_description\030: \001(\tB-\202\265"
  "\030)About this game section on the store p"
  "age\032T\n\014RelatedItems\022D\n\014parent_appid\030\001 \001("
  "\rB.\202\265\030*For DLC, Demos, etc, this is the "
  "main app.\032\306\002\n\nCategories\022Y\n\034supported_pl"
  "ayer_categoryids\030\002 \003(\rB3\202\265\030/Categories l"
  "ike Single Player, Multiplayer, MMO\022r\n\023f"
  "eature_categoryids\030\003 \003(\rBU\202\265\030QCategories"
  " indicating supported features like Stea"
  "m Cloud, VAC, Achievements, etc\022i\n\026contr"
  "oller_categoryids\030\004 \003(\rBI\202\265\030ECategories "
  "indicating controller support and full c"
  "ontroller support.\032\306\004\n\007Reviews\022\253\001\n\020summa"
  "ry_filtered\030\001 \001(\0132%.StoreItem.Reviews.St"
  "oreReviewSummaryBj\202\265\030fReview summary wit"
  "h review bombs removed (if any).  Always"
  " present (if include_reviews set in requ"
  "est)\022\232\001\n\022summary_unfiltered\030\002 \001(\0132%.Stor"
  "eItem.Reviews.StoreReviewSummaryBW\202\265\030SRe"
  "view summary with review bombs included."
  "  Only present if there are review bombs"
  ".\032\357\001\n\022StoreReviewSummary\022\024\n\014review_count"
  "\030\001 \001(\r\022#\n\020percent_positive\030\002 \001(\005B\t\202\265\030\0050-"
  "100\022@\n\014review_score\030\003 \001(\0162\021.EUserReviewS"
  "core:\027k_EUserReviewScore_None\022\\\n\022review_"
  "score_label\030\004 \001(\tB@\202\265\030<A string like \'Mi"
  "xed\', \'Negative\', \'Overwhelmingly Positi"
  "ve\'\032\214\004\n\tBasicInfo\022\031\n\021short_description\030\001"
  " \001(\t\0228\n\npublishers\030\002 \003(\0132$.StoreItem.Bas"
  "icInfo.CreatorHomeLink\0228\n\ndevelopers\030\003 \003"
  "(\0132$.StoreItem.BasicInfo.CreatorHomeLink"
  "\0228\n\nfranchises\030\004 \003(\0132$.StoreItem.BasicIn"
  "fo.CreatorHomeLink\022\214\001\n\020capsule_headline\030"
  "\005 \001(\tBr\202\265\030nA custom string specified by "
  "the partner for display on or around a c"
  "apsule on the store, e.g. \'Just Updated!"
  "\'\032\246\001\n\017CreatorHomeLink\022\014\n\004name\030\001 \001(\t\022\204\001\n\027"
  "creator_clan_account_id\030\002 \001(\rBc\202\265\030_Optio"
  "anl field indicating this name is associ"
  "ated this the creator home via the clan "
  "account id\032$\n\003Tag\022\r\n\005tagid\030\001 \001(\r\022\016\n\006weig"
  "ht\030\002 \001(\r\032\211\007\n\006Assets\022m\n\020asset_url_format\030"
  "\001 \001(\tBS\202\265\030OFormat for URLs, should subst"
  "itute the capsule name for ${FILENAME} i"
  "n the URL.\022\024\n\014main_capsule\030\002 \001(\t\022\025\n\rsmal"
  "l_capsule\030\003 \001(\t\022\177\n\006header\030\004 \001(\tBo\202\265\030kEqu"
  "ivalent to GetConstantRatioHeaderImage i"
  "n PHP; apps will always have this, packa"
  "ges and bundles may not.\022[\n\016package_head"
  "er\030\005 \001(\tBC\202\265\030\?A wider header used on pac"
  "kage/bundle pages.  Not set for apps.\022\027\n"
  "\017page_background\030\006 \001(\t\022!\n\014hero_capsule\030\007"
  " \001(\tB\013\202\265\030\007374x448\022=\n\017hero_capsule_2x\030\010 \001"
  "(\tB$\202\265\030 748x896 version of hero capsule."
  "\0229\n\017library_capsule\030\t \001(\tB \202\265\030\034300x450 -"
  " tall library asset\022<\n\022library_capsule_2"
  "x\030\n \001(\tB \202\265\030\034600x900 - tall library asse"
  "t\022O\n\014library_hero\030\013 \001(\tB9\202\265\0305960x310 or "
  "1920x620 - library detail background ass"
  "et\022T\n\017library_hero_2x\030\014 \001(\tB;\202\265\03071920x62"
  "0 or 3840x1240 - library detail backgrou"
  "nd asset\022U\n\016community_icon\030\r \001(\tB=\202\265\030932"
  "x32 jpg uploading via steamworks under c"
  "ommunity assets\022\023\n\013clan_avatar\030\016 \001(\t\032\302\010\n"
  "\013ReleaseInfo\022\220\001\n\022steam_release_date\030\001 \001("
  "\rBt\202\265\030pThe date this item first released"
  " on the Steam store.  For Early Access g"
  "raduates, this is their graduation day.\022"
  "w\n\025original_release_date\030\002 \001(\rBX\202\265\030TOpti"
  "onal; the date this item first released "
  "elsewhere, typically back catalog items."
  "\022o\n\033original_steam_release_date\030\003 \001(\rBJ\202"
  "\265\030FFor Early Access graduates, the date "
  "the game first appeared on Steam.\022\210\001\n\016is"
  "_coming_soon\030\004 \001(\010Bp\202\265\030lIs the app comin"
  "g soon\?  This flag should be preferred t"
  "o doing time comparisons against steam_r"
  "elease_date.\022V\n\nis_preload\030\005 \001(\010BB\202\265\030>Ca"
  "n the app be preloaded\?  Only applies to"
  " Coming Soon titles.\022v\n\033custom_release_d"
  "ate_message\030\006 \001(\tBQ\202\265\030MCustom release da"
  "te string.  steam_release_date will be u"
  "nset if this is set.\022\214\001\n\030is_abridged_rel"
  "ease_date\030\007 \001(\010Bj\202\265\030fRelease date should"
  " be displayed as month-year only.  steam"
  "_release_date is the last day of the mon"
  "th.\022}\n\023coming_soon_display\030\010 \001(\tB`\202\265\030\\On"
  "e of \'date_full\', \'date_month\', \'date_qu"
  "arter\', \'date_year\', \'text_comingsoon\', "
  "\'text_tba\'\022\027\n\017is_early_access\030\n \001(\010\022\030\n\020m"
  "ac_release_date\030\024 \001(\r\022\032\n\022linux_release_d"
  "ate\030\025 \001(\r\032\345\002\n\tPlatforms\022\017\n\007windows\030\001 \001(\010"
  "\022\013\n\003mac\030\002 \001(\010\022\025\n\rsteamos_linux\030\003 \001(\010\0222\n\n"
  "vr_support\030\n \001(\0132\036.StoreItem.Platforms.V"
  "RSupport\022o\n\032steam_deck_compat_category\030\013"
  " \001(\0162 .ESteamDeckCompatibilityCategory:)"
  "k_ESteamDeckCompatibilityCategory_Unknow"
  "n\032~\n\tVRSupport\022\r\n\005vrhmd\030\001 \001(\010\022\022\n\nvrhmd_o"
  "nly\030\002 \001(\010\022\020\n\010htc_vive\030( \001(\010\022\023\n\013oculus_ri"
  "ft\030) \001(\010\022\022\n\nwindows_mr\030* \001(\010\022\023\n\013valve_in"
  "dex\030+ \001(\010\032\320\016\n\016PurchaseOption\022\021\n\tpackagei"
  "d\030\001 \001(\005\022\020\n\010bundleid\030\002 \001(\005\022C\n\024purchase_op"
  "tion_name\030\003 \001(\tB%\202\265\030!The name of the pac"
  "kage or bundle\022c\n\024final_price_in_cents\030\005"
  " \001(\003BE\202\265\030AAlways set.  Includes any appl"
  "icable non user-specific discounts.\022c\n\027o"
  "riginal_price_in_cents\030\006 \001(\003BB\202\265\030>If dis"
  "counted, this is the price the item woul"
  "d normally cost.\022!\n\031user_final_price_in_"
  "cents\030\007 \001(\003\022j\n\025formatted_final_price\030\010 \001"
  "(\tBK\202\265\030GAlways set.  Formatted with curr"
  "ency symbol and decimal, like \'$10.00\'.\022"
  " \n\030formatted_original_price\030\t \001(\t\022X\n\014dis"
  "count_pct\030\n \001(\005BB\202\265\030>If discounted, calc"
  "ulated from final price and original pri"
  "ce.\022\031\n\021user_discount_pct\030\013 \001(\005\022\256\001\n\023bundl"
  "e_discount_pct\030\014 \001(\005B\220\001\202\265\030\213\001If this is a"
  " bundle, the savings from buying the bun"
  "dle.  If no bundle items are on active d"
  "iscount, this will be the same as discou"
  "nt_pct.\022r\n\020active_discounts\030\024 \003(\0132\".Stor"
  "eItem.PurchaseOption.DiscountB4\202\265\0300Disco"
  "unts included in discounted_price_in_cen"
  "ts.\022\207\001\n\025user_active_discounts\030\025 \003(\0132\".St"
  "oreItem.PurchaseOption.DiscountBD\202\265\030@Add"
  "itional discounts included in user_disco"
  "unted_price_in_cents.\022\215\001\n\022inactive_disco"
  "unts\030\026 \003(\0132\".StoreItem.PurchaseOption.Di"
  "scountBM\202\265\030IAdditional user-specific dis"
  "counts that do not apply to the current "
  "user.\022\031\n\021user_can_purchase\030\036 \001(\010\022!\n\031user"
  "_can_purchase_as_gift\030\037 \001(\010\022\?\n\025is_commer"
  "cial_license\030( \001(\010B \202\265\030\034This is a commer"
  "cial license\022n\n\034should_suppress_discount"
  "_pct\030) \001(\010BH\202\265\030DDon\'t show the discount "
  "percentage on a store capsule for this i"
  "tem.\022\206\001\n hide_discount_pct_for_complianc"
  "e\030* \001(\010:\005falseBU\202\265\030QDon\'t show the disco"
  "unt percent because there was a discount"
  " in the last 30 days.\022U\n\023included_game_c"
  "ount\030+ \001(\005B8\202\265\0304How many games are inclu"
  "ded in this purchase option.\022x\n\034lowest_r"
  "ecent_price_in_cents\030, \001(\003BR\202\265\030NLowest r"
  "ecent price in cents.  If not set, then "
  "there is no data so we ignore.\032\\\n\010Discou"
  "nt\022\027\n\017discount_amount\030\001 \001(\003\022\034\n\024discount_"
  "description\030\002 \001(\t\022\031\n\021discount_end_date\030\003"
  " \001(\r\032\371\004\n\013Screenshots\022g\n\024all_ages_screens"
  "hots\030\002 \003(\0132!.StoreItem.Screenshots.Scree"
  "nshotB&\202\265\030\"Screenshots suitable for all "
  "ages.\022\262\001\n\032mature_content_screenshots\030\003 \003"
  "(\0132!.StoreItem.Screenshots.ScreenshotBk\202"
  "\265\030gScreenshots that may contain mature c"
  "ontent; these should only be shown after"
  " verifying age (age gate).\032\313\002\n\nScreensho"
  "t\022\203\001\n\010filename\030\001 \001(\tBq\202\265\030mPath to file o"
  "n media CDN.  Can access sized version b"
  "y appending to SHA: \'.1920x1080\', \'.600x"
  "338\', \'.116x65\'\022\266\001\n\007ordinal\030\002 \001(\005B\244\001\202\265\030\237"
  "\001Screenshots should be displayed in orde"
  "r of ascending ordinal; they are returne"
  "d in-order but client may need to merge "
  "all_ages and mature_content_screenshots."
  "\032\324\007\n\010Trailers\022R\n\nhighlights\030\001 \003(\0132\033.Stor"
  "eItem.Trailers.TrailerB!\202\265\030\035Primary trai"
  "lers for this app\022\232\001\n\016other_trailers\030\002 \003"
  "(\0132\033.StoreItem.Trailers.TrailerBe\202\265\030aAdd"
  "itional trailers; on the app page, these"
  " are shown after screenshots (highlights"
  " shown before)\032\250\001\n\013VideoSource\0228\n\010filena"
  "me\030\001 \001(\tB&\202\265\030\"Substitute into trailer_ur"
  "l_format\022_\n\004type\030\002 \001(\tBQ\202\265\030M\'video/webm\'"
  " or \'video/mp4\'; can just put this direc"
  "tly in to a <source> tag.\032\253\004\n\007Trailer\022\024\n"
  "\014trailer_name\030\001 \001(\t\022g\n\022trailer_url_forma"
  "t\030\002 \001(\tBK\202\265\030GFormat for URLs, should sub"
  "stitute filename for ${FILENAME} in the "
  "URL.\0225\n\014trailer_480p\030\003 \003(\0132\037.StoreItem.T"
  "railers.VideoSource\0224\n\013trailer_max\030\004 \003(\013"
  "2\037.StoreItem.Trailers.VideoSource\0225\n\014mic"
  "rotrailer\030\005 \003(\0132\037.StoreItem.Trailers.Vid"
  "eoSource\022B\n\021screenshot_medium\030\n \001(\tB\'\202\265\030"
  "#293x165px.  Use trailer_url_format.\022O\n\017"
  "screenshot_full\030\013 \001(\tB6\202\265\0302Same size as "
  "trailer_max.  Use trailer_url_format.\022h\n"
  "\017trailer_base_id\030\014 \001(\005BO\202\265\030KTrailer ID. "
  " For localized trailers, this will be th"
  "e original trailer\'s ID\032o\n\021SupportedLang"
  "uage\022 \n\telanguage\030\001 \001(\005B\r\202\265\030\tELanguage\022\021"
  "\n\tsupported\030\002 \001(\010\022\022\n\nfull_audio\030\003 \001(\010\022\021\n"
  "\tsubtitles\030\004 \001(\010\032\275\001\n\013FreeWeekend\0225\n\nstar"
  "t_time\030\001 \001(\rB!\202\265\030\035When the free weekend "
  "starts.\0221\n\010end_time\030\002 \001(\rB\037\202\265\030\033When the "
  "free weekend ends.\022D\n\004text\030\003 \001(\tB6\202\265\0302Te"
  "xt to show as a description of the free "
  "weekend.\"A\n\036CStoreBrowse_GetItems_Respon"
  "se\022\037\n\013store_items\030\001 \003(\0132\n.StoreItem\"a\n\'C"
  "StoreBrowse_GetStoreCategories_Request\022\020"
  "\n\010language\030\001 \001(\t\022$\n\telanguage\030\002 \001(\005:\002-1B"
  "\r\202\265\030\tELanguage\"\241\003\n(CStoreBrowse_GetStore"
  "Categories_Response\022F\n\ncategories\030\001 \003(\0132"
  "2.CStoreBrowse_GetStoreCategories_Respon"
  "se.Category\032\254\002\n\010Category\022\022\n\ncategoryid\030\001"
  " \001(\r\022@\n\004type\030\002 \001(\0162\023.EStoreCategoryType:"
  "\035k_EStoreCategoryType_Category\022\025\n\rintern"
  "al_name\030\003 \001(\t\022\024\n\014display_name\030\004 \001(\t\022.\n\ti"
  "mage_url\030\005 \001(\tB\033\202\265\030\027Append to STORE_CDN_"
  "URL\022m\n\016show_in_search\030\006 \001(\010BU\202\265\030QIndicat"
  "es this category can link to search resu"
  "lts showing all items in category.\"\240\002\n\"C"
  "StoreBrowse_GetDLCForApps_Request\022$\n\007con"
  "text\030\001 \001(\0132\023.StoreBrowseContext\022,\n\021store"
  "_page_filter\030\002 \001(\0132\021.CStorePageFilter\022I\n"
  "\006appids\030\003 \003(\0132\014.StoreItemIDB+\202\265\030\'Apps fo"
  "r which we want DLC information.\022[\n\007stea"
  "mid\030\004 \001(\004BJ\202\265\030FIf specified, we want DLC"
  " information for all apps owned by this "
  "user.\"\314\003\n#CStoreBrowse_GetDLCForApps_Res"
  "ponse\022>\n\010dlc_data\030\001 \003(\0132,.CStoreBrowse_G"
  "etDLCForApps_Response.DLCData\022E\n\010playtim"
  "e\030\002 \003(\01323.CStoreBrowse_GetDLCForApps_Res"
  "ponse.PlaytimeForApp\032\207\001\n\007DLCData\022\r\n\005appi"
  "d\030\001 \001(\r\022\023\n\013parentappid\030\002 \001(\r\022\024\n\014release_"
  "date\030\003 \001(\r\022\023\n\013coming_soon\030\004 \001(\010\022\r\n\005price"
  "\030\005 \001(\003\022\020\n\010discount\030\006 \001(\r\022\014\n\004free\030\007 \001(\010\032\223"
  "\001\n\016PlaytimeForApp\022\r\n\005appid\030\001 \001(\r\0226\n\010play"
  "time\030\002 \001(\rB$\202\265\030 Total time played over a"
  "ll time.\022:\n\013last_played\030\003 \001(\rB%\202\265\030!Time "
  "last played on any platform.\"\253\001\n&CStoreB"
  "rowse_GetDLCForAppsSolr_Request\022$\n\007conte"
  "xt\030\001 \001(\0132\023.StoreBrowseContext\022\016\n\006appids\030"
  "\002 \003(\r\022\016\n\006flavor\030\003 \001(\t\022\r\n\005count\030\004 \001(\r\022,\n\021"
  "store_page_filter\030\005 \001(\0132\021.CStorePageFilt"
  "er\"\243\001\n\'CStoreBrowse_GetDLCForAppsSolr_Re"
  "sponse\022C\n\tdlc_lists\030\001 \003(\01320.CStoreBrowse"
  "_GetDLCForAppsSolr_Response.DLCList\0323\n\007D"
  "LCList\022\024\n\014parent_appid\030\001 \001(\r\022\022\n\ndlc_appi"
  "ds\030\002 \003(\r*\200\002\n\016EStoreItemType\022%\n\030k_EStoreI"
  "temType_Invalid\020\377\377\377\377\377\377\377\377\377\001\022\030\n\024k_EStoreIt"
  "emType_App\020\000\022\034\n\030k_EStoreItemType_Package"
  "\020\001\022\033\n\027k_EStoreItemType_Bundle\020\002\022\030\n\024k_ESt"
  "oreItemType_Mtx\020\003\022\030\n\024k_EStoreItemType_Ta"
  "g\020\004\022\034\n\030k_EStoreItemType_Creator\020\005\022 \n\034k_E"
  "StoreItemType_HubCategory\020\006*\253\003\n\rEStoreAp"
  "pType\022\030\n\024k_EStoreAppType_Game\020\000\022\030\n\024k_ESt"
  "oreAppType_Demo\020\001\022\027\n\023k_EStoreAppType_Mod"
  "\020\002\022\031\n\025k_EStoreAppType_Movie\020\003\022\027\n\023k_EStor"
  "eAppType_DLC\020\004\022\031\n\025k_EStoreAppType_Guide\020"
  "\005\022\034\n\030k_EStoreAppType_Software\020\006\022\031\n\025k_ESt"
  "oreAppType_Video\020\007\022\032\n\026k_EStoreAppType_Se"
  "ries\020\010\022\033\n\027k_EStoreAppType_Episode\020\t\022\034\n\030k"
  "_EStoreAppType_Hardware\020\n\022\031\n\025k_EStoreApp"
  "Type_Music\020\013\022\030\n\024k_EStoreAppType_Beta\020\014\022\030"
  "\n\024k_EStoreAppType_Tool\020\r\022\037\n\033k_EStoreAppT"
  "ype_Advertising\020\016*\205\003\n\020EUserReviewScore\022\033"
  "\n\027k_EUserReviewScore_None\020\000\022-\n)k_EUserRe"
  "viewScore_OverwhelminglyNegative\020\001\022#\n\037k_"
  "EUserReviewScore_VeryNegative\020\002\022\037\n\033k_EUs"
  "erReviewScore_Negative\020\003\022%\n!k_EUserRevie"
  "wScore_MostlyNegative\020\004\022\034\n\030k_EUserReview"
  "Score_Mixed\020\005\022%\n!k_EUserReviewScore_Most"
  "lyPositive\020\006\022\037\n\033k_EUserReviewScore_Posit"
  "ive\020\007\022#\n\037k_EUserReviewScore_VeryPositive"
  "\020\010\022-\n)k_EUserReviewScore_OverwhelminglyP"
  "ositive\020\t*\364\001\n\022EStoreCategoryType\022!\n\035k_ES"
  "toreCategoryType_Category\020\000\022)\n%k_EStoreC"
  "ategoryType_SupportedPlayers\020\001\022 \n\034k_ESto"
  "reCategoryType_Feature\020\002\022*\n&k_EStoreCate"
  "goryType_ControllerSupport\020\003\022$\n k_EStore"
  "CategoryType_CloudGaming\020\004\022\034\n\030k_EStoreCa"
  "tegoryType_MAX\020\0052\337\005\n\013StoreBrowse\022y\n\010GetI"
  "tems\022\036.CStoreBrowse_GetItems_Request\032\037.C"
  "StoreBrowse_GetItems_Response\",\202\265\030(Get i"
  "nformation about items on the store\022\370\001\n\022"
  "GetStoreCategories\022(.CStoreBrowse_GetSto"
  "reCategories_Request\032).CStoreBrowse_GetS"
  "toreCategories_Response\"\214\001\202\265\030\207\001Get categ"
  "ory definitions for store.  This is a pu"
  "blic-facing API (as compared to StoreCat"
  "alog.GetCategories, which is intended fo"
  "r PHP)\022\223\001\n\rGetDLCForApps\022#.CStoreBrowse_"
  "GetDLCForApps_Request\032$.CStoreBrowse_Get"
  "DLCForApps_Response\"7\202\265\0303Returns all DLC"
  " appids for games owned by the user.\022\233\001\n"
  "\021GetDLCForAppsSolr\022\'.CStoreBrowse_GetDLC"
  "ForAppsSolr_Request\032(.CStoreBrowse_GetDL"
  "CForAppsSolr_Response\"3\202\265\030/Returns all D"
  "LC appids for the specified games.\032&\202\265\030\""
  "APIs for accessing store item dataB\003\200\001\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_deps[5] = {
  &::descriptor_table_contenthubs_2eproto,
  &::descriptor_table_enums_2eproto,
  &::descriptor_table_enums_5fproductinfo_2eproto,
  &::descriptor_table_steammessages_5fbase_2eproto,
  &::descriptor_table_steammessages_5funified_5fbase_2esteamclient_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto = {
  false, false, 15799, descriptor_table_protodef_steammessages_5fstorebrowse_2esteamclient_2eproto, "steammessages_storebrowse.steamclient.proto", 
  &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once, descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_deps, 5, 37,
  schemas, file_default_instances, TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto::offsets,
  file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto, file_level_enum_descriptors_steammessages_5fstorebrowse_2esteamclient_2eproto, file_level_service_descriptors_steammessages_5fstorebrowse_2esteamclient_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter() {
  return &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_steammessages_5fstorebrowse_2esteamclient_2eproto(&descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStoreItemType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto);
  return file_level_enum_descriptors_steammessages_5fstorebrowse_2esteamclient_2eproto[0];
}
bool EStoreItemType_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStoreAppType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto);
  return file_level_enum_descriptors_steammessages_5fstorebrowse_2esteamclient_2eproto[1];
}
bool EStoreAppType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EUserReviewScore_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto);
  return file_level_enum_descriptors_steammessages_5fstorebrowse_2esteamclient_2eproto[2];
}
bool EUserReviewScore_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStoreCategoryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto);
  return file_level_enum_descriptors_steammessages_5fstorebrowse_2esteamclient_2eproto[3];
}
bool EStoreCategoryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class StoreItemID::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItemID>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_packageid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bundleid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tagid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_creatorid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_hubcategoryid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

StoreItemID::StoreItemID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItemID)
}
StoreItemID::StoreItemID(const StoreItemID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&hubcategoryid_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(hubcategoryid_));
  // @@protoc_insertion_point(copy_constructor:StoreItemID)
}

inline void StoreItemID::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hubcategoryid_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(hubcategoryid_));
}

StoreItemID::~StoreItemID() {
  // @@protoc_insertion_point(destructor:StoreItemID)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItemID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreItemID::ArenaDtor(void* object) {
  StoreItemID* _this = reinterpret_cast< StoreItemID* >(object);
  (void)_this;
}
void StoreItemID::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItemID::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItemID::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItemID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hubcategoryid_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(hubcategoryid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItemID::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 packageid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_packageid(&has_bits);
          packageid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bundleid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bundleid(&has_bits);
          bundleid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tagid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_tagid(&has_bits);
          tagid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 creatorid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_creatorid(&has_bits);
          creatorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hubcategoryid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_hubcategoryid(&has_bits);
          hubcategoryid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItemID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItemID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 packageid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_packageid(), target);
  }

  // optional uint32 bundleid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_bundleid(), target);
  }

  // optional uint32 tagid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_tagid(), target);
  }

  // optional uint32 creatorid = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_creatorid(), target);
  }

  // optional uint32 hubcategoryid = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_hubcategoryid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItemID)
  return target;
}

size_t StoreItemID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItemID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 packageid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_packageid());
    }

    // optional uint32 bundleid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_bundleid());
    }

    // optional uint32 tagid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_tagid());
    }

    // optional uint32 creatorid = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_creatorid());
    }

    // optional uint32 hubcategoryid = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_hubcategoryid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItemID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItemID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItemID::GetClassData() const { return &_class_data_; }

void StoreItemID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItemID *>(to)->MergeFrom(
      static_cast<const StoreItemID &>(from));
}


void StoreItemID::MergeFrom(const StoreItemID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItemID)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      packageid_ = from.packageid_;
    }
    if (cached_has_bits & 0x00000004u) {
      bundleid_ = from.bundleid_;
    }
    if (cached_has_bits & 0x00000008u) {
      tagid_ = from.tagid_;
    }
    if (cached_has_bits & 0x00000010u) {
      creatorid_ = from.creatorid_;
    }
    if (cached_has_bits & 0x00000020u) {
      hubcategoryid_ = from.hubcategoryid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItemID::CopyFrom(const StoreItemID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItemID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItemID::IsInitialized() const {
  return true;
}

void StoreItemID::InternalSwap(StoreItemID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItemID, hubcategoryid_)
      + sizeof(StoreItemID::hubcategoryid_)
      - PROTOBUF_FIELD_OFFSET(StoreItemID, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItemID::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[0]);
}

// ===================================================================

class StoreBrowseContext::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreBrowseContext>()._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_elanguage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_steam_realm(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

StoreBrowseContext::StoreBrowseContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreBrowseContext)
}
StoreBrowseContext::StoreBrowseContext(const StoreBrowseContext& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_language(), 
      GetArenaForAllocation());
  }
  country_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    country_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country_code()) {
    country_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_country_code(), 
      GetArenaForAllocation());
  }
  ::memcpy(&elanguage_, &from.elanguage_,
    static_cast<size_t>(reinterpret_cast<char*>(&steam_realm_) -
    reinterpret_cast<char*>(&elanguage_)) + sizeof(steam_realm_));
  // @@protoc_insertion_point(copy_constructor:StoreBrowseContext)
}

inline void StoreBrowseContext::SharedCtor() {
language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
country_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  country_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&elanguage_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&steam_realm_) -
    reinterpret_cast<char*>(&elanguage_)) + sizeof(steam_realm_));
}

StoreBrowseContext::~StoreBrowseContext() {
  // @@protoc_insertion_point(destructor:StoreBrowseContext)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreBrowseContext::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  language_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  country_code_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreBrowseContext::ArenaDtor(void* object) {
  StoreBrowseContext* _this = reinterpret_cast< StoreBrowseContext* >(object);
  (void)_this;
}
void StoreBrowseContext::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreBrowseContext::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreBrowseContext::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreBrowseContext)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      language_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      country_code_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&elanguage_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&steam_realm_) -
        reinterpret_cast<char*>(&elanguage_)) + sizeof(steam_realm_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreBrowseContext::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_language();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreBrowseContext.language");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 elanguage = 2 [(.description) = "ELanguage"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_elanguage(&has_bits);
          elanguage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string country_code = 3 [(.description) = "2-character country code; required"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_country_code();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreBrowseContext.country_code");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 steam_realm = 4 [(.description) = "ESteamRealm"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_steam_realm(&has_bits);
          steam_realm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreBrowseContext::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreBrowseContext)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string language = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreBrowseContext.language");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_language(), target);
  }

  // optional int32 elanguage = 2 [(.description) = "ELanguage"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_elanguage(), target);
  }

  // optional string country_code = 3 [(.description) = "2-character country code; required"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_country_code().data(), static_cast<int>(this->_internal_country_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreBrowseContext.country_code");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_country_code(), target);
  }

  // optional int32 steam_realm = 4 [(.description) = "ESteamRealm"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_steam_realm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreBrowseContext)
  return target;
}

size_t StoreBrowseContext::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreBrowseContext)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string language = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional string country_code = 3 [(.description) = "2-character country code; required"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country_code());
    }

    // optional int32 elanguage = 2 [(.description) = "ELanguage"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_elanguage());
    }

    // optional int32 steam_realm = 4 [(.description) = "ESteamRealm"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_steam_realm());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreBrowseContext::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreBrowseContext::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreBrowseContext::GetClassData() const { return &_class_data_; }

void StoreBrowseContext::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreBrowseContext *>(to)->MergeFrom(
      static_cast<const StoreBrowseContext &>(from));
}


void StoreBrowseContext::MergeFrom(const StoreBrowseContext& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreBrowseContext)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_country_code(from._internal_country_code());
    }
    if (cached_has_bits & 0x00000004u) {
      elanguage_ = from.elanguage_;
    }
    if (cached_has_bits & 0x00000008u) {
      steam_realm_ = from.steam_realm_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreBrowseContext::CopyFrom(const StoreBrowseContext& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreBrowseContext)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreBrowseContext::IsInitialized() const {
  return true;
}

void StoreBrowseContext::InternalSwap(StoreBrowseContext* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &language_, lhs_arena,
      &other->language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &country_code_, lhs_arena,
      &other->country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreBrowseContext, steam_realm_)
      + sizeof(StoreBrowseContext::steam_realm_)
      - PROTOBUF_FIELD_OFFSET(StoreBrowseContext, elanguage_)>(
          reinterpret_cast<char*>(&elanguage_),
          reinterpret_cast<char*>(&other->elanguage_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreBrowseContext::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[1]);
}

// ===================================================================

class StoreBrowseItemDataRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreBrowseItemDataRequest>()._has_bits_);
  static void set_has_include_assets(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_include_release(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_include_platforms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_include_all_purchase_options(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_include_screenshots(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_include_trailers(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_include_ratings(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_include_tag_count(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_include_reviews(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_include_basic_info(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_include_supported_languages(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_include_full_description(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

StoreBrowseItemDataRequest::StoreBrowseItemDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreBrowseItemDataRequest)
}
StoreBrowseItemDataRequest::StoreBrowseItemDataRequest(const StoreBrowseItemDataRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&include_assets_, &from.include_assets_,
    static_cast<size_t>(reinterpret_cast<char*>(&include_full_description_) -
    reinterpret_cast<char*>(&include_assets_)) + sizeof(include_full_description_));
  // @@protoc_insertion_point(copy_constructor:StoreBrowseItemDataRequest)
}

inline void StoreBrowseItemDataRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&include_assets_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&include_full_description_) -
    reinterpret_cast<char*>(&include_assets_)) + sizeof(include_full_description_));
}

StoreBrowseItemDataRequest::~StoreBrowseItemDataRequest() {
  // @@protoc_insertion_point(destructor:StoreBrowseItemDataRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreBrowseItemDataRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreBrowseItemDataRequest::ArenaDtor(void* object) {
  StoreBrowseItemDataRequest* _this = reinterpret_cast< StoreBrowseItemDataRequest* >(object);
  (void)_this;
}
void StoreBrowseItemDataRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreBrowseItemDataRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreBrowseItemDataRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreBrowseItemDataRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&include_assets_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&include_reviews_) -
        reinterpret_cast<char*>(&include_assets_)) + sizeof(include_reviews_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&include_tag_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&include_full_description_) -
        reinterpret_cast<char*>(&include_tag_count_)) + sizeof(include_full_description_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreBrowseItemDataRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool include_assets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_include_assets(&has_bits);
          include_assets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_release = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_include_release(&has_bits);
          include_release_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_platforms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_include_platforms(&has_bits);
          include_platforms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_all_purchase_options = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_include_all_purchase_options(&has_bits);
          include_all_purchase_options_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_screenshots = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_include_screenshots(&has_bits);
          include_screenshots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_trailers = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_include_trailers(&has_bits);
          include_trailers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_ratings = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_include_ratings(&has_bits);
          include_ratings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 include_tag_count = 8 [(.description) = "Count of tags to return, as tagids.  Maximum 20."];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_include_tag_count(&has_bits);
          include_tag_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_reviews = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_include_reviews(&has_bits);
          include_reviews_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_basic_info = 10 [(.description) = "Include short description, publisher, developers"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_include_basic_info(&has_bits);
          include_basic_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_supported_languages = 11 [(.description) = "includes the games support for languages: supported, full_audio, subtitles"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_include_supported_languages(&has_bits);
          include_supported_languages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_full_description = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_include_full_description(&has_bits);
          include_full_description_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreBrowseItemDataRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreBrowseItemDataRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool include_assets = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_include_assets(), target);
  }

  // optional bool include_release = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_include_release(), target);
  }

  // optional bool include_platforms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_include_platforms(), target);
  }

  // optional bool include_all_purchase_options = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_include_all_purchase_options(), target);
  }

  // optional bool include_screenshots = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_include_screenshots(), target);
  }

  // optional bool include_trailers = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_include_trailers(), target);
  }

  // optional bool include_ratings = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_include_ratings(), target);
  }

  // optional int32 include_tag_count = 8 [(.description) = "Count of tags to return, as tagids.  Maximum 20."];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_include_tag_count(), target);
  }

  // optional bool include_reviews = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_include_reviews(), target);
  }

  // optional bool include_basic_info = 10 [(.description) = "Include short description, publisher, developers"];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_include_basic_info(), target);
  }

  // optional bool include_supported_languages = 11 [(.description) = "includes the games support for languages: supported, full_audio, subtitles"];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_include_supported_languages(), target);
  }

  // optional bool include_full_description = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_include_full_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreBrowseItemDataRequest)
  return target;
}

size_t StoreBrowseItemDataRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreBrowseItemDataRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool include_assets = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool include_release = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool include_platforms = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool include_all_purchase_options = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool include_screenshots = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool include_trailers = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool include_ratings = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool include_reviews = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional int32 include_tag_count = 8 [(.description) = "Count of tags to return, as tagids.  Maximum 20."];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_include_tag_count());
    }

    // optional bool include_basic_info = 10 [(.description) = "Include short description, publisher, developers"];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool include_supported_languages = 11 [(.description) = "includes the games support for languages: supported, full_audio, subtitles"];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool include_full_description = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreBrowseItemDataRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreBrowseItemDataRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreBrowseItemDataRequest::GetClassData() const { return &_class_data_; }

void StoreBrowseItemDataRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreBrowseItemDataRequest *>(to)->MergeFrom(
      static_cast<const StoreBrowseItemDataRequest &>(from));
}


void StoreBrowseItemDataRequest::MergeFrom(const StoreBrowseItemDataRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreBrowseItemDataRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      include_assets_ = from.include_assets_;
    }
    if (cached_has_bits & 0x00000002u) {
      include_release_ = from.include_release_;
    }
    if (cached_has_bits & 0x00000004u) {
      include_platforms_ = from.include_platforms_;
    }
    if (cached_has_bits & 0x00000008u) {
      include_all_purchase_options_ = from.include_all_purchase_options_;
    }
    if (cached_has_bits & 0x00000010u) {
      include_screenshots_ = from.include_screenshots_;
    }
    if (cached_has_bits & 0x00000020u) {
      include_trailers_ = from.include_trailers_;
    }
    if (cached_has_bits & 0x00000040u) {
      include_ratings_ = from.include_ratings_;
    }
    if (cached_has_bits & 0x00000080u) {
      include_reviews_ = from.include_reviews_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      include_tag_count_ = from.include_tag_count_;
    }
    if (cached_has_bits & 0x00000200u) {
      include_basic_info_ = from.include_basic_info_;
    }
    if (cached_has_bits & 0x00000400u) {
      include_supported_languages_ = from.include_supported_languages_;
    }
    if (cached_has_bits & 0x00000800u) {
      include_full_description_ = from.include_full_description_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreBrowseItemDataRequest::CopyFrom(const StoreBrowseItemDataRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreBrowseItemDataRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreBrowseItemDataRequest::IsInitialized() const {
  return true;
}

void StoreBrowseItemDataRequest::InternalSwap(StoreBrowseItemDataRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreBrowseItemDataRequest, include_full_description_)
      + sizeof(StoreBrowseItemDataRequest::include_full_description_)
      - PROTOBUF_FIELD_OFFSET(StoreBrowseItemDataRequest, include_assets_)>(
          reinterpret_cast<char*>(&include_assets_),
          reinterpret_cast<char*>(&other->include_assets_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreBrowseItemDataRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[2]);
}

// ===================================================================

class CStoreBrowse_GetItems_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CStoreBrowse_GetItems_Request>()._has_bits_);
  static const ::StoreBrowseContext& context(const CStoreBrowse_GetItems_Request* msg);
  static void set_has_context(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::StoreBrowseItemDataRequest& data_request(const CStoreBrowse_GetItems_Request* msg);
  static void set_has_data_request(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::StoreBrowseContext&
CStoreBrowse_GetItems_Request::_Internal::context(const CStoreBrowse_GetItems_Request* msg) {
  return *msg->context_;
}
const ::StoreBrowseItemDataRequest&
CStoreBrowse_GetItems_Request::_Internal::data_request(const CStoreBrowse_GetItems_Request* msg) {
  return *msg->data_request_;
}
CStoreBrowse_GetItems_Request::CStoreBrowse_GetItems_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetItems_Request)
}
CStoreBrowse_GetItems_Request::CStoreBrowse_GetItems_Request(const CStoreBrowse_GetItems_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      ids_(from.ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_context()) {
    context_ = new ::StoreBrowseContext(*from.context_);
  } else {
    context_ = nullptr;
  }
  if (from._internal_has_data_request()) {
    data_request_ = new ::StoreBrowseItemDataRequest(*from.data_request_);
  } else {
    data_request_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetItems_Request)
}

inline void CStoreBrowse_GetItems_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&context_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&data_request_) -
    reinterpret_cast<char*>(&context_)) + sizeof(data_request_));
}

CStoreBrowse_GetItems_Request::~CStoreBrowse_GetItems_Request() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetItems_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetItems_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete context_;
  if (this != internal_default_instance()) delete data_request_;
}

void CStoreBrowse_GetItems_Request::ArenaDtor(void* object) {
  CStoreBrowse_GetItems_Request* _this = reinterpret_cast< CStoreBrowse_GetItems_Request* >(object);
  (void)_this;
}
void CStoreBrowse_GetItems_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetItems_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetItems_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetItems_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(context_ != nullptr);
      context_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(data_request_ != nullptr);
      data_request_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetItems_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .StoreItemID ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .StoreBrowseContext context = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreBrowseItemDataRequest data_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_data_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetItems_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetItems_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .StoreItemID ids = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ids_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_ids(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .StoreBrowseContext context = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::context(this), target, stream);
  }

  // optional .StoreBrowseItemDataRequest data_request = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::data_request(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetItems_Request)
  return target;
}

size_t CStoreBrowse_GetItems_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetItems_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .StoreItemID ids = 1;
  total_size += 1UL * this->_internal_ids_size();
  for (const auto& msg : this->ids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .StoreBrowseContext context = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *context_);
    }

    // optional .StoreBrowseItemDataRequest data_request = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_request_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetItems_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetItems_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetItems_Request::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetItems_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetItems_Request *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetItems_Request &>(from));
}


void CStoreBrowse_GetItems_Request::MergeFrom(const CStoreBrowse_GetItems_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetItems_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ids_.MergeFrom(from.ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_context()->::StoreBrowseContext::MergeFrom(from._internal_context());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_data_request()->::StoreBrowseItemDataRequest::MergeFrom(from._internal_data_request());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetItems_Request::CopyFrom(const CStoreBrowse_GetItems_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetItems_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetItems_Request::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetItems_Request::InternalSwap(CStoreBrowse_GetItems_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ids_.InternalSwap(&other->ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetItems_Request, data_request_)
      + sizeof(CStoreBrowse_GetItems_Request::data_request_)
      - PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetItems_Request, context_)>(
          reinterpret_cast<char*>(&context_),
          reinterpret_cast<char*>(&other->context_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetItems_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[3]);
}

// ===================================================================

class StoreGameRating::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreGameRating>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rating(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_interactive_elements(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_required_age(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_use_age_gate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_image_url(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_image_target(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

StoreGameRating::StoreGameRating(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  descriptors_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreGameRating)
}
StoreGameRating::StoreGameRating(const StoreGameRating& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      descriptors_(from.descriptors_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  rating_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    rating_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rating()) {
    rating_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_rating(), 
      GetArenaForAllocation());
  }
  interactive_elements_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    interactive_elements_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_interactive_elements()) {
    interactive_elements_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_interactive_elements(), 
      GetArenaForAllocation());
  }
  image_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image_url()) {
    image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_image_url(), 
      GetArenaForAllocation());
  }
  image_target_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    image_target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image_target()) {
    image_target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_image_target(), 
      GetArenaForAllocation());
  }
  ::memcpy(&required_age_, &from.required_age_,
    static_cast<size_t>(reinterpret_cast<char*>(&use_age_gate_) -
    reinterpret_cast<char*>(&required_age_)) + sizeof(use_age_gate_));
  // @@protoc_insertion_point(copy_constructor:StoreGameRating)
}

inline void StoreGameRating::SharedCtor() {
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
rating_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  rating_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
interactive_elements_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  interactive_elements_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
image_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
image_target_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  image_target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&required_age_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&use_age_gate_) -
    reinterpret_cast<char*>(&required_age_)) + sizeof(use_age_gate_));
}

StoreGameRating::~StoreGameRating() {
  // @@protoc_insertion_point(destructor:StoreGameRating)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreGameRating::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  rating_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  interactive_elements_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  image_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  image_target_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreGameRating::ArenaDtor(void* object) {
  StoreGameRating* _this = reinterpret_cast< StoreGameRating* >(object);
  (void)_this;
}
void StoreGameRating::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreGameRating::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreGameRating::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreGameRating)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  descriptors_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      rating_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      interactive_elements_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      image_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      image_target_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&required_age_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_age_gate_) -
        reinterpret_cast<char*>(&required_age_)) + sizeof(use_age_gate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreGameRating::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string type = 1 [(.description) = "\'esrb\', \'pegi\', ..."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreGameRating.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string rating = 2 [(.description) = "\'t\' for teen, \'m\' for mature, ..."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_rating();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreGameRating.rating");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string descriptors = 3 [(.description) = "Additional descriptors like \'Intense Violence\', \'Strong Language\',..."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_descriptors();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreGameRating.descriptors");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string interactive_elements = 4 [(.description) = "ESRB-specific"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_interactive_elements();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreGameRating.interactive_elements");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 required_age = 10 [(.description) = "Age in years.  Store pages will prompt with an age gate"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_required_age(&has_bits);
          required_age_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_age_gate = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_use_age_gate(&has_bits);
          use_age_gate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string image_url = 20 [(.description) = "An image corresponding to the rating."];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_image_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreGameRating.image_url");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string image_target = 21 [(.description) = "URL where the image should link for more information."];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_image_target();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreGameRating.image_target");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreGameRating::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreGameRating)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string type = 1 [(.description) = "\'esrb\', \'pegi\', ..."];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreGameRating.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional string rating = 2 [(.description) = "\'t\' for teen, \'m\' for mature, ..."];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_rating().data(), static_cast<int>(this->_internal_rating().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreGameRating.rating");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_rating(), target);
  }

  // repeated string descriptors = 3 [(.description) = "Additional descriptors like \'Intense Violence\', \'Strong Language\',..."];
  for (int i = 0, n = this->_internal_descriptors_size(); i < n; i++) {
    const auto& s = this->_internal_descriptors(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreGameRating.descriptors");
    target = stream->WriteString(3, s, target);
  }

  // optional string interactive_elements = 4 [(.description) = "ESRB-specific"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_interactive_elements().data(), static_cast<int>(this->_internal_interactive_elements().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreGameRating.interactive_elements");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_interactive_elements(), target);
  }

  // optional int32 required_age = 10 [(.description) = "Age in years.  Store pages will prompt with an age gate"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_required_age(), target);
  }

  // optional bool use_age_gate = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_use_age_gate(), target);
  }

  // optional string image_url = 20 [(.description) = "An image corresponding to the rating."];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_image_url().data(), static_cast<int>(this->_internal_image_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreGameRating.image_url");
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_image_url(), target);
  }

  // optional string image_target = 21 [(.description) = "URL where the image should link for more information."];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_image_target().data(), static_cast<int>(this->_internal_image_target().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreGameRating.image_target");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_image_target(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreGameRating)
  return target;
}

size_t StoreGameRating::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreGameRating)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string descriptors = 3 [(.description) = "Additional descriptors like \'Intense Violence\', \'Strong Language\',..."];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(descriptors_.size());
  for (int i = 0, n = descriptors_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      descriptors_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string type = 1 [(.description) = "\'esrb\', \'pegi\', ..."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string rating = 2 [(.description) = "\'t\' for teen, \'m\' for mature, ..."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rating());
    }

    // optional string interactive_elements = 4 [(.description) = "ESRB-specific"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_interactive_elements());
    }

    // optional string image_url = 20 [(.description) = "An image corresponding to the rating."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_image_url());
    }

    // optional string image_target = 21 [(.description) = "URL where the image should link for more information."];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_image_target());
    }

    // optional int32 required_age = 10 [(.description) = "Age in years.  Store pages will prompt with an age gate"];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_required_age());
    }

    // optional bool use_age_gate = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreGameRating::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreGameRating::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreGameRating::GetClassData() const { return &_class_data_; }

void StoreGameRating::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreGameRating *>(to)->MergeFrom(
      static_cast<const StoreGameRating &>(from));
}


void StoreGameRating::MergeFrom(const StoreGameRating& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreGameRating)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  descriptors_.MergeFrom(from.descriptors_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_rating(from._internal_rating());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_interactive_elements(from._internal_interactive_elements());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_image_url(from._internal_image_url());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_image_target(from._internal_image_target());
    }
    if (cached_has_bits & 0x00000020u) {
      required_age_ = from.required_age_;
    }
    if (cached_has_bits & 0x00000040u) {
      use_age_gate_ = from.use_age_gate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreGameRating::CopyFrom(const StoreGameRating& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreGameRating)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreGameRating::IsInitialized() const {
  return true;
}

void StoreGameRating::InternalSwap(StoreGameRating* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  descriptors_.InternalSwap(&other->descriptors_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &rating_, lhs_arena,
      &other->rating_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &interactive_elements_, lhs_arena,
      &other->interactive_elements_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &image_url_, lhs_arena,
      &other->image_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &image_target_, lhs_arena,
      &other->image_target_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreGameRating, use_age_gate_)
      + sizeof(StoreGameRating::use_age_gate_)
      - PROTOBUF_FIELD_OFFSET(StoreGameRating, required_age_)>(
          reinterpret_cast<char*>(&required_age_),
          reinterpret_cast<char*>(&other->required_age_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreGameRating::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[4]);
}

// ===================================================================

class StoreItem_RelatedItems::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_RelatedItems>()._has_bits_);
  static void set_has_parent_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StoreItem_RelatedItems::StoreItem_RelatedItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.RelatedItems)
}
StoreItem_RelatedItems::StoreItem_RelatedItems(const StoreItem_RelatedItems& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  parent_appid_ = from.parent_appid_;
  // @@protoc_insertion_point(copy_constructor:StoreItem.RelatedItems)
}

inline void StoreItem_RelatedItems::SharedCtor() {
parent_appid_ = 0u;
}

StoreItem_RelatedItems::~StoreItem_RelatedItems() {
  // @@protoc_insertion_point(destructor:StoreItem.RelatedItems)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_RelatedItems::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreItem_RelatedItems::ArenaDtor(void* object) {
  StoreItem_RelatedItems* _this = reinterpret_cast< StoreItem_RelatedItems* >(object);
  (void)_this;
}
void StoreItem_RelatedItems::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_RelatedItems::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_RelatedItems::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.RelatedItems)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  parent_appid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_RelatedItems::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 parent_appid = 1 [(.description) = "For DLC, Demos, etc, this is the main app."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_parent_appid(&has_bits);
          parent_appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_RelatedItems::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.RelatedItems)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 parent_appid = 1 [(.description) = "For DLC, Demos, etc, this is the main app."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_parent_appid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.RelatedItems)
  return target;
}

size_t StoreItem_RelatedItems::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.RelatedItems)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 parent_appid = 1 [(.description) = "For DLC, Demos, etc, this is the main app."];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_appid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_RelatedItems::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_RelatedItems::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_RelatedItems::GetClassData() const { return &_class_data_; }

void StoreItem_RelatedItems::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_RelatedItems *>(to)->MergeFrom(
      static_cast<const StoreItem_RelatedItems &>(from));
}


void StoreItem_RelatedItems::MergeFrom(const StoreItem_RelatedItems& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.RelatedItems)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_parent_appid()) {
    _internal_set_parent_appid(from._internal_parent_appid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_RelatedItems::CopyFrom(const StoreItem_RelatedItems& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.RelatedItems)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_RelatedItems::IsInitialized() const {
  return true;
}

void StoreItem_RelatedItems::InternalSwap(StoreItem_RelatedItems* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(parent_appid_, other->parent_appid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_RelatedItems::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[5]);
}

// ===================================================================

class StoreItem_Categories::_Internal {
 public:
};

StoreItem_Categories::StoreItem_Categories(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  supported_player_categoryids_(arena),
  feature_categoryids_(arena),
  controller_categoryids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Categories)
}
StoreItem_Categories::StoreItem_Categories(const StoreItem_Categories& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      supported_player_categoryids_(from.supported_player_categoryids_),
      feature_categoryids_(from.feature_categoryids_),
      controller_categoryids_(from.controller_categoryids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:StoreItem.Categories)
}

inline void StoreItem_Categories::SharedCtor() {
}

StoreItem_Categories::~StoreItem_Categories() {
  // @@protoc_insertion_point(destructor:StoreItem.Categories)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Categories::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreItem_Categories::ArenaDtor(void* object) {
  StoreItem_Categories* _this = reinterpret_cast< StoreItem_Categories* >(object);
  (void)_this;
}
void StoreItem_Categories::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Categories::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Categories::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Categories)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_player_categoryids_.Clear();
  feature_categoryids_.Clear();
  controller_categoryids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Categories::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 supported_player_categoryids = 2 [(.description) = "Categories like Single Player, Multiplayer, MMO"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_supported_player_categoryids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_supported_player_categoryids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 feature_categoryids = 3 [(.description) = "Categories indicating supported features like Steam Cloud, VAC, Achievements, etc"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_feature_categoryids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_feature_categoryids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 controller_categoryids = 4 [(.description) = "Categories indicating controller support and full controller support."];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_controller_categoryids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_controller_categoryids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Categories::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Categories)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 supported_player_categoryids = 2 [(.description) = "Categories like Single Player, Multiplayer, MMO"];
  for (int i = 0, n = this->_internal_supported_player_categoryids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_supported_player_categoryids(i), target);
  }

  // repeated uint32 feature_categoryids = 3 [(.description) = "Categories indicating supported features like Steam Cloud, VAC, Achievements, etc"];
  for (int i = 0, n = this->_internal_feature_categoryids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_feature_categoryids(i), target);
  }

  // repeated uint32 controller_categoryids = 4 [(.description) = "Categories indicating controller support and full controller support."];
  for (int i = 0, n = this->_internal_controller_categoryids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_controller_categoryids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Categories)
  return target;
}

size_t StoreItem_Categories::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Categories)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 supported_player_categoryids = 2 [(.description) = "Categories like Single Player, Multiplayer, MMO"];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->supported_player_categoryids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_supported_player_categoryids_size());
    total_size += data_size;
  }

  // repeated uint32 feature_categoryids = 3 [(.description) = "Categories indicating supported features like Steam Cloud, VAC, Achievements, etc"];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->feature_categoryids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_feature_categoryids_size());
    total_size += data_size;
  }

  // repeated uint32 controller_categoryids = 4 [(.description) = "Categories indicating controller support and full controller support."];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->controller_categoryids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_controller_categoryids_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Categories::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Categories::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Categories::GetClassData() const { return &_class_data_; }

void StoreItem_Categories::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Categories *>(to)->MergeFrom(
      static_cast<const StoreItem_Categories &>(from));
}


void StoreItem_Categories::MergeFrom(const StoreItem_Categories& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Categories)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  supported_player_categoryids_.MergeFrom(from.supported_player_categoryids_);
  feature_categoryids_.MergeFrom(from.feature_categoryids_);
  controller_categoryids_.MergeFrom(from.controller_categoryids_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Categories::CopyFrom(const StoreItem_Categories& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Categories)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Categories::IsInitialized() const {
  return true;
}

void StoreItem_Categories::InternalSwap(StoreItem_Categories* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  supported_player_categoryids_.InternalSwap(&other->supported_player_categoryids_);
  feature_categoryids_.InternalSwap(&other->feature_categoryids_);
  controller_categoryids_.InternalSwap(&other->controller_categoryids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Categories::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[6]);
}

// ===================================================================

class StoreItem_Reviews_StoreReviewSummary::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_Reviews_StoreReviewSummary>()._has_bits_);
  static void set_has_review_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_percent_positive(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_review_score(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_review_score_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StoreItem_Reviews_StoreReviewSummary::StoreItem_Reviews_StoreReviewSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Reviews.StoreReviewSummary)
}
StoreItem_Reviews_StoreReviewSummary::StoreItem_Reviews_StoreReviewSummary(const StoreItem_Reviews_StoreReviewSummary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  review_score_label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    review_score_label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_review_score_label()) {
    review_score_label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_review_score_label(), 
      GetArenaForAllocation());
  }
  ::memcpy(&review_count_, &from.review_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&review_score_) -
    reinterpret_cast<char*>(&review_count_)) + sizeof(review_score_));
  // @@protoc_insertion_point(copy_constructor:StoreItem.Reviews.StoreReviewSummary)
}

inline void StoreItem_Reviews_StoreReviewSummary::SharedCtor() {
review_score_label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  review_score_label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&review_count_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&review_score_) -
    reinterpret_cast<char*>(&review_count_)) + sizeof(review_score_));
}

StoreItem_Reviews_StoreReviewSummary::~StoreItem_Reviews_StoreReviewSummary() {
  // @@protoc_insertion_point(destructor:StoreItem.Reviews.StoreReviewSummary)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Reviews_StoreReviewSummary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  review_score_label_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_Reviews_StoreReviewSummary::ArenaDtor(void* object) {
  StoreItem_Reviews_StoreReviewSummary* _this = reinterpret_cast< StoreItem_Reviews_StoreReviewSummary* >(object);
  (void)_this;
}
void StoreItem_Reviews_StoreReviewSummary::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Reviews_StoreReviewSummary::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Reviews_StoreReviewSummary::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Reviews.StoreReviewSummary)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    review_score_label_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&review_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&review_score_) -
        reinterpret_cast<char*>(&review_count_)) + sizeof(review_score_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Reviews_StoreReviewSummary::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 review_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_review_count(&has_bits);
          review_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 percent_positive = 2 [(.description) = "0-100"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_percent_positive(&has_bits);
          percent_positive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EUserReviewScore review_score = 3 [default = k_EUserReviewScore_None];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EUserReviewScore_IsValid(val))) {
            _internal_set_review_score(static_cast<::EUserReviewScore>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string review_score_label = 4 [(.description) = "A string like \'Mixed\', \'Negative\', \'Overwhelmingly Positive\'"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_review_score_label();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Reviews.StoreReviewSummary.review_score_label");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Reviews_StoreReviewSummary::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Reviews.StoreReviewSummary)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 review_count = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_review_count(), target);
  }

  // optional int32 percent_positive = 2 [(.description) = "0-100"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_percent_positive(), target);
  }

  // optional .EUserReviewScore review_score = 3 [default = k_EUserReviewScore_None];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_review_score(), target);
  }

  // optional string review_score_label = 4 [(.description) = "A string like \'Mixed\', \'Negative\', \'Overwhelmingly Positive\'"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_review_score_label().data(), static_cast<int>(this->_internal_review_score_label().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Reviews.StoreReviewSummary.review_score_label");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_review_score_label(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Reviews.StoreReviewSummary)
  return target;
}

size_t StoreItem_Reviews_StoreReviewSummary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Reviews.StoreReviewSummary)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string review_score_label = 4 [(.description) = "A string like \'Mixed\', \'Negative\', \'Overwhelmingly Positive\'"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_review_score_label());
    }

    // optional uint32 review_count = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_review_count());
    }

    // optional int32 percent_positive = 2 [(.description) = "0-100"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_percent_positive());
    }

    // optional .EUserReviewScore review_score = 3 [default = k_EUserReviewScore_None];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_review_score());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Reviews_StoreReviewSummary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Reviews_StoreReviewSummary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Reviews_StoreReviewSummary::GetClassData() const { return &_class_data_; }

void StoreItem_Reviews_StoreReviewSummary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Reviews_StoreReviewSummary *>(to)->MergeFrom(
      static_cast<const StoreItem_Reviews_StoreReviewSummary &>(from));
}


void StoreItem_Reviews_StoreReviewSummary::MergeFrom(const StoreItem_Reviews_StoreReviewSummary& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Reviews.StoreReviewSummary)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_review_score_label(from._internal_review_score_label());
    }
    if (cached_has_bits & 0x00000002u) {
      review_count_ = from.review_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      percent_positive_ = from.percent_positive_;
    }
    if (cached_has_bits & 0x00000008u) {
      review_score_ = from.review_score_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Reviews_StoreReviewSummary::CopyFrom(const StoreItem_Reviews_StoreReviewSummary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Reviews.StoreReviewSummary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Reviews_StoreReviewSummary::IsInitialized() const {
  return true;
}

void StoreItem_Reviews_StoreReviewSummary::InternalSwap(StoreItem_Reviews_StoreReviewSummary* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &review_score_label_, lhs_arena,
      &other->review_score_label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem_Reviews_StoreReviewSummary, review_score_)
      + sizeof(StoreItem_Reviews_StoreReviewSummary::review_score_)
      - PROTOBUF_FIELD_OFFSET(StoreItem_Reviews_StoreReviewSummary, review_count_)>(
          reinterpret_cast<char*>(&review_count_),
          reinterpret_cast<char*>(&other->review_count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Reviews_StoreReviewSummary::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[7]);
}

// ===================================================================

class StoreItem_Reviews::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_Reviews>()._has_bits_);
  static const ::StoreItem_Reviews_StoreReviewSummary& summary_filtered(const StoreItem_Reviews* msg);
  static void set_has_summary_filtered(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::StoreItem_Reviews_StoreReviewSummary& summary_unfiltered(const StoreItem_Reviews* msg);
  static void set_has_summary_unfiltered(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::StoreItem_Reviews_StoreReviewSummary&
StoreItem_Reviews::_Internal::summary_filtered(const StoreItem_Reviews* msg) {
  return *msg->summary_filtered_;
}
const ::StoreItem_Reviews_StoreReviewSummary&
StoreItem_Reviews::_Internal::summary_unfiltered(const StoreItem_Reviews* msg) {
  return *msg->summary_unfiltered_;
}
StoreItem_Reviews::StoreItem_Reviews(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Reviews)
}
StoreItem_Reviews::StoreItem_Reviews(const StoreItem_Reviews& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_summary_filtered()) {
    summary_filtered_ = new ::StoreItem_Reviews_StoreReviewSummary(*from.summary_filtered_);
  } else {
    summary_filtered_ = nullptr;
  }
  if (from._internal_has_summary_unfiltered()) {
    summary_unfiltered_ = new ::StoreItem_Reviews_StoreReviewSummary(*from.summary_unfiltered_);
  } else {
    summary_unfiltered_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:StoreItem.Reviews)
}

inline void StoreItem_Reviews::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&summary_filtered_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&summary_unfiltered_) -
    reinterpret_cast<char*>(&summary_filtered_)) + sizeof(summary_unfiltered_));
}

StoreItem_Reviews::~StoreItem_Reviews() {
  // @@protoc_insertion_point(destructor:StoreItem.Reviews)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Reviews::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete summary_filtered_;
  if (this != internal_default_instance()) delete summary_unfiltered_;
}

void StoreItem_Reviews::ArenaDtor(void* object) {
  StoreItem_Reviews* _this = reinterpret_cast< StoreItem_Reviews* >(object);
  (void)_this;
}
void StoreItem_Reviews::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Reviews::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Reviews::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Reviews)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(summary_filtered_ != nullptr);
      summary_filtered_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(summary_unfiltered_ != nullptr);
      summary_unfiltered_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Reviews::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .StoreItem.Reviews.StoreReviewSummary summary_filtered = 1 [(.description) = "Review summary with review bombs removed (if any).  Always present (if include_reviews set in request)"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_summary_filtered(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.Reviews.StoreReviewSummary summary_unfiltered = 2 [(.description) = "Review summary with review bombs included.  Only present if there are review bombs."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_summary_unfiltered(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Reviews::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Reviews)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .StoreItem.Reviews.StoreReviewSummary summary_filtered = 1 [(.description) = "Review summary with review bombs removed (if any).  Always present (if include_reviews set in request)"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::summary_filtered(this), target, stream);
  }

  // optional .StoreItem.Reviews.StoreReviewSummary summary_unfiltered = 2 [(.description) = "Review summary with review bombs included.  Only present if there are review bombs."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::summary_unfiltered(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Reviews)
  return target;
}

size_t StoreItem_Reviews::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Reviews)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .StoreItem.Reviews.StoreReviewSummary summary_filtered = 1 [(.description) = "Review summary with review bombs removed (if any).  Always present (if include_reviews set in request)"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *summary_filtered_);
    }

    // optional .StoreItem.Reviews.StoreReviewSummary summary_unfiltered = 2 [(.description) = "Review summary with review bombs included.  Only present if there are review bombs."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *summary_unfiltered_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Reviews::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Reviews::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Reviews::GetClassData() const { return &_class_data_; }

void StoreItem_Reviews::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Reviews *>(to)->MergeFrom(
      static_cast<const StoreItem_Reviews &>(from));
}


void StoreItem_Reviews::MergeFrom(const StoreItem_Reviews& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Reviews)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_summary_filtered()->::StoreItem_Reviews_StoreReviewSummary::MergeFrom(from._internal_summary_filtered());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_summary_unfiltered()->::StoreItem_Reviews_StoreReviewSummary::MergeFrom(from._internal_summary_unfiltered());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Reviews::CopyFrom(const StoreItem_Reviews& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Reviews)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Reviews::IsInitialized() const {
  return true;
}

void StoreItem_Reviews::InternalSwap(StoreItem_Reviews* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem_Reviews, summary_unfiltered_)
      + sizeof(StoreItem_Reviews::summary_unfiltered_)
      - PROTOBUF_FIELD_OFFSET(StoreItem_Reviews, summary_filtered_)>(
          reinterpret_cast<char*>(&summary_filtered_),
          reinterpret_cast<char*>(&other->summary_filtered_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Reviews::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[8]);
}

// ===================================================================

class StoreItem_BasicInfo_CreatorHomeLink::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_BasicInfo_CreatorHomeLink>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_creator_clan_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StoreItem_BasicInfo_CreatorHomeLink::StoreItem_BasicInfo_CreatorHomeLink(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.BasicInfo.CreatorHomeLink)
}
StoreItem_BasicInfo_CreatorHomeLink::StoreItem_BasicInfo_CreatorHomeLink(const StoreItem_BasicInfo_CreatorHomeLink& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  creator_clan_account_id_ = from.creator_clan_account_id_;
  // @@protoc_insertion_point(copy_constructor:StoreItem.BasicInfo.CreatorHomeLink)
}

inline void StoreItem_BasicInfo_CreatorHomeLink::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
creator_clan_account_id_ = 0u;
}

StoreItem_BasicInfo_CreatorHomeLink::~StoreItem_BasicInfo_CreatorHomeLink() {
  // @@protoc_insertion_point(destructor:StoreItem.BasicInfo.CreatorHomeLink)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_BasicInfo_CreatorHomeLink::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_BasicInfo_CreatorHomeLink::ArenaDtor(void* object) {
  StoreItem_BasicInfo_CreatorHomeLink* _this = reinterpret_cast< StoreItem_BasicInfo_CreatorHomeLink* >(object);
  (void)_this;
}
void StoreItem_BasicInfo_CreatorHomeLink::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_BasicInfo_CreatorHomeLink::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_BasicInfo_CreatorHomeLink::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.BasicInfo.CreatorHomeLink)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  creator_clan_account_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_BasicInfo_CreatorHomeLink::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.BasicInfo.CreatorHomeLink.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 creator_clan_account_id = 2 [(.description) = "Optioanl field indicating this name is associated this the creator home via the clan account id"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_creator_clan_account_id(&has_bits);
          creator_clan_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_BasicInfo_CreatorHomeLink::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.BasicInfo.CreatorHomeLink)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.BasicInfo.CreatorHomeLink.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 creator_clan_account_id = 2 [(.description) = "Optioanl field indicating this name is associated this the creator home via the clan account id"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_creator_clan_account_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.BasicInfo.CreatorHomeLink)
  return target;
}

size_t StoreItem_BasicInfo_CreatorHomeLink::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.BasicInfo.CreatorHomeLink)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 creator_clan_account_id = 2 [(.description) = "Optioanl field indicating this name is associated this the creator home via the clan account id"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_creator_clan_account_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_BasicInfo_CreatorHomeLink::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_BasicInfo_CreatorHomeLink::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_BasicInfo_CreatorHomeLink::GetClassData() const { return &_class_data_; }

void StoreItem_BasicInfo_CreatorHomeLink::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_BasicInfo_CreatorHomeLink *>(to)->MergeFrom(
      static_cast<const StoreItem_BasicInfo_CreatorHomeLink &>(from));
}


void StoreItem_BasicInfo_CreatorHomeLink::MergeFrom(const StoreItem_BasicInfo_CreatorHomeLink& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.BasicInfo.CreatorHomeLink)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      creator_clan_account_id_ = from.creator_clan_account_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_BasicInfo_CreatorHomeLink::CopyFrom(const StoreItem_BasicInfo_CreatorHomeLink& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.BasicInfo.CreatorHomeLink)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_BasicInfo_CreatorHomeLink::IsInitialized() const {
  return true;
}

void StoreItem_BasicInfo_CreatorHomeLink::InternalSwap(StoreItem_BasicInfo_CreatorHomeLink* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(creator_clan_account_id_, other->creator_clan_account_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_BasicInfo_CreatorHomeLink::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[9]);
}

// ===================================================================

class StoreItem_BasicInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_BasicInfo>()._has_bits_);
  static void set_has_short_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_capsule_headline(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StoreItem_BasicInfo::StoreItem_BasicInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  publishers_(arena),
  developers_(arena),
  franchises_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.BasicInfo)
}
StoreItem_BasicInfo::StoreItem_BasicInfo(const StoreItem_BasicInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      publishers_(from.publishers_),
      developers_(from.developers_),
      franchises_(from.franchises_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  short_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    short_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_short_description()) {
    short_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_short_description(), 
      GetArenaForAllocation());
  }
  capsule_headline_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    capsule_headline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_capsule_headline()) {
    capsule_headline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_capsule_headline(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:StoreItem.BasicInfo)
}

inline void StoreItem_BasicInfo::SharedCtor() {
short_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  short_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
capsule_headline_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  capsule_headline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StoreItem_BasicInfo::~StoreItem_BasicInfo() {
  // @@protoc_insertion_point(destructor:StoreItem.BasicInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_BasicInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  short_description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  capsule_headline_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_BasicInfo::ArenaDtor(void* object) {
  StoreItem_BasicInfo* _this = reinterpret_cast< StoreItem_BasicInfo* >(object);
  (void)_this;
}
void StoreItem_BasicInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_BasicInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_BasicInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.BasicInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  publishers_.Clear();
  developers_.Clear();
  franchises_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      short_description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      capsule_headline_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_BasicInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string short_description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_short_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.BasicInfo.short_description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.BasicInfo.CreatorHomeLink publishers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_publishers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.BasicInfo.CreatorHomeLink developers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_developers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.BasicInfo.CreatorHomeLink franchises = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_franchises(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string capsule_headline = 5 [(.description) = "A custom string specified by the partner for display on or around a capsule on the store, e.g. \'Just Updated!\'"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_capsule_headline();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.BasicInfo.capsule_headline");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_BasicInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.BasicInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string short_description = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_short_description().data(), static_cast<int>(this->_internal_short_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.BasicInfo.short_description");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_short_description(), target);
  }

  // repeated .StoreItem.BasicInfo.CreatorHomeLink publishers = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_publishers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_publishers(i), target, stream);
  }

  // repeated .StoreItem.BasicInfo.CreatorHomeLink developers = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_developers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_developers(i), target, stream);
  }

  // repeated .StoreItem.BasicInfo.CreatorHomeLink franchises = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_franchises_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_franchises(i), target, stream);
  }

  // optional string capsule_headline = 5 [(.description) = "A custom string specified by the partner for display on or around a capsule on the store, e.g. \'Just Updated!\'"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_capsule_headline().data(), static_cast<int>(this->_internal_capsule_headline().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.BasicInfo.capsule_headline");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_capsule_headline(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.BasicInfo)
  return target;
}

size_t StoreItem_BasicInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.BasicInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .StoreItem.BasicInfo.CreatorHomeLink publishers = 2;
  total_size += 1UL * this->_internal_publishers_size();
  for (const auto& msg : this->publishers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.BasicInfo.CreatorHomeLink developers = 3;
  total_size += 1UL * this->_internal_developers_size();
  for (const auto& msg : this->developers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.BasicInfo.CreatorHomeLink franchises = 4;
  total_size += 1UL * this->_internal_franchises_size();
  for (const auto& msg : this->franchises_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string short_description = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_short_description());
    }

    // optional string capsule_headline = 5 [(.description) = "A custom string specified by the partner for display on or around a capsule on the store, e.g. \'Just Updated!\'"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_capsule_headline());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_BasicInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_BasicInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_BasicInfo::GetClassData() const { return &_class_data_; }

void StoreItem_BasicInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_BasicInfo *>(to)->MergeFrom(
      static_cast<const StoreItem_BasicInfo &>(from));
}


void StoreItem_BasicInfo::MergeFrom(const StoreItem_BasicInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.BasicInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  publishers_.MergeFrom(from.publishers_);
  developers_.MergeFrom(from.developers_);
  franchises_.MergeFrom(from.franchises_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_short_description(from._internal_short_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_capsule_headline(from._internal_capsule_headline());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_BasicInfo::CopyFrom(const StoreItem_BasicInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.BasicInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_BasicInfo::IsInitialized() const {
  return true;
}

void StoreItem_BasicInfo::InternalSwap(StoreItem_BasicInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  publishers_.InternalSwap(&other->publishers_);
  developers_.InternalSwap(&other->developers_);
  franchises_.InternalSwap(&other->franchises_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &short_description_, lhs_arena,
      &other->short_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &capsule_headline_, lhs_arena,
      &other->capsule_headline_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_BasicInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[10]);
}

// ===================================================================

class StoreItem_Tag::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_Tag>()._has_bits_);
  static void set_has_tagid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StoreItem_Tag::StoreItem_Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Tag)
}
StoreItem_Tag::StoreItem_Tag(const StoreItem_Tag& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&tagid_, &from.tagid_,
    static_cast<size_t>(reinterpret_cast<char*>(&weight_) -
    reinterpret_cast<char*>(&tagid_)) + sizeof(weight_));
  // @@protoc_insertion_point(copy_constructor:StoreItem.Tag)
}

inline void StoreItem_Tag::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tagid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&weight_) -
    reinterpret_cast<char*>(&tagid_)) + sizeof(weight_));
}

StoreItem_Tag::~StoreItem_Tag() {
  // @@protoc_insertion_point(destructor:StoreItem.Tag)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Tag::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreItem_Tag::ArenaDtor(void* object) {
  StoreItem_Tag* _this = reinterpret_cast< StoreItem_Tag* >(object);
  (void)_this;
}
void StoreItem_Tag::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Tag::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Tag::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Tag)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&tagid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&weight_) -
        reinterpret_cast<char*>(&tagid_)) + sizeof(weight_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Tag::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 tagid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tagid(&has_bits);
          tagid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 weight = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_weight(&has_bits);
          weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Tag::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Tag)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 tagid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tagid(), target);
  }

  // optional uint32 weight = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_weight(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Tag)
  return target;
}

size_t StoreItem_Tag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Tag)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 tagid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_tagid());
    }

    // optional uint32 weight = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_weight());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Tag::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Tag::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Tag::GetClassData() const { return &_class_data_; }

void StoreItem_Tag::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Tag *>(to)->MergeFrom(
      static_cast<const StoreItem_Tag &>(from));
}


void StoreItem_Tag::MergeFrom(const StoreItem_Tag& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Tag)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      tagid_ = from.tagid_;
    }
    if (cached_has_bits & 0x00000002u) {
      weight_ = from.weight_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Tag::CopyFrom(const StoreItem_Tag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Tag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Tag::IsInitialized() const {
  return true;
}

void StoreItem_Tag::InternalSwap(StoreItem_Tag* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem_Tag, weight_)
      + sizeof(StoreItem_Tag::weight_)
      - PROTOBUF_FIELD_OFFSET(StoreItem_Tag, tagid_)>(
          reinterpret_cast<char*>(&tagid_),
          reinterpret_cast<char*>(&other->tagid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Tag::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[11]);
}

// ===================================================================

class StoreItem_Assets::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_Assets>()._has_bits_);
  static void set_has_asset_url_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_main_capsule(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_small_capsule(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_package_header(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_page_background(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_hero_capsule(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_hero_capsule_2x(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_library_capsule(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_library_capsule_2x(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_library_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_library_hero_2x(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_community_icon(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_clan_avatar(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

StoreItem_Assets::StoreItem_Assets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Assets)
}
StoreItem_Assets::StoreItem_Assets(const StoreItem_Assets& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  asset_url_format_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    asset_url_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_asset_url_format()) {
    asset_url_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_asset_url_format(), 
      GetArenaForAllocation());
  }
  main_capsule_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    main_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_main_capsule()) {
    main_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_main_capsule(), 
      GetArenaForAllocation());
  }
  small_capsule_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    small_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_small_capsule()) {
    small_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_small_capsule(), 
      GetArenaForAllocation());
  }
  header_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_header()) {
    header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_header(), 
      GetArenaForAllocation());
  }
  package_header_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    package_header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_package_header()) {
    package_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_package_header(), 
      GetArenaForAllocation());
  }
  page_background_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    page_background_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_page_background()) {
    page_background_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_page_background(), 
      GetArenaForAllocation());
  }
  hero_capsule_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hero_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hero_capsule()) {
    hero_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hero_capsule(), 
      GetArenaForAllocation());
  }
  hero_capsule_2x_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hero_capsule_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hero_capsule_2x()) {
    hero_capsule_2x_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hero_capsule_2x(), 
      GetArenaForAllocation());
  }
  library_capsule_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    library_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_library_capsule()) {
    library_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_library_capsule(), 
      GetArenaForAllocation());
  }
  library_capsule_2x_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    library_capsule_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_library_capsule_2x()) {
    library_capsule_2x_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_library_capsule_2x(), 
      GetArenaForAllocation());
  }
  library_hero_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    library_hero_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_library_hero()) {
    library_hero_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_library_hero(), 
      GetArenaForAllocation());
  }
  library_hero_2x_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    library_hero_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_library_hero_2x()) {
    library_hero_2x_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_library_hero_2x(), 
      GetArenaForAllocation());
  }
  community_icon_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    community_icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_community_icon()) {
    community_icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_community_icon(), 
      GetArenaForAllocation());
  }
  clan_avatar_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clan_avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_clan_avatar()) {
    clan_avatar_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_clan_avatar(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:StoreItem.Assets)
}

inline void StoreItem_Assets::SharedCtor() {
asset_url_format_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  asset_url_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
main_capsule_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  main_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
small_capsule_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  small_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
header_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
package_header_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  package_header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
page_background_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  page_background_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hero_capsule_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hero_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hero_capsule_2x_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hero_capsule_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
library_capsule_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  library_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
library_capsule_2x_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  library_capsule_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
library_hero_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  library_hero_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
library_hero_2x_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  library_hero_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
community_icon_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  community_icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clan_avatar_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clan_avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StoreItem_Assets::~StoreItem_Assets() {
  // @@protoc_insertion_point(destructor:StoreItem.Assets)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Assets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  asset_url_format_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  main_capsule_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  small_capsule_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  header_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  package_header_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  page_background_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hero_capsule_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hero_capsule_2x_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  library_capsule_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  library_capsule_2x_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  library_hero_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  library_hero_2x_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  community_icon_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  clan_avatar_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_Assets::ArenaDtor(void* object) {
  StoreItem_Assets* _this = reinterpret_cast< StoreItem_Assets* >(object);
  (void)_this;
}
void StoreItem_Assets::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Assets::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Assets::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Assets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      asset_url_format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      main_capsule_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      small_capsule_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      header_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      package_header_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      page_background_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      hero_capsule_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      hero_capsule_2x_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      library_capsule_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      library_capsule_2x_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      library_hero_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      library_hero_2x_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00001000u) {
      community_icon_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00002000u) {
      clan_avatar_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Assets::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string asset_url_format = 1 [(.description) = "Format for URLs, should substitute the capsule name for ${FILENAME} in the URL."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_asset_url_format();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.asset_url_format");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string main_capsule = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_main_capsule();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.main_capsule");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string small_capsule = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_small_capsule();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.small_capsule");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string header = 4 [(.description) = "Equivalent to GetConstantRatioHeaderImage in PHP; apps will always have this, packages and bundles may not."];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_header();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.header");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string package_header = 5 [(.description) = "A wider header used on package/bundle pages.  Not set for apps."];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_package_header();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.package_header");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string page_background = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_page_background();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.page_background");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hero_capsule = 7 [(.description) = "374x448"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_hero_capsule();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.hero_capsule");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hero_capsule_2x = 8 [(.description) = "748x896 version of hero capsule."];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_hero_capsule_2x();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.hero_capsule_2x");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string library_capsule = 9 [(.description) = "300x450 - tall library asset"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_library_capsule();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.library_capsule");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string library_capsule_2x = 10 [(.description) = "600x900 - tall library asset"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_library_capsule_2x();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.library_capsule_2x");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string library_hero = 11 [(.description) = "960x310 or 1920x620 - library detail background asset"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_library_hero();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.library_hero");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string library_hero_2x = 12 [(.description) = "1920x620 or 3840x1240 - library detail background asset"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_library_hero_2x();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.library_hero_2x");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string community_icon = 13 [(.description) = "32x32 jpg uploading via steamworks under community assets"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_community_icon();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.community_icon");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string clan_avatar = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_clan_avatar();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Assets.clan_avatar");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Assets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Assets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string asset_url_format = 1 [(.description) = "Format for URLs, should substitute the capsule name for ${FILENAME} in the URL."];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_asset_url_format().data(), static_cast<int>(this->_internal_asset_url_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.asset_url_format");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_asset_url_format(), target);
  }

  // optional string main_capsule = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_main_capsule().data(), static_cast<int>(this->_internal_main_capsule().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.main_capsule");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_main_capsule(), target);
  }

  // optional string small_capsule = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_small_capsule().data(), static_cast<int>(this->_internal_small_capsule().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.small_capsule");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_small_capsule(), target);
  }

  // optional string header = 4 [(.description) = "Equivalent to GetConstantRatioHeaderImage in PHP; apps will always have this, packages and bundles may not."];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_header().data(), static_cast<int>(this->_internal_header().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.header");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_header(), target);
  }

  // optional string package_header = 5 [(.description) = "A wider header used on package/bundle pages.  Not set for apps."];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_package_header().data(), static_cast<int>(this->_internal_package_header().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.package_header");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_package_header(), target);
  }

  // optional string page_background = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_page_background().data(), static_cast<int>(this->_internal_page_background().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.page_background");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_page_background(), target);
  }

  // optional string hero_capsule = 7 [(.description) = "374x448"];
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hero_capsule().data(), static_cast<int>(this->_internal_hero_capsule().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.hero_capsule");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_hero_capsule(), target);
  }

  // optional string hero_capsule_2x = 8 [(.description) = "748x896 version of hero capsule."];
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hero_capsule_2x().data(), static_cast<int>(this->_internal_hero_capsule_2x().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.hero_capsule_2x");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_hero_capsule_2x(), target);
  }

  // optional string library_capsule = 9 [(.description) = "300x450 - tall library asset"];
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_library_capsule().data(), static_cast<int>(this->_internal_library_capsule().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.library_capsule");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_library_capsule(), target);
  }

  // optional string library_capsule_2x = 10 [(.description) = "600x900 - tall library asset"];
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_library_capsule_2x().data(), static_cast<int>(this->_internal_library_capsule_2x().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.library_capsule_2x");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_library_capsule_2x(), target);
  }

  // optional string library_hero = 11 [(.description) = "960x310 or 1920x620 - library detail background asset"];
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_library_hero().data(), static_cast<int>(this->_internal_library_hero().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.library_hero");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_library_hero(), target);
  }

  // optional string library_hero_2x = 12 [(.description) = "1920x620 or 3840x1240 - library detail background asset"];
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_library_hero_2x().data(), static_cast<int>(this->_internal_library_hero_2x().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.library_hero_2x");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_library_hero_2x(), target);
  }

  // optional string community_icon = 13 [(.description) = "32x32 jpg uploading via steamworks under community assets"];
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_community_icon().data(), static_cast<int>(this->_internal_community_icon().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.community_icon");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_community_icon(), target);
  }

  // optional string clan_avatar = 14;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_clan_avatar().data(), static_cast<int>(this->_internal_clan_avatar().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Assets.clan_avatar");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_clan_avatar(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Assets)
  return target;
}

size_t StoreItem_Assets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Assets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string asset_url_format = 1 [(.description) = "Format for URLs, should substitute the capsule name for ${FILENAME} in the URL."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_asset_url_format());
    }

    // optional string main_capsule = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_main_capsule());
    }

    // optional string small_capsule = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_small_capsule());
    }

    // optional string header = 4 [(.description) = "Equivalent to GetConstantRatioHeaderImage in PHP; apps will always have this, packages and bundles may not."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_header());
    }

    // optional string package_header = 5 [(.description) = "A wider header used on package/bundle pages.  Not set for apps."];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_package_header());
    }

    // optional string page_background = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_page_background());
    }

    // optional string hero_capsule = 7 [(.description) = "374x448"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hero_capsule());
    }

    // optional string hero_capsule_2x = 8 [(.description) = "748x896 version of hero capsule."];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hero_capsule_2x());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional string library_capsule = 9 [(.description) = "300x450 - tall library asset"];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_library_capsule());
    }

    // optional string library_capsule_2x = 10 [(.description) = "600x900 - tall library asset"];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_library_capsule_2x());
    }

    // optional string library_hero = 11 [(.description) = "960x310 or 1920x620 - library detail background asset"];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_library_hero());
    }

    // optional string library_hero_2x = 12 [(.description) = "1920x620 or 3840x1240 - library detail background asset"];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_library_hero_2x());
    }

    // optional string community_icon = 13 [(.description) = "32x32 jpg uploading via steamworks under community assets"];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_community_icon());
    }

    // optional string clan_avatar = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_clan_avatar());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Assets::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Assets::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Assets::GetClassData() const { return &_class_data_; }

void StoreItem_Assets::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Assets *>(to)->MergeFrom(
      static_cast<const StoreItem_Assets &>(from));
}


void StoreItem_Assets::MergeFrom(const StoreItem_Assets& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Assets)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_asset_url_format(from._internal_asset_url_format());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_main_capsule(from._internal_main_capsule());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_small_capsule(from._internal_small_capsule());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_header(from._internal_header());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_package_header(from._internal_package_header());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_page_background(from._internal_page_background());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_hero_capsule(from._internal_hero_capsule());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_hero_capsule_2x(from._internal_hero_capsule_2x());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_set_library_capsule(from._internal_library_capsule());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_set_library_capsule_2x(from._internal_library_capsule_2x());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_set_library_hero(from._internal_library_hero());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_set_library_hero_2x(from._internal_library_hero_2x());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_set_community_icon(from._internal_community_icon());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_set_clan_avatar(from._internal_clan_avatar());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Assets::CopyFrom(const StoreItem_Assets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Assets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Assets::IsInitialized() const {
  return true;
}

void StoreItem_Assets::InternalSwap(StoreItem_Assets* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &asset_url_format_, lhs_arena,
      &other->asset_url_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &main_capsule_, lhs_arena,
      &other->main_capsule_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &small_capsule_, lhs_arena,
      &other->small_capsule_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &header_, lhs_arena,
      &other->header_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &package_header_, lhs_arena,
      &other->package_header_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &page_background_, lhs_arena,
      &other->page_background_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hero_capsule_, lhs_arena,
      &other->hero_capsule_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hero_capsule_2x_, lhs_arena,
      &other->hero_capsule_2x_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &library_capsule_, lhs_arena,
      &other->library_capsule_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &library_capsule_2x_, lhs_arena,
      &other->library_capsule_2x_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &library_hero_, lhs_arena,
      &other->library_hero_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &library_hero_2x_, lhs_arena,
      &other->library_hero_2x_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &community_icon_, lhs_arena,
      &other->community_icon_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &clan_avatar_, lhs_arena,
      &other->clan_avatar_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Assets::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[12]);
}

// ===================================================================

class StoreItem_ReleaseInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_ReleaseInfo>()._has_bits_);
  static void set_has_steam_release_date(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_original_release_date(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_original_steam_release_date(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_coming_soon(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_preload(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_custom_release_date_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_abridged_release_date(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_coming_soon_display(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_early_access(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_mac_release_date(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_linux_release_date(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

StoreItem_ReleaseInfo::StoreItem_ReleaseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.ReleaseInfo)
}
StoreItem_ReleaseInfo::StoreItem_ReleaseInfo(const StoreItem_ReleaseInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  custom_release_date_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    custom_release_date_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_custom_release_date_message()) {
    custom_release_date_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_custom_release_date_message(), 
      GetArenaForAllocation());
  }
  coming_soon_display_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coming_soon_display_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coming_soon_display()) {
    coming_soon_display_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_coming_soon_display(), 
      GetArenaForAllocation());
  }
  ::memcpy(&steam_release_date_, &from.steam_release_date_,
    static_cast<size_t>(reinterpret_cast<char*>(&linux_release_date_) -
    reinterpret_cast<char*>(&steam_release_date_)) + sizeof(linux_release_date_));
  // @@protoc_insertion_point(copy_constructor:StoreItem.ReleaseInfo)
}

inline void StoreItem_ReleaseInfo::SharedCtor() {
custom_release_date_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  custom_release_date_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coming_soon_display_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coming_soon_display_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&steam_release_date_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&linux_release_date_) -
    reinterpret_cast<char*>(&steam_release_date_)) + sizeof(linux_release_date_));
}

StoreItem_ReleaseInfo::~StoreItem_ReleaseInfo() {
  // @@protoc_insertion_point(destructor:StoreItem.ReleaseInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_ReleaseInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  custom_release_date_message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  coming_soon_display_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_ReleaseInfo::ArenaDtor(void* object) {
  StoreItem_ReleaseInfo* _this = reinterpret_cast< StoreItem_ReleaseInfo* >(object);
  (void)_this;
}
void StoreItem_ReleaseInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_ReleaseInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_ReleaseInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.ReleaseInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      custom_release_date_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coming_soon_display_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&steam_release_date_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_abridged_release_date_) -
        reinterpret_cast<char*>(&steam_release_date_)) + sizeof(is_abridged_release_date_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&is_early_access_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&linux_release_date_) -
        reinterpret_cast<char*>(&is_early_access_)) + sizeof(linux_release_date_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_ReleaseInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 steam_release_date = 1 [(.description) = "The date this item first released on the Steam store.  For Early Access graduates, this is their graduation day."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_steam_release_date(&has_bits);
          steam_release_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 original_release_date = 2 [(.description) = "Optional; the date this item first released elsewhere, typically back catalog items."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_original_release_date(&has_bits);
          original_release_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 original_steam_release_date = 3 [(.description) = "For Early Access graduates, the date the game first appeared on Steam."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_original_steam_release_date(&has_bits);
          original_steam_release_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_coming_soon = 4 [(.description) = "Is the app coming soon?  This flag should be preferred to doing time comparisons against steam_release_date."];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_coming_soon(&has_bits);
          is_coming_soon_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_preload = 5 [(.description) = "Can the app be preloaded?  Only applies to Coming Soon titles."];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_preload(&has_bits);
          is_preload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string custom_release_date_message = 6 [(.description) = "Custom release date string.  steam_release_date will be unset if this is set."];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_custom_release_date_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.ReleaseInfo.custom_release_date_message");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_abridged_release_date = 7 [(.description) = "Release date should be displayed as month-year only.  steam_release_date is the last day of the month."];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_abridged_release_date(&has_bits);
          is_abridged_release_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string coming_soon_display = 8 [(.description) = "One of \'date_full\', \'date_month\', \'date_quarter\', \'date_year\', \'text_comingsoon\', \'text_tba\'"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_coming_soon_display();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.ReleaseInfo.coming_soon_display");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_early_access = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_early_access(&has_bits);
          is_early_access_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mac_release_date = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_mac_release_date(&has_bits);
          mac_release_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 linux_release_date = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_linux_release_date(&has_bits);
          linux_release_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_ReleaseInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.ReleaseInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 steam_release_date = 1 [(.description) = "The date this item first released on the Steam store.  For Early Access graduates, this is their graduation day."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_steam_release_date(), target);
  }

  // optional uint32 original_release_date = 2 [(.description) = "Optional; the date this item first released elsewhere, typically back catalog items."];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_original_release_date(), target);
  }

  // optional uint32 original_steam_release_date = 3 [(.description) = "For Early Access graduates, the date the game first appeared on Steam."];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_original_steam_release_date(), target);
  }

  // optional bool is_coming_soon = 4 [(.description) = "Is the app coming soon?  This flag should be preferred to doing time comparisons against steam_release_date."];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_coming_soon(), target);
  }

  // optional bool is_preload = 5 [(.description) = "Can the app be preloaded?  Only applies to Coming Soon titles."];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_preload(), target);
  }

  // optional string custom_release_date_message = 6 [(.description) = "Custom release date string.  steam_release_date will be unset if this is set."];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_custom_release_date_message().data(), static_cast<int>(this->_internal_custom_release_date_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.ReleaseInfo.custom_release_date_message");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_custom_release_date_message(), target);
  }

  // optional bool is_abridged_release_date = 7 [(.description) = "Release date should be displayed as month-year only.  steam_release_date is the last day of the month."];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_is_abridged_release_date(), target);
  }

  // optional string coming_soon_display = 8 [(.description) = "One of \'date_full\', \'date_month\', \'date_quarter\', \'date_year\', \'text_comingsoon\', \'text_tba\'"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coming_soon_display().data(), static_cast<int>(this->_internal_coming_soon_display().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.ReleaseInfo.coming_soon_display");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_coming_soon_display(), target);
  }

  // optional bool is_early_access = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_is_early_access(), target);
  }

  // optional uint32 mac_release_date = 20;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(20, this->_internal_mac_release_date(), target);
  }

  // optional uint32 linux_release_date = 21;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(21, this->_internal_linux_release_date(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.ReleaseInfo)
  return target;
}

size_t StoreItem_ReleaseInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.ReleaseInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string custom_release_date_message = 6 [(.description) = "Custom release date string.  steam_release_date will be unset if this is set."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_custom_release_date_message());
    }

    // optional string coming_soon_display = 8 [(.description) = "One of \'date_full\', \'date_month\', \'date_quarter\', \'date_year\', \'text_comingsoon\', \'text_tba\'"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coming_soon_display());
    }

    // optional uint32 steam_release_date = 1 [(.description) = "The date this item first released on the Steam store.  For Early Access graduates, this is their graduation day."];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_steam_release_date());
    }

    // optional uint32 original_release_date = 2 [(.description) = "Optional; the date this item first released elsewhere, typically back catalog items."];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_original_release_date());
    }

    // optional uint32 original_steam_release_date = 3 [(.description) = "For Early Access graduates, the date the game first appeared on Steam."];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_original_steam_release_date());
    }

    // optional bool is_coming_soon = 4 [(.description) = "Is the app coming soon?  This flag should be preferred to doing time comparisons against steam_release_date."];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_preload = 5 [(.description) = "Can the app be preloaded?  Only applies to Coming Soon titles."];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_abridged_release_date = 7 [(.description) = "Release date should be displayed as month-year only.  steam_release_date is the last day of the month."];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool is_early_access = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional uint32 mac_release_date = 20;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_mac_release_date());
    }

    // optional uint32 linux_release_date = 21;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_linux_release_date());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_ReleaseInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_ReleaseInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_ReleaseInfo::GetClassData() const { return &_class_data_; }

void StoreItem_ReleaseInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_ReleaseInfo *>(to)->MergeFrom(
      static_cast<const StoreItem_ReleaseInfo &>(from));
}


void StoreItem_ReleaseInfo::MergeFrom(const StoreItem_ReleaseInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.ReleaseInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_custom_release_date_message(from._internal_custom_release_date_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coming_soon_display(from._internal_coming_soon_display());
    }
    if (cached_has_bits & 0x00000004u) {
      steam_release_date_ = from.steam_release_date_;
    }
    if (cached_has_bits & 0x00000008u) {
      original_release_date_ = from.original_release_date_;
    }
    if (cached_has_bits & 0x00000010u) {
      original_steam_release_date_ = from.original_steam_release_date_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_coming_soon_ = from.is_coming_soon_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_preload_ = from.is_preload_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_abridged_release_date_ = from.is_abridged_release_date_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      is_early_access_ = from.is_early_access_;
    }
    if (cached_has_bits & 0x00000200u) {
      mac_release_date_ = from.mac_release_date_;
    }
    if (cached_has_bits & 0x00000400u) {
      linux_release_date_ = from.linux_release_date_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_ReleaseInfo::CopyFrom(const StoreItem_ReleaseInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.ReleaseInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_ReleaseInfo::IsInitialized() const {
  return true;
}

void StoreItem_ReleaseInfo::InternalSwap(StoreItem_ReleaseInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &custom_release_date_message_, lhs_arena,
      &other->custom_release_date_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &coming_soon_display_, lhs_arena,
      &other->coming_soon_display_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem_ReleaseInfo, linux_release_date_)
      + sizeof(StoreItem_ReleaseInfo::linux_release_date_)
      - PROTOBUF_FIELD_OFFSET(StoreItem_ReleaseInfo, steam_release_date_)>(
          reinterpret_cast<char*>(&steam_release_date_),
          reinterpret_cast<char*>(&other->steam_release_date_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_ReleaseInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[13]);
}

// ===================================================================

class StoreItem_Platforms_VRSupport::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_Platforms_VRSupport>()._has_bits_);
  static void set_has_vrhmd(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vrhmd_only(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_htc_vive(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_oculus_rift(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_windows_mr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_valve_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

StoreItem_Platforms_VRSupport::StoreItem_Platforms_VRSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Platforms.VRSupport)
}
StoreItem_Platforms_VRSupport::StoreItem_Platforms_VRSupport(const StoreItem_Platforms_VRSupport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&vrhmd_, &from.vrhmd_,
    static_cast<size_t>(reinterpret_cast<char*>(&valve_index_) -
    reinterpret_cast<char*>(&vrhmd_)) + sizeof(valve_index_));
  // @@protoc_insertion_point(copy_constructor:StoreItem.Platforms.VRSupport)
}

inline void StoreItem_Platforms_VRSupport::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vrhmd_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&valve_index_) -
    reinterpret_cast<char*>(&vrhmd_)) + sizeof(valve_index_));
}

StoreItem_Platforms_VRSupport::~StoreItem_Platforms_VRSupport() {
  // @@protoc_insertion_point(destructor:StoreItem.Platforms.VRSupport)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Platforms_VRSupport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreItem_Platforms_VRSupport::ArenaDtor(void* object) {
  StoreItem_Platforms_VRSupport* _this = reinterpret_cast< StoreItem_Platforms_VRSupport* >(object);
  (void)_this;
}
void StoreItem_Platforms_VRSupport::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Platforms_VRSupport::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Platforms_VRSupport::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Platforms.VRSupport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&vrhmd_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&valve_index_) -
        reinterpret_cast<char*>(&vrhmd_)) + sizeof(valve_index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Platforms_VRSupport::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool vrhmd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_vrhmd(&has_bits);
          vrhmd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool vrhmd_only = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vrhmd_only(&has_bits);
          vrhmd_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool htc_vive = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_htc_vive(&has_bits);
          htc_vive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool oculus_rift = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_oculus_rift(&has_bits);
          oculus_rift_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool windows_mr = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_windows_mr(&has_bits);
          windows_mr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool valve_index = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_valve_index(&has_bits);
          valve_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Platforms_VRSupport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Platforms.VRSupport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool vrhmd = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_vrhmd(), target);
  }

  // optional bool vrhmd_only = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_vrhmd_only(), target);
  }

  // optional bool htc_vive = 40;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(40, this->_internal_htc_vive(), target);
  }

  // optional bool oculus_rift = 41;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(41, this->_internal_oculus_rift(), target);
  }

  // optional bool windows_mr = 42;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(42, this->_internal_windows_mr(), target);
  }

  // optional bool valve_index = 43;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(43, this->_internal_valve_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Platforms.VRSupport)
  return target;
}

size_t StoreItem_Platforms_VRSupport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Platforms.VRSupport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bool vrhmd = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool vrhmd_only = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool htc_vive = 40;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 1;
    }

    // optional bool oculus_rift = 41;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 1;
    }

    // optional bool windows_mr = 42;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool valve_index = 43;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Platforms_VRSupport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Platforms_VRSupport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Platforms_VRSupport::GetClassData() const { return &_class_data_; }

void StoreItem_Platforms_VRSupport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Platforms_VRSupport *>(to)->MergeFrom(
      static_cast<const StoreItem_Platforms_VRSupport &>(from));
}


void StoreItem_Platforms_VRSupport::MergeFrom(const StoreItem_Platforms_VRSupport& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Platforms.VRSupport)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      vrhmd_ = from.vrhmd_;
    }
    if (cached_has_bits & 0x00000002u) {
      vrhmd_only_ = from.vrhmd_only_;
    }
    if (cached_has_bits & 0x00000004u) {
      htc_vive_ = from.htc_vive_;
    }
    if (cached_has_bits & 0x00000008u) {
      oculus_rift_ = from.oculus_rift_;
    }
    if (cached_has_bits & 0x00000010u) {
      windows_mr_ = from.windows_mr_;
    }
    if (cached_has_bits & 0x00000020u) {
      valve_index_ = from.valve_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Platforms_VRSupport::CopyFrom(const StoreItem_Platforms_VRSupport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Platforms.VRSupport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Platforms_VRSupport::IsInitialized() const {
  return true;
}

void StoreItem_Platforms_VRSupport::InternalSwap(StoreItem_Platforms_VRSupport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem_Platforms_VRSupport, valve_index_)
      + sizeof(StoreItem_Platforms_VRSupport::valve_index_)
      - PROTOBUF_FIELD_OFFSET(StoreItem_Platforms_VRSupport, vrhmd_)>(
          reinterpret_cast<char*>(&vrhmd_),
          reinterpret_cast<char*>(&other->vrhmd_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Platforms_VRSupport::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[14]);
}

// ===================================================================

class StoreItem_Platforms::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_Platforms>()._has_bits_);
  static void set_has_windows(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mac(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_steamos_linux(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::StoreItem_Platforms_VRSupport& vr_support(const StoreItem_Platforms* msg);
  static void set_has_vr_support(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_steam_deck_compat_category(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::StoreItem_Platforms_VRSupport&
StoreItem_Platforms::_Internal::vr_support(const StoreItem_Platforms* msg) {
  return *msg->vr_support_;
}
StoreItem_Platforms::StoreItem_Platforms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Platforms)
}
StoreItem_Platforms::StoreItem_Platforms(const StoreItem_Platforms& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_vr_support()) {
    vr_support_ = new ::StoreItem_Platforms_VRSupport(*from.vr_support_);
  } else {
    vr_support_ = nullptr;
  }
  ::memcpy(&windows_, &from.windows_,
    static_cast<size_t>(reinterpret_cast<char*>(&steam_deck_compat_category_) -
    reinterpret_cast<char*>(&windows_)) + sizeof(steam_deck_compat_category_));
  // @@protoc_insertion_point(copy_constructor:StoreItem.Platforms)
}

inline void StoreItem_Platforms::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vr_support_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&steam_deck_compat_category_) -
    reinterpret_cast<char*>(&vr_support_)) + sizeof(steam_deck_compat_category_));
}

StoreItem_Platforms::~StoreItem_Platforms() {
  // @@protoc_insertion_point(destructor:StoreItem.Platforms)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Platforms::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete vr_support_;
}

void StoreItem_Platforms::ArenaDtor(void* object) {
  StoreItem_Platforms* _this = reinterpret_cast< StoreItem_Platforms* >(object);
  (void)_this;
}
void StoreItem_Platforms::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Platforms::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Platforms::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Platforms)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(vr_support_ != nullptr);
    vr_support_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&windows_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&steam_deck_compat_category_) -
        reinterpret_cast<char*>(&windows_)) + sizeof(steam_deck_compat_category_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Platforms::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool windows = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_windows(&has_bits);
          windows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool mac = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_mac(&has_bits);
          mac_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool steamos_linux = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_steamos_linux(&has_bits);
          steamos_linux_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.Platforms.VRSupport vr_support = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_vr_support(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ESteamDeckCompatibilityCategory steam_deck_compat_category = 11 [default = k_ESteamDeckCompatibilityCategory_Unknown];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESteamDeckCompatibilityCategory_IsValid(val))) {
            _internal_set_steam_deck_compat_category(static_cast<::ESteamDeckCompatibilityCategory>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Platforms::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Platforms)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool windows = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_windows(), target);
  }

  // optional bool mac = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_mac(), target);
  }

  // optional bool steamos_linux = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_steamos_linux(), target);
  }

  // optional .StoreItem.Platforms.VRSupport vr_support = 10;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::vr_support(this), target, stream);
  }

  // optional .ESteamDeckCompatibilityCategory steam_deck_compat_category = 11 [default = k_ESteamDeckCompatibilityCategory_Unknown];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      11, this->_internal_steam_deck_compat_category(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Platforms)
  return target;
}

size_t StoreItem_Platforms::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Platforms)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .StoreItem.Platforms.VRSupport vr_support = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *vr_support_);
    }

    // optional bool windows = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool mac = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool steamos_linux = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional .ESteamDeckCompatibilityCategory steam_deck_compat_category = 11 [default = k_ESteamDeckCompatibilityCategory_Unknown];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_steam_deck_compat_category());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Platforms::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Platforms::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Platforms::GetClassData() const { return &_class_data_; }

void StoreItem_Platforms::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Platforms *>(to)->MergeFrom(
      static_cast<const StoreItem_Platforms &>(from));
}


void StoreItem_Platforms::MergeFrom(const StoreItem_Platforms& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Platforms)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_vr_support()->::StoreItem_Platforms_VRSupport::MergeFrom(from._internal_vr_support());
    }
    if (cached_has_bits & 0x00000002u) {
      windows_ = from.windows_;
    }
    if (cached_has_bits & 0x00000004u) {
      mac_ = from.mac_;
    }
    if (cached_has_bits & 0x00000008u) {
      steamos_linux_ = from.steamos_linux_;
    }
    if (cached_has_bits & 0x00000010u) {
      steam_deck_compat_category_ = from.steam_deck_compat_category_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Platforms::CopyFrom(const StoreItem_Platforms& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Platforms)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Platforms::IsInitialized() const {
  return true;
}

void StoreItem_Platforms::InternalSwap(StoreItem_Platforms* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem_Platforms, steam_deck_compat_category_)
      + sizeof(StoreItem_Platforms::steam_deck_compat_category_)
      - PROTOBUF_FIELD_OFFSET(StoreItem_Platforms, vr_support_)>(
          reinterpret_cast<char*>(&vr_support_),
          reinterpret_cast<char*>(&other->vr_support_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Platforms::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[15]);
}

// ===================================================================

class StoreItem_PurchaseOption_Discount::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_PurchaseOption_Discount>()._has_bits_);
  static void set_has_discount_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_discount_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_discount_end_date(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

StoreItem_PurchaseOption_Discount::StoreItem_PurchaseOption_Discount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.PurchaseOption.Discount)
}
StoreItem_PurchaseOption_Discount::StoreItem_PurchaseOption_Discount(const StoreItem_PurchaseOption_Discount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  discount_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    discount_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_discount_description()) {
    discount_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_discount_description(), 
      GetArenaForAllocation());
  }
  ::memcpy(&discount_amount_, &from.discount_amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&discount_end_date_) -
    reinterpret_cast<char*>(&discount_amount_)) + sizeof(discount_end_date_));
  // @@protoc_insertion_point(copy_constructor:StoreItem.PurchaseOption.Discount)
}

inline void StoreItem_PurchaseOption_Discount::SharedCtor() {
discount_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  discount_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&discount_amount_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&discount_end_date_) -
    reinterpret_cast<char*>(&discount_amount_)) + sizeof(discount_end_date_));
}

StoreItem_PurchaseOption_Discount::~StoreItem_PurchaseOption_Discount() {
  // @@protoc_insertion_point(destructor:StoreItem.PurchaseOption.Discount)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_PurchaseOption_Discount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  discount_description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_PurchaseOption_Discount::ArenaDtor(void* object) {
  StoreItem_PurchaseOption_Discount* _this = reinterpret_cast< StoreItem_PurchaseOption_Discount* >(object);
  (void)_this;
}
void StoreItem_PurchaseOption_Discount::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_PurchaseOption_Discount::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_PurchaseOption_Discount::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.PurchaseOption.Discount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    discount_description_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&discount_amount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&discount_end_date_) -
        reinterpret_cast<char*>(&discount_amount_)) + sizeof(discount_end_date_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_PurchaseOption_Discount::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 discount_amount = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_discount_amount(&has_bits);
          discount_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string discount_description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_discount_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.PurchaseOption.Discount.discount_description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 discount_end_date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_discount_end_date(&has_bits);
          discount_end_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_PurchaseOption_Discount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.PurchaseOption.Discount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 discount_amount = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_discount_amount(), target);
  }

  // optional string discount_description = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_discount_description().data(), static_cast<int>(this->_internal_discount_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.PurchaseOption.Discount.discount_description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_discount_description(), target);
  }

  // optional uint32 discount_end_date = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_discount_end_date(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.PurchaseOption.Discount)
  return target;
}

size_t StoreItem_PurchaseOption_Discount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.PurchaseOption.Discount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string discount_description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_discount_description());
    }

    // optional int64 discount_amount = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_discount_amount());
    }

    // optional uint32 discount_end_date = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_discount_end_date());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_PurchaseOption_Discount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_PurchaseOption_Discount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_PurchaseOption_Discount::GetClassData() const { return &_class_data_; }

void StoreItem_PurchaseOption_Discount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_PurchaseOption_Discount *>(to)->MergeFrom(
      static_cast<const StoreItem_PurchaseOption_Discount &>(from));
}


void StoreItem_PurchaseOption_Discount::MergeFrom(const StoreItem_PurchaseOption_Discount& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.PurchaseOption.Discount)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_discount_description(from._internal_discount_description());
    }
    if (cached_has_bits & 0x00000002u) {
      discount_amount_ = from.discount_amount_;
    }
    if (cached_has_bits & 0x00000004u) {
      discount_end_date_ = from.discount_end_date_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_PurchaseOption_Discount::CopyFrom(const StoreItem_PurchaseOption_Discount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.PurchaseOption.Discount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_PurchaseOption_Discount::IsInitialized() const {
  return true;
}

void StoreItem_PurchaseOption_Discount::InternalSwap(StoreItem_PurchaseOption_Discount* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &discount_description_, lhs_arena,
      &other->discount_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem_PurchaseOption_Discount, discount_end_date_)
      + sizeof(StoreItem_PurchaseOption_Discount::discount_end_date_)
      - PROTOBUF_FIELD_OFFSET(StoreItem_PurchaseOption_Discount, discount_amount_)>(
          reinterpret_cast<char*>(&discount_amount_),
          reinterpret_cast<char*>(&other->discount_amount_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_PurchaseOption_Discount::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[16]);
}

// ===================================================================

class StoreItem_PurchaseOption::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_PurchaseOption>()._has_bits_);
  static void set_has_packageid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bundleid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_purchase_option_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_final_price_in_cents(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_original_price_in_cents(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_user_final_price_in_cents(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_formatted_final_price(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_formatted_original_price(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_discount_pct(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_user_discount_pct(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_bundle_discount_pct(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_user_can_purchase(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_user_can_purchase_as_gift(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_is_commercial_license(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_should_suppress_discount_pct(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_hide_discount_pct_for_compliance(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_included_game_count(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_lowest_recent_price_in_cents(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

StoreItem_PurchaseOption::StoreItem_PurchaseOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  active_discounts_(arena),
  user_active_discounts_(arena),
  inactive_discounts_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.PurchaseOption)
}
StoreItem_PurchaseOption::StoreItem_PurchaseOption(const StoreItem_PurchaseOption& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      active_discounts_(from.active_discounts_),
      user_active_discounts_(from.user_active_discounts_),
      inactive_discounts_(from.inactive_discounts_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  purchase_option_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    purchase_option_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_purchase_option_name()) {
    purchase_option_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_purchase_option_name(), 
      GetArenaForAllocation());
  }
  formatted_final_price_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    formatted_final_price_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_formatted_final_price()) {
    formatted_final_price_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_formatted_final_price(), 
      GetArenaForAllocation());
  }
  formatted_original_price_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    formatted_original_price_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_formatted_original_price()) {
    formatted_original_price_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_formatted_original_price(), 
      GetArenaForAllocation());
  }
  ::memcpy(&packageid_, &from.packageid_,
    static_cast<size_t>(reinterpret_cast<char*>(&lowest_recent_price_in_cents_) -
    reinterpret_cast<char*>(&packageid_)) + sizeof(lowest_recent_price_in_cents_));
  // @@protoc_insertion_point(copy_constructor:StoreItem.PurchaseOption)
}

inline void StoreItem_PurchaseOption::SharedCtor() {
purchase_option_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  purchase_option_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
formatted_final_price_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  formatted_final_price_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
formatted_original_price_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  formatted_original_price_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&packageid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lowest_recent_price_in_cents_) -
    reinterpret_cast<char*>(&packageid_)) + sizeof(lowest_recent_price_in_cents_));
}

StoreItem_PurchaseOption::~StoreItem_PurchaseOption() {
  // @@protoc_insertion_point(destructor:StoreItem.PurchaseOption)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_PurchaseOption::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  purchase_option_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  formatted_final_price_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  formatted_original_price_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_PurchaseOption::ArenaDtor(void* object) {
  StoreItem_PurchaseOption* _this = reinterpret_cast< StoreItem_PurchaseOption* >(object);
  (void)_this;
}
void StoreItem_PurchaseOption::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_PurchaseOption::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_PurchaseOption::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.PurchaseOption)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  active_discounts_.Clear();
  user_active_discounts_.Clear();
  inactive_discounts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      purchase_option_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      formatted_final_price_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      formatted_original_price_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&packageid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&user_final_price_in_cents_) -
        reinterpret_cast<char*>(&packageid_)) + sizeof(user_final_price_in_cents_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&discount_pct_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hide_discount_pct_for_compliance_) -
        reinterpret_cast<char*>(&discount_pct_)) + sizeof(hide_discount_pct_for_compliance_));
  }
  if (cached_has_bits & 0x00030000u) {
    ::memset(&included_game_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lowest_recent_price_in_cents_) -
        reinterpret_cast<char*>(&included_game_count_)) + sizeof(lowest_recent_price_in_cents_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_PurchaseOption::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 packageid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_packageid(&has_bits);
          packageid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bundleid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bundleid(&has_bits);
          bundleid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string purchase_option_name = 3 [(.description) = "The name of the package or bundle"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_purchase_option_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.PurchaseOption.purchase_option_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 final_price_in_cents = 5 [(.description) = "Always set.  Includes any applicable non user-specific discounts."];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_final_price_in_cents(&has_bits);
          final_price_in_cents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 original_price_in_cents = 6 [(.description) = "If discounted, this is the price the item would normally cost."];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_original_price_in_cents(&has_bits);
          original_price_in_cents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 user_final_price_in_cents = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_user_final_price_in_cents(&has_bits);
          user_final_price_in_cents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string formatted_final_price = 8 [(.description) = "Always set.  Formatted with currency symbol and decimal, like \'$10.00\'."];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_formatted_final_price();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.PurchaseOption.formatted_final_price");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string formatted_original_price = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_formatted_original_price();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.PurchaseOption.formatted_original_price");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 discount_pct = 10 [(.description) = "If discounted, calculated from final price and original price."];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_discount_pct(&has_bits);
          discount_pct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 user_discount_pct = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_user_discount_pct(&has_bits);
          user_discount_pct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bundle_discount_pct = 12 [(.description) = "If this is a bundle, the savings from buying the bundle.  If no bundle items are on active discount, this will be the same as discount_pct."];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_bundle_discount_pct(&has_bits);
          bundle_discount_pct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.PurchaseOption.Discount active_discounts = 20 [(.description) = "Discounts included in discounted_price_in_cents."];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_active_discounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.PurchaseOption.Discount user_active_discounts = 21 [(.description) = "Additional discounts included in user_discounted_price_in_cents."];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_user_active_discounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.PurchaseOption.Discount inactive_discounts = 22 [(.description) = "Additional user-specific discounts that do not apply to the current user."];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_inactive_discounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool user_can_purchase = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_user_can_purchase(&has_bits);
          user_can_purchase_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool user_can_purchase_as_gift = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_user_can_purchase_as_gift(&has_bits);
          user_can_purchase_as_gift_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_commercial_license = 40 [(.description) = "This is a commercial license"];
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is_commercial_license(&has_bits);
          is_commercial_license_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool should_suppress_discount_pct = 41 [(.description) = "Don\'t show the discount percentage on a store capsule for this item."];
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_should_suppress_discount_pct(&has_bits);
          should_suppress_discount_pct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hide_discount_pct_for_compliance = 42 [default = false, (.description) = "Don\'t show the discount percent because there was a discount in the last 30 days."];
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_hide_discount_pct_for_compliance(&has_bits);
          hide_discount_pct_for_compliance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 included_game_count = 43 [(.description) = "How many games are included in this purchase option."];
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_included_game_count(&has_bits);
          included_game_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 lowest_recent_price_in_cents = 44 [(.description) = "Lowest recent price in cents.  If not set, then there is no data so we ignore."];
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_lowest_recent_price_in_cents(&has_bits);
          lowest_recent_price_in_cents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_PurchaseOption::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.PurchaseOption)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 packageid = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_packageid(), target);
  }

  // optional int32 bundleid = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_bundleid(), target);
  }

  // optional string purchase_option_name = 3 [(.description) = "The name of the package or bundle"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_purchase_option_name().data(), static_cast<int>(this->_internal_purchase_option_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.PurchaseOption.purchase_option_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_purchase_option_name(), target);
  }

  // optional int64 final_price_in_cents = 5 [(.description) = "Always set.  Includes any applicable non user-specific discounts."];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_final_price_in_cents(), target);
  }

  // optional int64 original_price_in_cents = 6 [(.description) = "If discounted, this is the price the item would normally cost."];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_original_price_in_cents(), target);
  }

  // optional int64 user_final_price_in_cents = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_user_final_price_in_cents(), target);
  }

  // optional string formatted_final_price = 8 [(.description) = "Always set.  Formatted with currency symbol and decimal, like \'$10.00\'."];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_formatted_final_price().data(), static_cast<int>(this->_internal_formatted_final_price().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.PurchaseOption.formatted_final_price");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_formatted_final_price(), target);
  }

  // optional string formatted_original_price = 9;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_formatted_original_price().data(), static_cast<int>(this->_internal_formatted_original_price().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.PurchaseOption.formatted_original_price");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_formatted_original_price(), target);
  }

  // optional int32 discount_pct = 10 [(.description) = "If discounted, calculated from final price and original price."];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_discount_pct(), target);
  }

  // optional int32 user_discount_pct = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_user_discount_pct(), target);
  }

  // optional int32 bundle_discount_pct = 12 [(.description) = "If this is a bundle, the savings from buying the bundle.  If no bundle items are on active discount, this will be the same as discount_pct."];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_bundle_discount_pct(), target);
  }

  // repeated .StoreItem.PurchaseOption.Discount active_discounts = 20 [(.description) = "Discounts included in discounted_price_in_cents."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_active_discounts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_active_discounts(i), target, stream);
  }

  // repeated .StoreItem.PurchaseOption.Discount user_active_discounts = 21 [(.description) = "Additional discounts included in user_discounted_price_in_cents."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_user_active_discounts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, this->_internal_user_active_discounts(i), target, stream);
  }

  // repeated .StoreItem.PurchaseOption.Discount inactive_discounts = 22 [(.description) = "Additional user-specific discounts that do not apply to the current user."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_inactive_discounts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, this->_internal_inactive_discounts(i), target, stream);
  }

  // optional bool user_can_purchase = 30;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(30, this->_internal_user_can_purchase(), target);
  }

  // optional bool user_can_purchase_as_gift = 31;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(31, this->_internal_user_can_purchase_as_gift(), target);
  }

  // optional bool is_commercial_license = 40 [(.description) = "This is a commercial license"];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(40, this->_internal_is_commercial_license(), target);
  }

  // optional bool should_suppress_discount_pct = 41 [(.description) = "Don\'t show the discount percentage on a store capsule for this item."];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(41, this->_internal_should_suppress_discount_pct(), target);
  }

  // optional bool hide_discount_pct_for_compliance = 42 [default = false, (.description) = "Don\'t show the discount percent because there was a discount in the last 30 days."];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(42, this->_internal_hide_discount_pct_for_compliance(), target);
  }

  // optional int32 included_game_count = 43 [(.description) = "How many games are included in this purchase option."];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(43, this->_internal_included_game_count(), target);
  }

  // optional int64 lowest_recent_price_in_cents = 44 [(.description) = "Lowest recent price in cents.  If not set, then there is no data so we ignore."];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(44, this->_internal_lowest_recent_price_in_cents(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.PurchaseOption)
  return target;
}

size_t StoreItem_PurchaseOption::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.PurchaseOption)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .StoreItem.PurchaseOption.Discount active_discounts = 20 [(.description) = "Discounts included in discounted_price_in_cents."];
  total_size += 2UL * this->_internal_active_discounts_size();
  for (const auto& msg : this->active_discounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.PurchaseOption.Discount user_active_discounts = 21 [(.description) = "Additional discounts included in user_discounted_price_in_cents."];
  total_size += 2UL * this->_internal_user_active_discounts_size();
  for (const auto& msg : this->user_active_discounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.PurchaseOption.Discount inactive_discounts = 22 [(.description) = "Additional user-specific discounts that do not apply to the current user."];
  total_size += 2UL * this->_internal_inactive_discounts_size();
  for (const auto& msg : this->inactive_discounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string purchase_option_name = 3 [(.description) = "The name of the package or bundle"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_purchase_option_name());
    }

    // optional string formatted_final_price = 8 [(.description) = "Always set.  Formatted with currency symbol and decimal, like \'$10.00\'."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_formatted_final_price());
    }

    // optional string formatted_original_price = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_formatted_original_price());
    }

    // optional int32 packageid = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_packageid());
    }

    // optional int32 bundleid = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_bundleid());
    }

    // optional int64 final_price_in_cents = 5 [(.description) = "Always set.  Includes any applicable non user-specific discounts."];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_final_price_in_cents());
    }

    // optional int64 original_price_in_cents = 6 [(.description) = "If discounted, this is the price the item would normally cost."];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_original_price_in_cents());
    }

    // optional int64 user_final_price_in_cents = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_user_final_price_in_cents());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 discount_pct = 10 [(.description) = "If discounted, calculated from final price and original price."];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_discount_pct());
    }

    // optional int32 user_discount_pct = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_user_discount_pct());
    }

    // optional int32 bundle_discount_pct = 12 [(.description) = "If this is a bundle, the savings from buying the bundle.  If no bundle items are on active discount, this will be the same as discount_pct."];
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_bundle_discount_pct());
    }

    // optional bool user_can_purchase = 30;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool user_can_purchase_as_gift = 31;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool is_commercial_license = 40 [(.description) = "This is a commercial license"];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool should_suppress_discount_pct = 41 [(.description) = "Don\'t show the discount percentage on a store capsule for this item."];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool hide_discount_pct_for_compliance = 42 [default = false, (.description) = "Don\'t show the discount percent because there was a discount in the last 30 days."];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional int32 included_game_count = 43 [(.description) = "How many games are included in this purchase option."];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_included_game_count());
    }

    // optional int64 lowest_recent_price_in_cents = 44 [(.description) = "Lowest recent price in cents.  If not set, then there is no data so we ignore."];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_lowest_recent_price_in_cents());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_PurchaseOption::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_PurchaseOption::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_PurchaseOption::GetClassData() const { return &_class_data_; }

void StoreItem_PurchaseOption::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_PurchaseOption *>(to)->MergeFrom(
      static_cast<const StoreItem_PurchaseOption &>(from));
}


void StoreItem_PurchaseOption::MergeFrom(const StoreItem_PurchaseOption& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.PurchaseOption)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  active_discounts_.MergeFrom(from.active_discounts_);
  user_active_discounts_.MergeFrom(from.user_active_discounts_);
  inactive_discounts_.MergeFrom(from.inactive_discounts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_purchase_option_name(from._internal_purchase_option_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_formatted_final_price(from._internal_formatted_final_price());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_formatted_original_price(from._internal_formatted_original_price());
    }
    if (cached_has_bits & 0x00000008u) {
      packageid_ = from.packageid_;
    }
    if (cached_has_bits & 0x00000010u) {
      bundleid_ = from.bundleid_;
    }
    if (cached_has_bits & 0x00000020u) {
      final_price_in_cents_ = from.final_price_in_cents_;
    }
    if (cached_has_bits & 0x00000040u) {
      original_price_in_cents_ = from.original_price_in_cents_;
    }
    if (cached_has_bits & 0x00000080u) {
      user_final_price_in_cents_ = from.user_final_price_in_cents_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      discount_pct_ = from.discount_pct_;
    }
    if (cached_has_bits & 0x00000200u) {
      user_discount_pct_ = from.user_discount_pct_;
    }
    if (cached_has_bits & 0x00000400u) {
      bundle_discount_pct_ = from.bundle_discount_pct_;
    }
    if (cached_has_bits & 0x00000800u) {
      user_can_purchase_ = from.user_can_purchase_;
    }
    if (cached_has_bits & 0x00001000u) {
      user_can_purchase_as_gift_ = from.user_can_purchase_as_gift_;
    }
    if (cached_has_bits & 0x00002000u) {
      is_commercial_license_ = from.is_commercial_license_;
    }
    if (cached_has_bits & 0x00004000u) {
      should_suppress_discount_pct_ = from.should_suppress_discount_pct_;
    }
    if (cached_has_bits & 0x00008000u) {
      hide_discount_pct_for_compliance_ = from.hide_discount_pct_for_compliance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      included_game_count_ = from.included_game_count_;
    }
    if (cached_has_bits & 0x00020000u) {
      lowest_recent_price_in_cents_ = from.lowest_recent_price_in_cents_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_PurchaseOption::CopyFrom(const StoreItem_PurchaseOption& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.PurchaseOption)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_PurchaseOption::IsInitialized() const {
  return true;
}

void StoreItem_PurchaseOption::InternalSwap(StoreItem_PurchaseOption* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  active_discounts_.InternalSwap(&other->active_discounts_);
  user_active_discounts_.InternalSwap(&other->user_active_discounts_);
  inactive_discounts_.InternalSwap(&other->inactive_discounts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &purchase_option_name_, lhs_arena,
      &other->purchase_option_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &formatted_final_price_, lhs_arena,
      &other->formatted_final_price_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &formatted_original_price_, lhs_arena,
      &other->formatted_original_price_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem_PurchaseOption, lowest_recent_price_in_cents_)
      + sizeof(StoreItem_PurchaseOption::lowest_recent_price_in_cents_)
      - PROTOBUF_FIELD_OFFSET(StoreItem_PurchaseOption, packageid_)>(
          reinterpret_cast<char*>(&packageid_),
          reinterpret_cast<char*>(&other->packageid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_PurchaseOption::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[17]);
}

// ===================================================================

class StoreItem_Screenshots_Screenshot::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_Screenshots_Screenshot>()._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ordinal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StoreItem_Screenshots_Screenshot::StoreItem_Screenshots_Screenshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Screenshots.Screenshot)
}
StoreItem_Screenshots_Screenshot::StoreItem_Screenshots_Screenshot(const StoreItem_Screenshots_Screenshot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_filename(), 
      GetArenaForAllocation());
  }
  ordinal_ = from.ordinal_;
  // @@protoc_insertion_point(copy_constructor:StoreItem.Screenshots.Screenshot)
}

inline void StoreItem_Screenshots_Screenshot::SharedCtor() {
filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ordinal_ = 0;
}

StoreItem_Screenshots_Screenshot::~StoreItem_Screenshots_Screenshot() {
  // @@protoc_insertion_point(destructor:StoreItem.Screenshots.Screenshot)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Screenshots_Screenshot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_Screenshots_Screenshot::ArenaDtor(void* object) {
  StoreItem_Screenshots_Screenshot* _this = reinterpret_cast< StoreItem_Screenshots_Screenshot* >(object);
  (void)_this;
}
void StoreItem_Screenshots_Screenshot::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Screenshots_Screenshot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Screenshots_Screenshot::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Screenshots.Screenshot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    filename_.ClearNonDefaultToEmpty();
  }
  ordinal_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Screenshots_Screenshot::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1 [(.description) = "Path to file on media CDN.  Can access sized version by appending to SHA: \'.1920x1080\', \'.600x338\', \'.116x65\'"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Screenshots.Screenshot.filename");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ordinal = 2 [(.description) = "Screenshots should be displayed in order of ascending ordinal; they are returned in-order but client may need to merge all_ages and mature_content_screenshots."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ordinal(&has_bits);
          ordinal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Screenshots_Screenshot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Screenshots.Screenshot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string filename = 1 [(.description) = "Path to file on media CDN.  Can access sized version by appending to SHA: \'.1920x1080\', \'.600x338\', \'.116x65\'"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Screenshots.Screenshot.filename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // optional int32 ordinal = 2 [(.description) = "Screenshots should be displayed in order of ascending ordinal; they are returned in-order but client may need to merge all_ages and mature_content_screenshots."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_ordinal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Screenshots.Screenshot)
  return target;
}

size_t StoreItem_Screenshots_Screenshot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Screenshots.Screenshot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string filename = 1 [(.description) = "Path to file on media CDN.  Can access sized version by appending to SHA: \'.1920x1080\', \'.600x338\', \'.116x65\'"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional int32 ordinal = 2 [(.description) = "Screenshots should be displayed in order of ascending ordinal; they are returned in-order but client may need to merge all_ages and mature_content_screenshots."];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_ordinal());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Screenshots_Screenshot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Screenshots_Screenshot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Screenshots_Screenshot::GetClassData() const { return &_class_data_; }

void StoreItem_Screenshots_Screenshot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Screenshots_Screenshot *>(to)->MergeFrom(
      static_cast<const StoreItem_Screenshots_Screenshot &>(from));
}


void StoreItem_Screenshots_Screenshot::MergeFrom(const StoreItem_Screenshots_Screenshot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Screenshots.Screenshot)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      ordinal_ = from.ordinal_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Screenshots_Screenshot::CopyFrom(const StoreItem_Screenshots_Screenshot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Screenshots.Screenshot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Screenshots_Screenshot::IsInitialized() const {
  return true;
}

void StoreItem_Screenshots_Screenshot::InternalSwap(StoreItem_Screenshots_Screenshot* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &filename_, lhs_arena,
      &other->filename_, rhs_arena
  );
  swap(ordinal_, other->ordinal_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Screenshots_Screenshot::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[18]);
}

// ===================================================================

class StoreItem_Screenshots::_Internal {
 public:
};

StoreItem_Screenshots::StoreItem_Screenshots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  all_ages_screenshots_(arena),
  mature_content_screenshots_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Screenshots)
}
StoreItem_Screenshots::StoreItem_Screenshots(const StoreItem_Screenshots& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      all_ages_screenshots_(from.all_ages_screenshots_),
      mature_content_screenshots_(from.mature_content_screenshots_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:StoreItem.Screenshots)
}

inline void StoreItem_Screenshots::SharedCtor() {
}

StoreItem_Screenshots::~StoreItem_Screenshots() {
  // @@protoc_insertion_point(destructor:StoreItem.Screenshots)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Screenshots::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreItem_Screenshots::ArenaDtor(void* object) {
  StoreItem_Screenshots* _this = reinterpret_cast< StoreItem_Screenshots* >(object);
  (void)_this;
}
void StoreItem_Screenshots::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Screenshots::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Screenshots::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Screenshots)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  all_ages_screenshots_.Clear();
  mature_content_screenshots_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Screenshots::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .StoreItem.Screenshots.Screenshot all_ages_screenshots = 2 [(.description) = "Screenshots suitable for all ages."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_all_ages_screenshots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.Screenshots.Screenshot mature_content_screenshots = 3 [(.description) = "Screenshots that may contain mature content; these should only be shown after verifying age (age gate)."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mature_content_screenshots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Screenshots::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Screenshots)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .StoreItem.Screenshots.Screenshot all_ages_screenshots = 2 [(.description) = "Screenshots suitable for all ages."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_all_ages_screenshots_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_all_ages_screenshots(i), target, stream);
  }

  // repeated .StoreItem.Screenshots.Screenshot mature_content_screenshots = 3 [(.description) = "Screenshots that may contain mature content; these should only be shown after verifying age (age gate)."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_mature_content_screenshots_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_mature_content_screenshots(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Screenshots)
  return target;
}

size_t StoreItem_Screenshots::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Screenshots)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .StoreItem.Screenshots.Screenshot all_ages_screenshots = 2 [(.description) = "Screenshots suitable for all ages."];
  total_size += 1UL * this->_internal_all_ages_screenshots_size();
  for (const auto& msg : this->all_ages_screenshots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.Screenshots.Screenshot mature_content_screenshots = 3 [(.description) = "Screenshots that may contain mature content; these should only be shown after verifying age (age gate)."];
  total_size += 1UL * this->_internal_mature_content_screenshots_size();
  for (const auto& msg : this->mature_content_screenshots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Screenshots::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Screenshots::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Screenshots::GetClassData() const { return &_class_data_; }

void StoreItem_Screenshots::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Screenshots *>(to)->MergeFrom(
      static_cast<const StoreItem_Screenshots &>(from));
}


void StoreItem_Screenshots::MergeFrom(const StoreItem_Screenshots& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Screenshots)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  all_ages_screenshots_.MergeFrom(from.all_ages_screenshots_);
  mature_content_screenshots_.MergeFrom(from.mature_content_screenshots_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Screenshots::CopyFrom(const StoreItem_Screenshots& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Screenshots)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Screenshots::IsInitialized() const {
  return true;
}

void StoreItem_Screenshots::InternalSwap(StoreItem_Screenshots* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  all_ages_screenshots_.InternalSwap(&other->all_ages_screenshots_);
  mature_content_screenshots_.InternalSwap(&other->mature_content_screenshots_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Screenshots::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[19]);
}

// ===================================================================

class StoreItem_Trailers_VideoSource::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_Trailers_VideoSource>()._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StoreItem_Trailers_VideoSource::StoreItem_Trailers_VideoSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Trailers.VideoSource)
}
StoreItem_Trailers_VideoSource::StoreItem_Trailers_VideoSource(const StoreItem_Trailers_VideoSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_filename(), 
      GetArenaForAllocation());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:StoreItem.Trailers.VideoSource)
}

inline void StoreItem_Trailers_VideoSource::SharedCtor() {
filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StoreItem_Trailers_VideoSource::~StoreItem_Trailers_VideoSource() {
  // @@protoc_insertion_point(destructor:StoreItem.Trailers.VideoSource)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Trailers_VideoSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_Trailers_VideoSource::ArenaDtor(void* object) {
  StoreItem_Trailers_VideoSource* _this = reinterpret_cast< StoreItem_Trailers_VideoSource* >(object);
  (void)_this;
}
void StoreItem_Trailers_VideoSource::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Trailers_VideoSource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Trailers_VideoSource::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Trailers.VideoSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Trailers_VideoSource::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1 [(.description) = "Substitute into trailer_url_format"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Trailers.VideoSource.filename");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string type = 2 [(.description) = "\'video/webm\' or \'video/mp4\'; can just put this directly in to a <source> tag."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Trailers.VideoSource.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Trailers_VideoSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Trailers.VideoSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string filename = 1 [(.description) = "Substitute into trailer_url_format"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Trailers.VideoSource.filename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // optional string type = 2 [(.description) = "\'video/webm\' or \'video/mp4\'; can just put this directly in to a <source> tag."];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Trailers.VideoSource.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Trailers.VideoSource)
  return target;
}

size_t StoreItem_Trailers_VideoSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Trailers.VideoSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string filename = 1 [(.description) = "Substitute into trailer_url_format"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional string type = 2 [(.description) = "\'video/webm\' or \'video/mp4\'; can just put this directly in to a <source> tag."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Trailers_VideoSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Trailers_VideoSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Trailers_VideoSource::GetClassData() const { return &_class_data_; }

void StoreItem_Trailers_VideoSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Trailers_VideoSource *>(to)->MergeFrom(
      static_cast<const StoreItem_Trailers_VideoSource &>(from));
}


void StoreItem_Trailers_VideoSource::MergeFrom(const StoreItem_Trailers_VideoSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Trailers.VideoSource)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Trailers_VideoSource::CopyFrom(const StoreItem_Trailers_VideoSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Trailers.VideoSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Trailers_VideoSource::IsInitialized() const {
  return true;
}

void StoreItem_Trailers_VideoSource::InternalSwap(StoreItem_Trailers_VideoSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &filename_, lhs_arena,
      &other->filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Trailers_VideoSource::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[20]);
}

// ===================================================================

class StoreItem_Trailers_Trailer::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_Trailers_Trailer>()._has_bits_);
  static void set_has_trailer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_trailer_url_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_screenshot_medium(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_screenshot_full(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_trailer_base_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

StoreItem_Trailers_Trailer::StoreItem_Trailers_Trailer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  trailer_480p_(arena),
  trailer_max_(arena),
  microtrailer_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Trailers.Trailer)
}
StoreItem_Trailers_Trailer::StoreItem_Trailers_Trailer(const StoreItem_Trailers_Trailer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      trailer_480p_(from.trailer_480p_),
      trailer_max_(from.trailer_max_),
      microtrailer_(from.microtrailer_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  trailer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    trailer_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trailer_name()) {
    trailer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_trailer_name(), 
      GetArenaForAllocation());
  }
  trailer_url_format_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    trailer_url_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trailer_url_format()) {
    trailer_url_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_trailer_url_format(), 
      GetArenaForAllocation());
  }
  screenshot_medium_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    screenshot_medium_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_screenshot_medium()) {
    screenshot_medium_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_screenshot_medium(), 
      GetArenaForAllocation());
  }
  screenshot_full_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    screenshot_full_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_screenshot_full()) {
    screenshot_full_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_screenshot_full(), 
      GetArenaForAllocation());
  }
  trailer_base_id_ = from.trailer_base_id_;
  // @@protoc_insertion_point(copy_constructor:StoreItem.Trailers.Trailer)
}

inline void StoreItem_Trailers_Trailer::SharedCtor() {
trailer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  trailer_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
trailer_url_format_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  trailer_url_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
screenshot_medium_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  screenshot_medium_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
screenshot_full_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  screenshot_full_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
trailer_base_id_ = 0;
}

StoreItem_Trailers_Trailer::~StoreItem_Trailers_Trailer() {
  // @@protoc_insertion_point(destructor:StoreItem.Trailers.Trailer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Trailers_Trailer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  trailer_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  trailer_url_format_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  screenshot_medium_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  screenshot_full_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_Trailers_Trailer::ArenaDtor(void* object) {
  StoreItem_Trailers_Trailer* _this = reinterpret_cast< StoreItem_Trailers_Trailer* >(object);
  (void)_this;
}
void StoreItem_Trailers_Trailer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Trailers_Trailer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Trailers_Trailer::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Trailers.Trailer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  trailer_480p_.Clear();
  trailer_max_.Clear();
  microtrailer_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      trailer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      trailer_url_format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      screenshot_medium_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      screenshot_full_.ClearNonDefaultToEmpty();
    }
  }
  trailer_base_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Trailers_Trailer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string trailer_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_trailer_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Trailers.Trailer.trailer_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string trailer_url_format = 2 [(.description) = "Format for URLs, should substitute filename for ${FILENAME} in the URL."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_trailer_url_format();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Trailers.Trailer.trailer_url_format");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.Trailers.VideoSource trailer_480p = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trailer_480p(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.Trailers.VideoSource trailer_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trailer_max(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.Trailers.VideoSource microtrailer = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_microtrailer(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string screenshot_medium = 10 [(.description) = "293x165px.  Use trailer_url_format."];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_screenshot_medium();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Trailers.Trailer.screenshot_medium");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string screenshot_full = 11 [(.description) = "Same size as trailer_max.  Use trailer_url_format."];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_screenshot_full();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.Trailers.Trailer.screenshot_full");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 trailer_base_id = 12 [(.description) = "Trailer ID.  For localized trailers, this will be the original trailer\'s ID"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_trailer_base_id(&has_bits);
          trailer_base_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Trailers_Trailer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Trailers.Trailer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string trailer_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_trailer_name().data(), static_cast<int>(this->_internal_trailer_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Trailers.Trailer.trailer_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_trailer_name(), target);
  }

  // optional string trailer_url_format = 2 [(.description) = "Format for URLs, should substitute filename for ${FILENAME} in the URL."];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_trailer_url_format().data(), static_cast<int>(this->_internal_trailer_url_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Trailers.Trailer.trailer_url_format");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_trailer_url_format(), target);
  }

  // repeated .StoreItem.Trailers.VideoSource trailer_480p = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_trailer_480p_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_trailer_480p(i), target, stream);
  }

  // repeated .StoreItem.Trailers.VideoSource trailer_max = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_trailer_max_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_trailer_max(i), target, stream);
  }

  // repeated .StoreItem.Trailers.VideoSource microtrailer = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_microtrailer_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_microtrailer(i), target, stream);
  }

  // optional string screenshot_medium = 10 [(.description) = "293x165px.  Use trailer_url_format."];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_screenshot_medium().data(), static_cast<int>(this->_internal_screenshot_medium().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Trailers.Trailer.screenshot_medium");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_screenshot_medium(), target);
  }

  // optional string screenshot_full = 11 [(.description) = "Same size as trailer_max.  Use trailer_url_format."];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_screenshot_full().data(), static_cast<int>(this->_internal_screenshot_full().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.Trailers.Trailer.screenshot_full");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_screenshot_full(), target);
  }

  // optional int32 trailer_base_id = 12 [(.description) = "Trailer ID.  For localized trailers, this will be the original trailer\'s ID"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_trailer_base_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Trailers.Trailer)
  return target;
}

size_t StoreItem_Trailers_Trailer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Trailers.Trailer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .StoreItem.Trailers.VideoSource trailer_480p = 3;
  total_size += 1UL * this->_internal_trailer_480p_size();
  for (const auto& msg : this->trailer_480p_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.Trailers.VideoSource trailer_max = 4;
  total_size += 1UL * this->_internal_trailer_max_size();
  for (const auto& msg : this->trailer_max_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.Trailers.VideoSource microtrailer = 5;
  total_size += 1UL * this->_internal_microtrailer_size();
  for (const auto& msg : this->microtrailer_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string trailer_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_trailer_name());
    }

    // optional string trailer_url_format = 2 [(.description) = "Format for URLs, should substitute filename for ${FILENAME} in the URL."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_trailer_url_format());
    }

    // optional string screenshot_medium = 10 [(.description) = "293x165px.  Use trailer_url_format."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_screenshot_medium());
    }

    // optional string screenshot_full = 11 [(.description) = "Same size as trailer_max.  Use trailer_url_format."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_screenshot_full());
    }

    // optional int32 trailer_base_id = 12 [(.description) = "Trailer ID.  For localized trailers, this will be the original trailer\'s ID"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_trailer_base_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Trailers_Trailer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Trailers_Trailer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Trailers_Trailer::GetClassData() const { return &_class_data_; }

void StoreItem_Trailers_Trailer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Trailers_Trailer *>(to)->MergeFrom(
      static_cast<const StoreItem_Trailers_Trailer &>(from));
}


void StoreItem_Trailers_Trailer::MergeFrom(const StoreItem_Trailers_Trailer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Trailers.Trailer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  trailer_480p_.MergeFrom(from.trailer_480p_);
  trailer_max_.MergeFrom(from.trailer_max_);
  microtrailer_.MergeFrom(from.microtrailer_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_trailer_name(from._internal_trailer_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_trailer_url_format(from._internal_trailer_url_format());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_screenshot_medium(from._internal_screenshot_medium());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_screenshot_full(from._internal_screenshot_full());
    }
    if (cached_has_bits & 0x00000010u) {
      trailer_base_id_ = from.trailer_base_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Trailers_Trailer::CopyFrom(const StoreItem_Trailers_Trailer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Trailers.Trailer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Trailers_Trailer::IsInitialized() const {
  return true;
}

void StoreItem_Trailers_Trailer::InternalSwap(StoreItem_Trailers_Trailer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  trailer_480p_.InternalSwap(&other->trailer_480p_);
  trailer_max_.InternalSwap(&other->trailer_max_);
  microtrailer_.InternalSwap(&other->microtrailer_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &trailer_name_, lhs_arena,
      &other->trailer_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &trailer_url_format_, lhs_arena,
      &other->trailer_url_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &screenshot_medium_, lhs_arena,
      &other->screenshot_medium_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &screenshot_full_, lhs_arena,
      &other->screenshot_full_, rhs_arena
  );
  swap(trailer_base_id_, other->trailer_base_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Trailers_Trailer::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[21]);
}

// ===================================================================

class StoreItem_Trailers::_Internal {
 public:
};

StoreItem_Trailers::StoreItem_Trailers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  highlights_(arena),
  other_trailers_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.Trailers)
}
StoreItem_Trailers::StoreItem_Trailers(const StoreItem_Trailers& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      highlights_(from.highlights_),
      other_trailers_(from.other_trailers_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:StoreItem.Trailers)
}

inline void StoreItem_Trailers::SharedCtor() {
}

StoreItem_Trailers::~StoreItem_Trailers() {
  // @@protoc_insertion_point(destructor:StoreItem.Trailers)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_Trailers::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreItem_Trailers::ArenaDtor(void* object) {
  StoreItem_Trailers* _this = reinterpret_cast< StoreItem_Trailers* >(object);
  (void)_this;
}
void StoreItem_Trailers::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_Trailers::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_Trailers::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.Trailers)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  highlights_.Clear();
  other_trailers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_Trailers::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .StoreItem.Trailers.Trailer highlights = 1 [(.description) = "Primary trailers for this app"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_highlights(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.Trailers.Trailer other_trailers = 2 [(.description) = "Additional trailers; on the app page, these are shown after screenshots (highlights shown before)"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_other_trailers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_Trailers::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.Trailers)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .StoreItem.Trailers.Trailer highlights = 1 [(.description) = "Primary trailers for this app"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_highlights_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_highlights(i), target, stream);
  }

  // repeated .StoreItem.Trailers.Trailer other_trailers = 2 [(.description) = "Additional trailers; on the app page, these are shown after screenshots (highlights shown before)"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_other_trailers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_other_trailers(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.Trailers)
  return target;
}

size_t StoreItem_Trailers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.Trailers)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .StoreItem.Trailers.Trailer highlights = 1 [(.description) = "Primary trailers for this app"];
  total_size += 1UL * this->_internal_highlights_size();
  for (const auto& msg : this->highlights_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.Trailers.Trailer other_trailers = 2 [(.description) = "Additional trailers; on the app page, these are shown after screenshots (highlights shown before)"];
  total_size += 1UL * this->_internal_other_trailers_size();
  for (const auto& msg : this->other_trailers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_Trailers::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_Trailers::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_Trailers::GetClassData() const { return &_class_data_; }

void StoreItem_Trailers::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_Trailers *>(to)->MergeFrom(
      static_cast<const StoreItem_Trailers &>(from));
}


void StoreItem_Trailers::MergeFrom(const StoreItem_Trailers& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.Trailers)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  highlights_.MergeFrom(from.highlights_);
  other_trailers_.MergeFrom(from.other_trailers_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_Trailers::CopyFrom(const StoreItem_Trailers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.Trailers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_Trailers::IsInitialized() const {
  return true;
}

void StoreItem_Trailers::InternalSwap(StoreItem_Trailers* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  highlights_.InternalSwap(&other->highlights_);
  other_trailers_.InternalSwap(&other->other_trailers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_Trailers::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[22]);
}

// ===================================================================

class StoreItem_SupportedLanguage::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_SupportedLanguage>()._has_bits_);
  static void set_has_elanguage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_full_audio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_subtitles(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

StoreItem_SupportedLanguage::StoreItem_SupportedLanguage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.SupportedLanguage)
}
StoreItem_SupportedLanguage::StoreItem_SupportedLanguage(const StoreItem_SupportedLanguage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&elanguage_, &from.elanguage_,
    static_cast<size_t>(reinterpret_cast<char*>(&subtitles_) -
    reinterpret_cast<char*>(&elanguage_)) + sizeof(subtitles_));
  // @@protoc_insertion_point(copy_constructor:StoreItem.SupportedLanguage)
}

inline void StoreItem_SupportedLanguage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&elanguage_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&subtitles_) -
    reinterpret_cast<char*>(&elanguage_)) + sizeof(subtitles_));
}

StoreItem_SupportedLanguage::~StoreItem_SupportedLanguage() {
  // @@protoc_insertion_point(destructor:StoreItem.SupportedLanguage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_SupportedLanguage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreItem_SupportedLanguage::ArenaDtor(void* object) {
  StoreItem_SupportedLanguage* _this = reinterpret_cast< StoreItem_SupportedLanguage* >(object);
  (void)_this;
}
void StoreItem_SupportedLanguage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_SupportedLanguage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_SupportedLanguage::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.SupportedLanguage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&elanguage_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&subtitles_) -
        reinterpret_cast<char*>(&elanguage_)) + sizeof(subtitles_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_SupportedLanguage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 elanguage = 1 [(.description) = "ELanguage"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_elanguage(&has_bits);
          elanguage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supported = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_supported(&has_bits);
          supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool full_audio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_full_audio(&has_bits);
          full_audio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool subtitles = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_subtitles(&has_bits);
          subtitles_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_SupportedLanguage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.SupportedLanguage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 elanguage = 1 [(.description) = "ELanguage"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_elanguage(), target);
  }

  // optional bool supported = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_supported(), target);
  }

  // optional bool full_audio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_full_audio(), target);
  }

  // optional bool subtitles = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_subtitles(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.SupportedLanguage)
  return target;
}

size_t StoreItem_SupportedLanguage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.SupportedLanguage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 elanguage = 1 [(.description) = "ELanguage"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_elanguage());
    }

    // optional bool supported = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool full_audio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool subtitles = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_SupportedLanguage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_SupportedLanguage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_SupportedLanguage::GetClassData() const { return &_class_data_; }

void StoreItem_SupportedLanguage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_SupportedLanguage *>(to)->MergeFrom(
      static_cast<const StoreItem_SupportedLanguage &>(from));
}


void StoreItem_SupportedLanguage::MergeFrom(const StoreItem_SupportedLanguage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.SupportedLanguage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      elanguage_ = from.elanguage_;
    }
    if (cached_has_bits & 0x00000002u) {
      supported_ = from.supported_;
    }
    if (cached_has_bits & 0x00000004u) {
      full_audio_ = from.full_audio_;
    }
    if (cached_has_bits & 0x00000008u) {
      subtitles_ = from.subtitles_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_SupportedLanguage::CopyFrom(const StoreItem_SupportedLanguage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.SupportedLanguage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_SupportedLanguage::IsInitialized() const {
  return true;
}

void StoreItem_SupportedLanguage::InternalSwap(StoreItem_SupportedLanguage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem_SupportedLanguage, subtitles_)
      + sizeof(StoreItem_SupportedLanguage::subtitles_)
      - PROTOBUF_FIELD_OFFSET(StoreItem_SupportedLanguage, elanguage_)>(
          reinterpret_cast<char*>(&elanguage_),
          reinterpret_cast<char*>(&other->elanguage_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_SupportedLanguage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[23]);
}

// ===================================================================

class StoreItem_FreeWeekend::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem_FreeWeekend>()._has_bits_);
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StoreItem_FreeWeekend::StoreItem_FreeWeekend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem.FreeWeekend)
}
StoreItem_FreeWeekend::StoreItem_FreeWeekend(const StoreItem_FreeWeekend& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_text(), 
      GetArenaForAllocation());
  }
  ::memcpy(&start_time_, &from.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_time_) -
    reinterpret_cast<char*>(&start_time_)) + sizeof(end_time_));
  // @@protoc_insertion_point(copy_constructor:StoreItem.FreeWeekend)
}

inline void StoreItem_FreeWeekend::SharedCtor() {
text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&end_time_) -
    reinterpret_cast<char*>(&start_time_)) + sizeof(end_time_));
}

StoreItem_FreeWeekend::~StoreItem_FreeWeekend() {
  // @@protoc_insertion_point(destructor:StoreItem.FreeWeekend)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem_FreeWeekend::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StoreItem_FreeWeekend::ArenaDtor(void* object) {
  StoreItem_FreeWeekend* _this = reinterpret_cast< StoreItem_FreeWeekend* >(object);
  (void)_this;
}
void StoreItem_FreeWeekend::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem_FreeWeekend::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem_FreeWeekend::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem.FreeWeekend)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    text_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&start_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_time_) -
        reinterpret_cast<char*>(&start_time_)) + sizeof(end_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem_FreeWeekend::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 start_time = 1 [(.description) = "When the free weekend starts."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 end_time = 2 [(.description) = "When the free weekend ends."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_end_time(&has_bits);
          end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text = 3 [(.description) = "Text to show as a description of the free weekend."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.FreeWeekend.text");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem_FreeWeekend::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem.FreeWeekend)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 start_time = 1 [(.description) = "When the free weekend starts."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_start_time(), target);
  }

  // optional uint32 end_time = 2 [(.description) = "When the free weekend ends."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_end_time(), target);
  }

  // optional string text = 3 [(.description) = "Text to show as a description of the free weekend."];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.FreeWeekend.text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem.FreeWeekend)
  return target;
}

size_t StoreItem_FreeWeekend::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem.FreeWeekend)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string text = 3 [(.description) = "Text to show as a description of the free weekend."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
    }

    // optional uint32 start_time = 1 [(.description) = "When the free weekend starts."];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_start_time());
    }

    // optional uint32 end_time = 2 [(.description) = "When the free weekend ends."];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_end_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem_FreeWeekend::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem_FreeWeekend::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem_FreeWeekend::GetClassData() const { return &_class_data_; }

void StoreItem_FreeWeekend::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem_FreeWeekend *>(to)->MergeFrom(
      static_cast<const StoreItem_FreeWeekend &>(from));
}


void StoreItem_FreeWeekend::MergeFrom(const StoreItem_FreeWeekend& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem.FreeWeekend)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      start_time_ = from.start_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      end_time_ = from.end_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem_FreeWeekend::CopyFrom(const StoreItem_FreeWeekend& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem.FreeWeekend)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem_FreeWeekend::IsInitialized() const {
  return true;
}

void StoreItem_FreeWeekend::InternalSwap(StoreItem_FreeWeekend* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &text_, lhs_arena,
      &other->text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem_FreeWeekend, end_time_)
      + sizeof(StoreItem_FreeWeekend::end_time_)
      - PROTOBUF_FIELD_OFFSET(StoreItem_FreeWeekend, start_time_)>(
          reinterpret_cast<char*>(&start_time_),
          reinterpret_cast<char*>(&other->start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem_FreeWeekend::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[24]);
}

// ===================================================================

class StoreItem::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreItem>()._has_bits_);
  static void set_has_item_type(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_visible(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_unvailable_for_country_restriction(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_store_url_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_is_free(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_is_early_access(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::StoreItem_RelatedItems& related_items(const StoreItem* msg);
  static void set_has_related_items(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::StoreItem_Categories& categories(const StoreItem* msg);
  static void set_has_categories(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::StoreItem_Reviews& reviews(const StoreItem* msg);
  static void set_has_reviews(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::StoreItem_BasicInfo& basic_info(const StoreItem* msg);
  static void set_has_basic_info(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::StoreItem_Assets& assets(const StoreItem* msg);
  static void set_has_assets(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::StoreItem_ReleaseInfo& release(const StoreItem* msg);
  static void set_has_release(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::StoreItem_Platforms& platforms(const StoreItem* msg);
  static void set_has_platforms(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::StoreGameRating& game_rating(const StoreItem* msg);
  static void set_has_game_rating(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::StoreItem_PurchaseOption& best_purchase_option(const StoreItem* msg);
  static void set_has_best_purchase_option(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::StoreItem_Screenshots& screenshots(const StoreItem* msg);
  static void set_has_screenshots(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::StoreItem_Trailers& trailers(const StoreItem* msg);
  static void set_has_trailers(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_store_url_path_override(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::StoreItem_FreeWeekend& free_weekend(const StoreItem* msg);
  static void set_has_free_weekend(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_unlisted(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_game_count(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_internal_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_full_description(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::StoreItem_RelatedItems&
StoreItem::_Internal::related_items(const StoreItem* msg) {
  return *msg->related_items_;
}
const ::StoreItem_Categories&
StoreItem::_Internal::categories(const StoreItem* msg) {
  return *msg->categories_;
}
const ::StoreItem_Reviews&
StoreItem::_Internal::reviews(const StoreItem* msg) {
  return *msg->reviews_;
}
const ::StoreItem_BasicInfo&
StoreItem::_Internal::basic_info(const StoreItem* msg) {
  return *msg->basic_info_;
}
const ::StoreItem_Assets&
StoreItem::_Internal::assets(const StoreItem* msg) {
  return *msg->assets_;
}
const ::StoreItem_ReleaseInfo&
StoreItem::_Internal::release(const StoreItem* msg) {
  return *msg->release_;
}
const ::StoreItem_Platforms&
StoreItem::_Internal::platforms(const StoreItem* msg) {
  return *msg->platforms_;
}
const ::StoreGameRating&
StoreItem::_Internal::game_rating(const StoreItem* msg) {
  return *msg->game_rating_;
}
const ::StoreItem_PurchaseOption&
StoreItem::_Internal::best_purchase_option(const StoreItem* msg) {
  return *msg->best_purchase_option_;
}
const ::StoreItem_Screenshots&
StoreItem::_Internal::screenshots(const StoreItem* msg) {
  return *msg->screenshots_;
}
const ::StoreItem_Trailers&
StoreItem::_Internal::trailers(const StoreItem* msg) {
  return *msg->trailers_;
}
const ::StoreItem_FreeWeekend&
StoreItem::_Internal::free_weekend(const StoreItem* msg) {
  return *msg->free_weekend_;
}
StoreItem::StoreItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  included_types_(arena),
  included_appids_(arena),
  content_descriptorids_(arena),
  tagids_(arena),
  tags_(arena),
  purchase_options_(arena),
  accessories_(arena),
  supported_languages_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:StoreItem)
}
StoreItem::StoreItem(const StoreItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      included_types_(from.included_types_),
      included_appids_(from.included_appids_),
      content_descriptorids_(from.content_descriptorids_),
      tagids_(from.tagids_),
      tags_(from.tags_),
      purchase_options_(from.purchase_options_),
      accessories_(from.accessories_),
      supported_languages_(from.supported_languages_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  store_url_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    store_url_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_store_url_path()) {
    store_url_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_store_url_path(), 
      GetArenaForAllocation());
  }
  store_url_path_override_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    store_url_path_override_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_store_url_path_override()) {
    store_url_path_override_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_store_url_path_override(), 
      GetArenaForAllocation());
  }
  internal_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    internal_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_internal_name()) {
    internal_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_internal_name(), 
      GetArenaForAllocation());
  }
  full_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    full_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_full_description()) {
    full_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_full_description(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_related_items()) {
    related_items_ = new ::StoreItem_RelatedItems(*from.related_items_);
  } else {
    related_items_ = nullptr;
  }
  if (from._internal_has_categories()) {
    categories_ = new ::StoreItem_Categories(*from.categories_);
  } else {
    categories_ = nullptr;
  }
  if (from._internal_has_reviews()) {
    reviews_ = new ::StoreItem_Reviews(*from.reviews_);
  } else {
    reviews_ = nullptr;
  }
  if (from._internal_has_basic_info()) {
    basic_info_ = new ::StoreItem_BasicInfo(*from.basic_info_);
  } else {
    basic_info_ = nullptr;
  }
  if (from._internal_has_assets()) {
    assets_ = new ::StoreItem_Assets(*from.assets_);
  } else {
    assets_ = nullptr;
  }
  if (from._internal_has_release()) {
    release_ = new ::StoreItem_ReleaseInfo(*from.release_);
  } else {
    release_ = nullptr;
  }
  if (from._internal_has_platforms()) {
    platforms_ = new ::StoreItem_Platforms(*from.platforms_);
  } else {
    platforms_ = nullptr;
  }
  if (from._internal_has_game_rating()) {
    game_rating_ = new ::StoreGameRating(*from.game_rating_);
  } else {
    game_rating_ = nullptr;
  }
  if (from._internal_has_best_purchase_option()) {
    best_purchase_option_ = new ::StoreItem_PurchaseOption(*from.best_purchase_option_);
  } else {
    best_purchase_option_ = nullptr;
  }
  if (from._internal_has_screenshots()) {
    screenshots_ = new ::StoreItem_Screenshots(*from.screenshots_);
  } else {
    screenshots_ = nullptr;
  }
  if (from._internal_has_trailers()) {
    trailers_ = new ::StoreItem_Trailers(*from.trailers_);
  } else {
    trailers_ = nullptr;
  }
  if (from._internal_has_free_weekend()) {
    free_weekend_ = new ::StoreItem_FreeWeekend(*from.free_weekend_);
  } else {
    free_weekend_ = nullptr;
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&item_type_) -
    reinterpret_cast<char*>(&id_)) + sizeof(item_type_));
  // @@protoc_insertion_point(copy_constructor:StoreItem)
}

inline void StoreItem::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
store_url_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  store_url_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
store_url_path_override_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  store_url_path_override_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
internal_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  internal_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
full_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  full_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&related_items_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&game_count_) -
    reinterpret_cast<char*>(&related_items_)) + sizeof(game_count_));
item_type_ = -1;
}

StoreItem::~StoreItem() {
  // @@protoc_insertion_point(destructor:StoreItem)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  store_url_path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  store_url_path_override_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  internal_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  full_description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete related_items_;
  if (this != internal_default_instance()) delete categories_;
  if (this != internal_default_instance()) delete reviews_;
  if (this != internal_default_instance()) delete basic_info_;
  if (this != internal_default_instance()) delete assets_;
  if (this != internal_default_instance()) delete release_;
  if (this != internal_default_instance()) delete platforms_;
  if (this != internal_default_instance()) delete game_rating_;
  if (this != internal_default_instance()) delete best_purchase_option_;
  if (this != internal_default_instance()) delete screenshots_;
  if (this != internal_default_instance()) delete trailers_;
  if (this != internal_default_instance()) delete free_weekend_;
}

void StoreItem::ArenaDtor(void* object) {
  StoreItem* _this = reinterpret_cast< StoreItem* >(object);
  (void)_this;
}
void StoreItem::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreItem::Clear() {
// @@protoc_insertion_point(message_clear_start:StoreItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  included_types_.Clear();
  included_appids_.Clear();
  content_descriptorids_.Clear();
  tagids_.Clear();
  tags_.Clear();
  purchase_options_.Clear();
  accessories_.Clear();
  supported_languages_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      store_url_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      store_url_path_override_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      internal_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      full_description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(related_items_ != nullptr);
      related_items_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(categories_ != nullptr);
      categories_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(reviews_ != nullptr);
      reviews_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(basic_info_ != nullptr);
      basic_info_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(assets_ != nullptr);
      assets_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(release_ != nullptr);
      release_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(platforms_ != nullptr);
      platforms_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(game_rating_ != nullptr);
      game_rating_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(best_purchase_option_ != nullptr);
      best_purchase_option_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(screenshots_ != nullptr);
      screenshots_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(trailers_ != nullptr);
      trailers_->Clear();
    }
  }
  if (cached_has_bits & 0x00010000u) {
    GOOGLE_DCHECK(free_weekend_ != nullptr);
    free_weekend_->Clear();
  }
  if (cached_has_bits & 0x00fe0000u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_early_access_) -
        reinterpret_cast<char*>(&id_)) + sizeof(is_early_access_));
  }
  if (cached_has_bits & 0x0f000000u) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&game_count_) -
        reinterpret_cast<char*>(&type_)) + sizeof(game_count_));
    item_type_ = -1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreItem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EStoreItemType item_type = 1 [default = k_EStoreItemType_Invalid];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStoreItemType_IsValid(val))) {
            _internal_set_item_type(static_cast<::EStoreItemType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 success = 3 [(.description) = "EResult of this lookup action"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool visible = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_visible(&has_bits);
          visible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool unvailable_for_country_restriction = 5 [(.description) = "Indicates this app is visible in other regions, but not the requested reagion"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_unvailable_for_country_restriction(&has_bits);
          unvailable_for_country_restriction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string store_url_path = 7 [(.description) = "The URL of this item\'s store page, to be appended to STORE_BASE_URL."];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_store_url_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.store_url_path");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 9 [(.description) = "If this is an app, or a single-app package, the steamworks appid."];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStoreAppType type = 10 [default = k_EStoreAppType_Game, (.description) = "Type of app (Game, Software, Music).  For packages/bundles, this will be the most interesting type (eg Game + Soundtrack bundle will have type Game)"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStoreAppType_IsValid(val))) {
            _internal_set_type(static_cast<::EStoreAppType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .EStoreAppType included_types = 11 [(.description) = "For packages/bundles, all types of included items"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::EStoreAppType_IsValid(val))) {
              _internal_add_included_types(static_cast<::EStoreAppType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<88>(ptr));
        } else if (static_cast<uint8_t>(tag) == 90) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_included_types(), ptr, ctx, ::EStoreAppType_IsValid, &_internal_metadata_, 11);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 included_appids = 12 [(.description) = "For packages/bundles, all included appids"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_included_appids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
        } else if (static_cast<uint8_t>(tag) == 98) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_included_appids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_free = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_is_free(&has_bits);
          is_free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_early_access = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_is_early_access(&has_bits);
          is_early_access_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.RelatedItems related_items = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_related_items(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .EContentDescriptorID content_descriptorids = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::EContentDescriptorID_IsValid(val))) {
              _internal_add_content_descriptorids(static_cast<::EContentDescriptorID>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<160>(ptr));
        } else if (static_cast<uint8_t>(tag) == 162) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_content_descriptorids(), ptr, ctx, ::EContentDescriptorID_IsValid, &_internal_metadata_, 20);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 tagids = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_tagids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<168>(ptr));
        } else if (static_cast<uint8_t>(tag) == 170) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_tagids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.Categories categories = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_categories(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.Reviews reviews = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_reviews(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.BasicInfo basic_info = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_basic_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.Tag tags = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_tags(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<202>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.Assets assets = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_assets(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.ReleaseInfo release = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_release(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.Platforms platforms = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_platforms(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreGameRating game_rating = 33 [(.description) = "Local ratings agency information, like ESRB or PEGI"];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_rating(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.PurchaseOption best_purchase_option = 40 [(.description) = "The cheapest way for the user to acquire this app or package (may be a bundle)."];
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_best_purchase_option(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.PurchaseOption purchase_options = 41 [(.description) = "Different ways to buy this app or packages (packages can be purchased directly, but may also be included in bundles)."];
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_purchase_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<330>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.PurchaseOption accessories = 42 [(.description) = "Additional packages or bundles associated with an app, but that do not contain the app."];
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_accessories(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<338>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.Screenshots screenshots = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_screenshots(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.Trailers trailers = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_trailers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItem.SupportedLanguage supported_languages = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_supported_languages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<418>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string store_url_path_override = 53 [(.description) = "Navigate to this URL (relative to store home) when the store capsule for this item is clicked, instead of the default /app/... URL. Used by advertising apps that point to a sale page."];
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_store_url_path_override();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.store_url_path_override");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .StoreItem.FreeWeekend free_weekend = 54 [(.description) = "Information about a free weekend offer."];
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_free_weekend(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool unlisted = 55 [(.description) = "If true, item is only accessible on store via a direct link"];
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_unlisted(&has_bits);
          unlisted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 game_count = 56 [(.description) = "For creators and tags, how many games belong to them"];
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_game_count(&has_bits);
          game_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string internal_name = 57 [(.description) = "For hub categories, the internal name (handle) of the category"];
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          auto str = _internal_mutable_internal_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.internal_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string full_description = 58 [(.description) = "About this game section on the store page"];
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_full_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StoreItem.full_description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StoreItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EStoreItemType item_type = 1 [default = k_EStoreItemType_Invalid];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_item_type(), target);
  }

  // optional uint32 id = 2;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_id(), target);
  }

  // optional uint32 success = 3 [(.description) = "EResult of this lookup action"];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_success(), target);
  }

  // optional bool visible = 4;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_visible(), target);
  }

  // optional bool unvailable_for_country_restriction = 5 [(.description) = "Indicates this app is visible in other regions, but not the requested reagion"];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_unvailable_for_country_restriction(), target);
  }

  // optional string name = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_name(), target);
  }

  // optional string store_url_path = 7 [(.description) = "The URL of this item\'s store page, to be appended to STORE_BASE_URL."];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_store_url_path().data(), static_cast<int>(this->_internal_store_url_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.store_url_path");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_store_url_path(), target);
  }

  // optional uint32 appid = 9 [(.description) = "If this is an app, or a single-app package, the steamworks appid."];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_appid(), target);
  }

  // optional .EStoreAppType type = 10 [default = k_EStoreAppType_Game, (.description) = "Type of app (Game, Software, Music).  For packages/bundles, this will be the most interesting type (eg Game + Soundtrack bundle will have type Game)"];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_type(), target);
  }

  // repeated .EStoreAppType included_types = 11 [(.description) = "For packages/bundles, all types of included items"];
  for (int i = 0, n = this->_internal_included_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        11, this->_internal_included_types(i), target);
  }

  // repeated uint32 included_appids = 12 [(.description) = "For packages/bundles, all included appids"];
  for (int i = 0, n = this->_internal_included_appids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_included_appids(i), target);
  }

  // optional bool is_free = 13;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_is_free(), target);
  }

  // optional bool is_early_access = 14;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_is_early_access(), target);
  }

  // optional .StoreItem.RelatedItems related_items = 15;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        15, _Internal::related_items(this), target, stream);
  }

  // repeated .EContentDescriptorID content_descriptorids = 20;
  for (int i = 0, n = this->_internal_content_descriptorids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        20, this->_internal_content_descriptorids(i), target);
  }

  // repeated uint32 tagids = 21;
  for (int i = 0, n = this->_internal_tagids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(21, this->_internal_tagids(i), target);
  }

  // optional .StoreItem.Categories categories = 22;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        22, _Internal::categories(this), target, stream);
  }

  // optional .StoreItem.Reviews reviews = 23;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        23, _Internal::reviews(this), target, stream);
  }

  // optional .StoreItem.BasicInfo basic_info = 24;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        24, _Internal::basic_info(this), target, stream);
  }

  // repeated .StoreItem.Tag tags = 25;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_tags_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, this->_internal_tags(i), target, stream);
  }

  // optional .StoreItem.Assets assets = 30;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::assets(this), target, stream);
  }

  // optional .StoreItem.ReleaseInfo release = 31;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        31, _Internal::release(this), target, stream);
  }

  // optional .StoreItem.Platforms platforms = 32;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        32, _Internal::platforms(this), target, stream);
  }

  // optional .StoreGameRating game_rating = 33 [(.description) = "Local ratings agency information, like ESRB or PEGI"];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        33, _Internal::game_rating(this), target, stream);
  }

  // optional .StoreItem.PurchaseOption best_purchase_option = 40 [(.description) = "The cheapest way for the user to acquire this app or package (may be a bundle)."];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        40, _Internal::best_purchase_option(this), target, stream);
  }

  // repeated .StoreItem.PurchaseOption purchase_options = 41 [(.description) = "Different ways to buy this app or packages (packages can be purchased directly, but may also be included in bundles)."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_purchase_options_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(41, this->_internal_purchase_options(i), target, stream);
  }

  // repeated .StoreItem.PurchaseOption accessories = 42 [(.description) = "Additional packages or bundles associated with an app, but that do not contain the app."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_accessories_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(42, this->_internal_accessories(i), target, stream);
  }

  // optional .StoreItem.Screenshots screenshots = 50;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        50, _Internal::screenshots(this), target, stream);
  }

  // optional .StoreItem.Trailers trailers = 51;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        51, _Internal::trailers(this), target, stream);
  }

  // repeated .StoreItem.SupportedLanguage supported_languages = 52;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_supported_languages_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(52, this->_internal_supported_languages(i), target, stream);
  }

  // optional string store_url_path_override = 53 [(.description) = "Navigate to this URL (relative to store home) when the store capsule for this item is clicked, instead of the default /app/... URL. Used by advertising apps that point to a sale page."];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_store_url_path_override().data(), static_cast<int>(this->_internal_store_url_path_override().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.store_url_path_override");
    target = stream->WriteStringMaybeAliased(
        53, this->_internal_store_url_path_override(), target);
  }

  // optional .StoreItem.FreeWeekend free_weekend = 54 [(.description) = "Information about a free weekend offer."];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        54, _Internal::free_weekend(this), target, stream);
  }

  // optional bool unlisted = 55 [(.description) = "If true, item is only accessible on store via a direct link"];
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(55, this->_internal_unlisted(), target);
  }

  // optional uint32 game_count = 56 [(.description) = "For creators and tags, how many games belong to them"];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(56, this->_internal_game_count(), target);
  }

  // optional string internal_name = 57 [(.description) = "For hub categories, the internal name (handle) of the category"];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_internal_name().data(), static_cast<int>(this->_internal_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.internal_name");
    target = stream->WriteStringMaybeAliased(
        57, this->_internal_internal_name(), target);
  }

  // optional string full_description = 58 [(.description) = "About this game section on the store page"];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_full_description().data(), static_cast<int>(this->_internal_full_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StoreItem.full_description");
    target = stream->WriteStringMaybeAliased(
        58, this->_internal_full_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StoreItem)
  return target;
}

size_t StoreItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StoreItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .EStoreAppType included_types = 11 [(.description) = "For packages/bundles, all types of included items"];
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_included_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_included_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated uint32 included_appids = 12 [(.description) = "For packages/bundles, all included appids"];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->included_appids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_included_appids_size());
    total_size += data_size;
  }

  // repeated .EContentDescriptorID content_descriptorids = 20;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_content_descriptorids_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_content_descriptorids(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  // repeated uint32 tagids = 21;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->tagids_);
    total_size += 2 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_tagids_size());
    total_size += data_size;
  }

  // repeated .StoreItem.Tag tags = 25;
  total_size += 2UL * this->_internal_tags_size();
  for (const auto& msg : this->tags_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.PurchaseOption purchase_options = 41 [(.description) = "Different ways to buy this app or packages (packages can be purchased directly, but may also be included in bundles)."];
  total_size += 2UL * this->_internal_purchase_options_size();
  for (const auto& msg : this->purchase_options_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.PurchaseOption accessories = 42 [(.description) = "Additional packages or bundles associated with an app, but that do not contain the app."];
  total_size += 2UL * this->_internal_accessories_size();
  for (const auto& msg : this->accessories_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .StoreItem.SupportedLanguage supported_languages = 52;
  total_size += 2UL * this->_internal_supported_languages_size();
  for (const auto& msg : this->supported_languages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string store_url_path = 7 [(.description) = "The URL of this item\'s store page, to be appended to STORE_BASE_URL."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_store_url_path());
    }

    // optional string store_url_path_override = 53 [(.description) = "Navigate to this URL (relative to store home) when the store capsule for this item is clicked, instead of the default /app/... URL. Used by advertising apps that point to a sale page."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_store_url_path_override());
    }

    // optional string internal_name = 57 [(.description) = "For hub categories, the internal name (handle) of the category"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_internal_name());
    }

    // optional string full_description = 58 [(.description) = "About this game section on the store page"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_full_description());
    }

    // optional .StoreItem.RelatedItems related_items = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *related_items_);
    }

    // optional .StoreItem.Categories categories = 22;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *categories_);
    }

    // optional .StoreItem.Reviews reviews = 23;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *reviews_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .StoreItem.BasicInfo basic_info = 24;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *basic_info_);
    }

    // optional .StoreItem.Assets assets = 30;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *assets_);
    }

    // optional .StoreItem.ReleaseInfo release = 31;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *release_);
    }

    // optional .StoreItem.Platforms platforms = 32;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *platforms_);
    }

    // optional .StoreGameRating game_rating = 33 [(.description) = "Local ratings agency information, like ESRB or PEGI"];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *game_rating_);
    }

    // optional .StoreItem.PurchaseOption best_purchase_option = 40 [(.description) = "The cheapest way for the user to acquire this app or package (may be a bundle)."];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *best_purchase_option_);
    }

    // optional .StoreItem.Screenshots screenshots = 50;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *screenshots_);
    }

    // optional .StoreItem.Trailers trailers = 51;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *trailers_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .StoreItem.FreeWeekend free_weekend = 54 [(.description) = "Information about a free weekend offer."];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *free_weekend_);
    }

    // optional uint32 id = 2;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional uint32 success = 3 [(.description) = "EResult of this lookup action"];
    if (cached_has_bits & 0x00040000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_success());
    }

    // optional uint32 appid = 9 [(.description) = "If this is an app, or a single-app package, the steamworks appid."];
    if (cached_has_bits & 0x00080000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional bool visible = 4;
    if (cached_has_bits & 0x00100000u) {
      total_size += 1 + 1;
    }

    // optional bool unvailable_for_country_restriction = 5 [(.description) = "Indicates this app is visible in other regions, but not the requested reagion"];
    if (cached_has_bits & 0x00200000u) {
      total_size += 1 + 1;
    }

    // optional bool is_free = 13;
    if (cached_has_bits & 0x00400000u) {
      total_size += 1 + 1;
    }

    // optional bool is_early_access = 14;
    if (cached_has_bits & 0x00800000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0f000000u) {
    // optional .EStoreAppType type = 10 [default = k_EStoreAppType_Game, (.description) = "Type of app (Game, Software, Music).  For packages/bundles, this will be the most interesting type (eg Game + Soundtrack bundle will have type Game)"];
    if (cached_has_bits & 0x01000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool unlisted = 55 [(.description) = "If true, item is only accessible on store via a direct link"];
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional uint32 game_count = 56 [(.description) = "For creators and tags, how many games belong to them"];
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_game_count());
    }

    // optional .EStoreItemType item_type = 1 [default = k_EStoreItemType_Invalid];
    if (cached_has_bits & 0x08000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_item_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreItem::GetClassData() const { return &_class_data_; }

void StoreItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreItem *>(to)->MergeFrom(
      static_cast<const StoreItem &>(from));
}


void StoreItem::MergeFrom(const StoreItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StoreItem)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  included_types_.MergeFrom(from.included_types_);
  included_appids_.MergeFrom(from.included_appids_);
  content_descriptorids_.MergeFrom(from.content_descriptorids_);
  tagids_.MergeFrom(from.tagids_);
  tags_.MergeFrom(from.tags_);
  purchase_options_.MergeFrom(from.purchase_options_);
  accessories_.MergeFrom(from.accessories_);
  supported_languages_.MergeFrom(from.supported_languages_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_store_url_path(from._internal_store_url_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_store_url_path_override(from._internal_store_url_path_override());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_internal_name(from._internal_internal_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_full_description(from._internal_full_description());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_related_items()->::StoreItem_RelatedItems::MergeFrom(from._internal_related_items());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_categories()->::StoreItem_Categories::MergeFrom(from._internal_categories());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_reviews()->::StoreItem_Reviews::MergeFrom(from._internal_reviews());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_basic_info()->::StoreItem_BasicInfo::MergeFrom(from._internal_basic_info());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_assets()->::StoreItem_Assets::MergeFrom(from._internal_assets());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_release()->::StoreItem_ReleaseInfo::MergeFrom(from._internal_release());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_platforms()->::StoreItem_Platforms::MergeFrom(from._internal_platforms());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_game_rating()->::StoreGameRating::MergeFrom(from._internal_game_rating());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_best_purchase_option()->::StoreItem_PurchaseOption::MergeFrom(from._internal_best_purchase_option());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_screenshots()->::StoreItem_Screenshots::MergeFrom(from._internal_screenshots());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_trailers()->::StoreItem_Trailers::MergeFrom(from._internal_trailers());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_free_weekend()->::StoreItem_FreeWeekend::MergeFrom(from._internal_free_weekend());
    }
    if (cached_has_bits & 0x00020000u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00040000u) {
      success_ = from.success_;
    }
    if (cached_has_bits & 0x00080000u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00100000u) {
      visible_ = from.visible_;
    }
    if (cached_has_bits & 0x00200000u) {
      unvailable_for_country_restriction_ = from.unvailable_for_country_restriction_;
    }
    if (cached_has_bits & 0x00400000u) {
      is_free_ = from.is_free_;
    }
    if (cached_has_bits & 0x00800000u) {
      is_early_access_ = from.is_early_access_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0f000000u) {
    if (cached_has_bits & 0x01000000u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x02000000u) {
      unlisted_ = from.unlisted_;
    }
    if (cached_has_bits & 0x04000000u) {
      game_count_ = from.game_count_;
    }
    if (cached_has_bits & 0x08000000u) {
      item_type_ = from.item_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreItem::CopyFrom(const StoreItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StoreItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem::IsInitialized() const {
  return true;
}

void StoreItem::InternalSwap(StoreItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  included_types_.InternalSwap(&other->included_types_);
  included_appids_.InternalSwap(&other->included_appids_);
  content_descriptorids_.InternalSwap(&other->content_descriptorids_);
  tagids_.InternalSwap(&other->tagids_);
  tags_.InternalSwap(&other->tags_);
  purchase_options_.InternalSwap(&other->purchase_options_);
  accessories_.InternalSwap(&other->accessories_);
  supported_languages_.InternalSwap(&other->supported_languages_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &store_url_path_, lhs_arena,
      &other->store_url_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &store_url_path_override_, lhs_arena,
      &other->store_url_path_override_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &internal_name_, lhs_arena,
      &other->internal_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &full_description_, lhs_arena,
      &other->full_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreItem, game_count_)
      + sizeof(StoreItem::game_count_)
      - PROTOBUF_FIELD_OFFSET(StoreItem, related_items_)>(
          reinterpret_cast<char*>(&related_items_),
          reinterpret_cast<char*>(&other->related_items_));
  swap(item_type_, other->item_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreItem::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[25]);
}

// ===================================================================

class CStoreBrowse_GetItems_Response::_Internal {
 public:
};

CStoreBrowse_GetItems_Response::CStoreBrowse_GetItems_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  store_items_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetItems_Response)
}
CStoreBrowse_GetItems_Response::CStoreBrowse_GetItems_Response(const CStoreBrowse_GetItems_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      store_items_(from.store_items_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetItems_Response)
}

inline void CStoreBrowse_GetItems_Response::SharedCtor() {
}

CStoreBrowse_GetItems_Response::~CStoreBrowse_GetItems_Response() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetItems_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetItems_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStoreBrowse_GetItems_Response::ArenaDtor(void* object) {
  CStoreBrowse_GetItems_Response* _this = reinterpret_cast< CStoreBrowse_GetItems_Response* >(object);
  (void)_this;
}
void CStoreBrowse_GetItems_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetItems_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetItems_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetItems_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  store_items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetItems_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .StoreItem store_items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_store_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetItems_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetItems_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .StoreItem store_items = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_store_items_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_store_items(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetItems_Response)
  return target;
}

size_t CStoreBrowse_GetItems_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetItems_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .StoreItem store_items = 1;
  total_size += 1UL * this->_internal_store_items_size();
  for (const auto& msg : this->store_items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetItems_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetItems_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetItems_Response::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetItems_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetItems_Response *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetItems_Response &>(from));
}


void CStoreBrowse_GetItems_Response::MergeFrom(const CStoreBrowse_GetItems_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetItems_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  store_items_.MergeFrom(from.store_items_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetItems_Response::CopyFrom(const CStoreBrowse_GetItems_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetItems_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetItems_Response::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetItems_Response::InternalSwap(CStoreBrowse_GetItems_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  store_items_.InternalSwap(&other->store_items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetItems_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[26]);
}

// ===================================================================

class CStoreBrowse_GetStoreCategories_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CStoreBrowse_GetStoreCategories_Request>()._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_elanguage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CStoreBrowse_GetStoreCategories_Request::CStoreBrowse_GetStoreCategories_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetStoreCategories_Request)
}
CStoreBrowse_GetStoreCategories_Request::CStoreBrowse_GetStoreCategories_Request(const CStoreBrowse_GetStoreCategories_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_language(), 
      GetArenaForAllocation());
  }
  elanguage_ = from.elanguage_;
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetStoreCategories_Request)
}

inline void CStoreBrowse_GetStoreCategories_Request::SharedCtor() {
language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
elanguage_ = -1;
}

CStoreBrowse_GetStoreCategories_Request::~CStoreBrowse_GetStoreCategories_Request() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetStoreCategories_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetStoreCategories_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  language_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CStoreBrowse_GetStoreCategories_Request::ArenaDtor(void* object) {
  CStoreBrowse_GetStoreCategories_Request* _this = reinterpret_cast< CStoreBrowse_GetStoreCategories_Request* >(object);
  (void)_this;
}
void CStoreBrowse_GetStoreCategories_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetStoreCategories_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetStoreCategories_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetStoreCategories_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      language_.ClearNonDefaultToEmpty();
    }
    elanguage_ = -1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetStoreCategories_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_language();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CStoreBrowse_GetStoreCategories_Request.language");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 elanguage = 2 [default = -1, (.description) = "ELanguage"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_elanguage(&has_bits);
          elanguage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetStoreCategories_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetStoreCategories_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string language = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CStoreBrowse_GetStoreCategories_Request.language");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_language(), target);
  }

  // optional int32 elanguage = 2 [default = -1, (.description) = "ELanguage"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_elanguage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetStoreCategories_Request)
  return target;
}

size_t CStoreBrowse_GetStoreCategories_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetStoreCategories_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string language = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional int32 elanguage = 2 [default = -1, (.description) = "ELanguage"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_elanguage());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetStoreCategories_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetStoreCategories_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetStoreCategories_Request::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetStoreCategories_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetStoreCategories_Request *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetStoreCategories_Request &>(from));
}


void CStoreBrowse_GetStoreCategories_Request::MergeFrom(const CStoreBrowse_GetStoreCategories_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetStoreCategories_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      elanguage_ = from.elanguage_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetStoreCategories_Request::CopyFrom(const CStoreBrowse_GetStoreCategories_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetStoreCategories_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetStoreCategories_Request::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetStoreCategories_Request::InternalSwap(CStoreBrowse_GetStoreCategories_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &language_, lhs_arena,
      &other->language_, rhs_arena
  );
  swap(elanguage_, other->elanguage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetStoreCategories_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[27]);
}

// ===================================================================

class CStoreBrowse_GetStoreCategories_Response_Category::_Internal {
 public:
  using HasBits = decltype(std::declval<CStoreBrowse_GetStoreCategories_Response_Category>()._has_bits_);
  static void set_has_categoryid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_internal_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_display_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_image_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_show_in_search(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CStoreBrowse_GetStoreCategories_Response_Category::CStoreBrowse_GetStoreCategories_Response_Category(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetStoreCategories_Response.Category)
}
CStoreBrowse_GetStoreCategories_Response_Category::CStoreBrowse_GetStoreCategories_Response_Category(const CStoreBrowse_GetStoreCategories_Response_Category& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  internal_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    internal_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_internal_name()) {
    internal_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_internal_name(), 
      GetArenaForAllocation());
  }
  display_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_display_name()) {
    display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_display_name(), 
      GetArenaForAllocation());
  }
  image_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image_url()) {
    image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_image_url(), 
      GetArenaForAllocation());
  }
  ::memcpy(&categoryid_, &from.categoryid_,
    static_cast<size_t>(reinterpret_cast<char*>(&show_in_search_) -
    reinterpret_cast<char*>(&categoryid_)) + sizeof(show_in_search_));
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetStoreCategories_Response.Category)
}

inline void CStoreBrowse_GetStoreCategories_Response_Category::SharedCtor() {
internal_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  internal_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
display_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
image_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&categoryid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&show_in_search_) -
    reinterpret_cast<char*>(&categoryid_)) + sizeof(show_in_search_));
}

CStoreBrowse_GetStoreCategories_Response_Category::~CStoreBrowse_GetStoreCategories_Response_Category() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetStoreCategories_Response.Category)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetStoreCategories_Response_Category::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  internal_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  display_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  image_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CStoreBrowse_GetStoreCategories_Response_Category::ArenaDtor(void* object) {
  CStoreBrowse_GetStoreCategories_Response_Category* _this = reinterpret_cast< CStoreBrowse_GetStoreCategories_Response_Category* >(object);
  (void)_this;
}
void CStoreBrowse_GetStoreCategories_Response_Category::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetStoreCategories_Response_Category::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetStoreCategories_Response_Category::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetStoreCategories_Response.Category)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      internal_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      display_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      image_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&categoryid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&show_in_search_) -
        reinterpret_cast<char*>(&categoryid_)) + sizeof(show_in_search_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetStoreCategories_Response_Category::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 categoryid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_categoryid(&has_bits);
          categoryid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStoreCategoryType type = 2 [default = k_EStoreCategoryType_Category];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStoreCategoryType_IsValid(val))) {
            _internal_set_type(static_cast<::EStoreCategoryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string internal_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_internal_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CStoreBrowse_GetStoreCategories_Response.Category.internal_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string display_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_display_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CStoreBrowse_GetStoreCategories_Response.Category.display_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string image_url = 5 [(.description) = "Append to STORE_CDN_URL"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_image_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CStoreBrowse_GetStoreCategories_Response.Category.image_url");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_in_search = 6 [(.description) = "Indicates this category can link to search results showing all items in category."];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_show_in_search(&has_bits);
          show_in_search_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetStoreCategories_Response_Category::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetStoreCategories_Response.Category)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 categoryid = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_categoryid(), target);
  }

  // optional .EStoreCategoryType type = 2 [default = k_EStoreCategoryType_Category];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional string internal_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_internal_name().data(), static_cast<int>(this->_internal_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CStoreBrowse_GetStoreCategories_Response.Category.internal_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_internal_name(), target);
  }

  // optional string display_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_display_name().data(), static_cast<int>(this->_internal_display_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CStoreBrowse_GetStoreCategories_Response.Category.display_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_display_name(), target);
  }

  // optional string image_url = 5 [(.description) = "Append to STORE_CDN_URL"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_image_url().data(), static_cast<int>(this->_internal_image_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CStoreBrowse_GetStoreCategories_Response.Category.image_url");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_image_url(), target);
  }

  // optional bool show_in_search = 6 [(.description) = "Indicates this category can link to search results showing all items in category."];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_show_in_search(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetStoreCategories_Response.Category)
  return target;
}

size_t CStoreBrowse_GetStoreCategories_Response_Category::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetStoreCategories_Response.Category)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string internal_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_internal_name());
    }

    // optional string display_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_display_name());
    }

    // optional string image_url = 5 [(.description) = "Append to STORE_CDN_URL"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_image_url());
    }

    // optional uint32 categoryid = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_categoryid());
    }

    // optional .EStoreCategoryType type = 2 [default = k_EStoreCategoryType_Category];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool show_in_search = 6 [(.description) = "Indicates this category can link to search results showing all items in category."];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetStoreCategories_Response_Category::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetStoreCategories_Response_Category::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetStoreCategories_Response_Category::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetStoreCategories_Response_Category::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetStoreCategories_Response_Category *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetStoreCategories_Response_Category &>(from));
}


void CStoreBrowse_GetStoreCategories_Response_Category::MergeFrom(const CStoreBrowse_GetStoreCategories_Response_Category& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetStoreCategories_Response.Category)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_internal_name(from._internal_internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_display_name(from._internal_display_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_image_url(from._internal_image_url());
    }
    if (cached_has_bits & 0x00000008u) {
      categoryid_ = from.categoryid_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      show_in_search_ = from.show_in_search_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetStoreCategories_Response_Category::CopyFrom(const CStoreBrowse_GetStoreCategories_Response_Category& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetStoreCategories_Response.Category)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetStoreCategories_Response_Category::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetStoreCategories_Response_Category::InternalSwap(CStoreBrowse_GetStoreCategories_Response_Category* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &internal_name_, lhs_arena,
      &other->internal_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &display_name_, lhs_arena,
      &other->display_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &image_url_, lhs_arena,
      &other->image_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetStoreCategories_Response_Category, show_in_search_)
      + sizeof(CStoreBrowse_GetStoreCategories_Response_Category::show_in_search_)
      - PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetStoreCategories_Response_Category, categoryid_)>(
          reinterpret_cast<char*>(&categoryid_),
          reinterpret_cast<char*>(&other->categoryid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetStoreCategories_Response_Category::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[28]);
}

// ===================================================================

class CStoreBrowse_GetStoreCategories_Response::_Internal {
 public:
};

CStoreBrowse_GetStoreCategories_Response::CStoreBrowse_GetStoreCategories_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  categories_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetStoreCategories_Response)
}
CStoreBrowse_GetStoreCategories_Response::CStoreBrowse_GetStoreCategories_Response(const CStoreBrowse_GetStoreCategories_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      categories_(from.categories_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetStoreCategories_Response)
}

inline void CStoreBrowse_GetStoreCategories_Response::SharedCtor() {
}

CStoreBrowse_GetStoreCategories_Response::~CStoreBrowse_GetStoreCategories_Response() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetStoreCategories_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetStoreCategories_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStoreBrowse_GetStoreCategories_Response::ArenaDtor(void* object) {
  CStoreBrowse_GetStoreCategories_Response* _this = reinterpret_cast< CStoreBrowse_GetStoreCategories_Response* >(object);
  (void)_this;
}
void CStoreBrowse_GetStoreCategories_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetStoreCategories_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetStoreCategories_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetStoreCategories_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  categories_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetStoreCategories_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CStoreBrowse_GetStoreCategories_Response.Category categories = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_categories(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetStoreCategories_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetStoreCategories_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CStoreBrowse_GetStoreCategories_Response.Category categories = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_categories_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_categories(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetStoreCategories_Response)
  return target;
}

size_t CStoreBrowse_GetStoreCategories_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetStoreCategories_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CStoreBrowse_GetStoreCategories_Response.Category categories = 1;
  total_size += 1UL * this->_internal_categories_size();
  for (const auto& msg : this->categories_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetStoreCategories_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetStoreCategories_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetStoreCategories_Response::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetStoreCategories_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetStoreCategories_Response *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetStoreCategories_Response &>(from));
}


void CStoreBrowse_GetStoreCategories_Response::MergeFrom(const CStoreBrowse_GetStoreCategories_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetStoreCategories_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  categories_.MergeFrom(from.categories_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetStoreCategories_Response::CopyFrom(const CStoreBrowse_GetStoreCategories_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetStoreCategories_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetStoreCategories_Response::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetStoreCategories_Response::InternalSwap(CStoreBrowse_GetStoreCategories_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  categories_.InternalSwap(&other->categories_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetStoreCategories_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[29]);
}

// ===================================================================

class CStoreBrowse_GetDLCForApps_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CStoreBrowse_GetDLCForApps_Request>()._has_bits_);
  static const ::StoreBrowseContext& context(const CStoreBrowse_GetDLCForApps_Request* msg);
  static void set_has_context(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CStorePageFilter& store_page_filter(const CStoreBrowse_GetDLCForApps_Request* msg);
  static void set_has_store_page_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::StoreBrowseContext&
CStoreBrowse_GetDLCForApps_Request::_Internal::context(const CStoreBrowse_GetDLCForApps_Request* msg) {
  return *msg->context_;
}
const ::CStorePageFilter&
CStoreBrowse_GetDLCForApps_Request::_Internal::store_page_filter(const CStoreBrowse_GetDLCForApps_Request* msg) {
  return *msg->store_page_filter_;
}
void CStoreBrowse_GetDLCForApps_Request::clear_store_page_filter() {
  if (store_page_filter_ != nullptr) store_page_filter_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CStoreBrowse_GetDLCForApps_Request::CStoreBrowse_GetDLCForApps_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  appids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetDLCForApps_Request)
}
CStoreBrowse_GetDLCForApps_Request::CStoreBrowse_GetDLCForApps_Request(const CStoreBrowse_GetDLCForApps_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      appids_(from.appids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_context()) {
    context_ = new ::StoreBrowseContext(*from.context_);
  } else {
    context_ = nullptr;
  }
  if (from._internal_has_store_page_filter()) {
    store_page_filter_ = new ::CStorePageFilter(*from.store_page_filter_);
  } else {
    store_page_filter_ = nullptr;
  }
  steamid_ = from.steamid_;
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetDLCForApps_Request)
}

inline void CStoreBrowse_GetDLCForApps_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&context_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&steamid_) -
    reinterpret_cast<char*>(&context_)) + sizeof(steamid_));
}

CStoreBrowse_GetDLCForApps_Request::~CStoreBrowse_GetDLCForApps_Request() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetDLCForApps_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetDLCForApps_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete context_;
  if (this != internal_default_instance()) delete store_page_filter_;
}

void CStoreBrowse_GetDLCForApps_Request::ArenaDtor(void* object) {
  CStoreBrowse_GetDLCForApps_Request* _this = reinterpret_cast< CStoreBrowse_GetDLCForApps_Request* >(object);
  (void)_this;
}
void CStoreBrowse_GetDLCForApps_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetDLCForApps_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetDLCForApps_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetDLCForApps_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  appids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(context_ != nullptr);
      context_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(store_page_filter_ != nullptr);
      store_page_filter_->Clear();
    }
  }
  steamid_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetDLCForApps_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .StoreBrowseContext context = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CStorePageFilter store_page_filter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_store_page_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .StoreItemID appids = 3 [(.description) = "Apps for which we want DLC information."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_appids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 steamid = 4 [(.description) = "If specified, we want DLC information for all apps owned by this user."];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetDLCForApps_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetDLCForApps_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .StoreBrowseContext context = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::context(this), target, stream);
  }

  // optional .CStorePageFilter store_page_filter = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::store_page_filter(this), target, stream);
  }

  // repeated .StoreItemID appids = 3 [(.description) = "Apps for which we want DLC information."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_appids_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_appids(i), target, stream);
  }

  // optional uint64 steamid = 4 [(.description) = "If specified, we want DLC information for all apps owned by this user."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetDLCForApps_Request)
  return target;
}

size_t CStoreBrowse_GetDLCForApps_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetDLCForApps_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .StoreItemID appids = 3 [(.description) = "Apps for which we want DLC information."];
  total_size += 1UL * this->_internal_appids_size();
  for (const auto& msg : this->appids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .StoreBrowseContext context = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *context_);
    }

    // optional .CStorePageFilter store_page_filter = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *store_page_filter_);
    }

    // optional uint64 steamid = 4 [(.description) = "If specified, we want DLC information for all apps owned by this user."];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_steamid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetDLCForApps_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetDLCForApps_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetDLCForApps_Request::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetDLCForApps_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetDLCForApps_Request *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetDLCForApps_Request &>(from));
}


void CStoreBrowse_GetDLCForApps_Request::MergeFrom(const CStoreBrowse_GetDLCForApps_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetDLCForApps_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  appids_.MergeFrom(from.appids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_context()->::StoreBrowseContext::MergeFrom(from._internal_context());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_store_page_filter()->::CStorePageFilter::MergeFrom(from._internal_store_page_filter());
    }
    if (cached_has_bits & 0x00000004u) {
      steamid_ = from.steamid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetDLCForApps_Request::CopyFrom(const CStoreBrowse_GetDLCForApps_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetDLCForApps_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetDLCForApps_Request::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetDLCForApps_Request::InternalSwap(CStoreBrowse_GetDLCForApps_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  appids_.InternalSwap(&other->appids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetDLCForApps_Request, steamid_)
      + sizeof(CStoreBrowse_GetDLCForApps_Request::steamid_)
      - PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetDLCForApps_Request, context_)>(
          reinterpret_cast<char*>(&context_),
          reinterpret_cast<char*>(&other->context_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetDLCForApps_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[30]);
}

// ===================================================================

class CStoreBrowse_GetDLCForApps_Response_DLCData::_Internal {
 public:
  using HasBits = decltype(std::declval<CStoreBrowse_GetDLCForApps_Response_DLCData>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parentappid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_release_date(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_coming_soon(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_discount(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_free(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CStoreBrowse_GetDLCForApps_Response_DLCData::CStoreBrowse_GetDLCForApps_Response_DLCData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetDLCForApps_Response.DLCData)
}
CStoreBrowse_GetDLCForApps_Response_DLCData::CStoreBrowse_GetDLCForApps_Response_DLCData(const CStoreBrowse_GetDLCForApps_Response_DLCData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&discount_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(discount_));
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetDLCForApps_Response.DLCData)
}

inline void CStoreBrowse_GetDLCForApps_Response_DLCData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&discount_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(discount_));
}

CStoreBrowse_GetDLCForApps_Response_DLCData::~CStoreBrowse_GetDLCForApps_Response_DLCData() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetDLCForApps_Response.DLCData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetDLCForApps_Response_DLCData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStoreBrowse_GetDLCForApps_Response_DLCData::ArenaDtor(void* object) {
  CStoreBrowse_GetDLCForApps_Response_DLCData* _this = reinterpret_cast< CStoreBrowse_GetDLCForApps_Response_DLCData* >(object);
  (void)_this;
}
void CStoreBrowse_GetDLCForApps_Response_DLCData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetDLCForApps_Response_DLCData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetDLCForApps_Response_DLCData::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetDLCForApps_Response.DLCData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&discount_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(discount_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetDLCForApps_Response_DLCData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 parentappid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_parentappid(&has_bits);
          parentappid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 release_date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_release_date(&has_bits);
          release_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool coming_soon = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_coming_soon(&has_bits);
          coming_soon_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 price = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_price(&has_bits);
          price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 discount = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_discount(&has_bits);
          discount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool free = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_free(&has_bits);
          free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetDLCForApps_Response_DLCData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetDLCForApps_Response.DLCData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 parentappid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_parentappid(), target);
  }

  // optional uint32 release_date = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_release_date(), target);
  }

  // optional bool coming_soon = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_coming_soon(), target);
  }

  // optional int64 price = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_price(), target);
  }

  // optional uint32 discount = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_discount(), target);
  }

  // optional bool free = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_free(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetDLCForApps_Response.DLCData)
  return target;
}

size_t CStoreBrowse_GetDLCForApps_Response_DLCData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetDLCForApps_Response.DLCData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 parentappid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_parentappid());
    }

    // optional uint32 release_date = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_release_date());
    }

    // optional bool coming_soon = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool free = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional int64 price = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_price());
    }

    // optional uint32 discount = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_discount());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetDLCForApps_Response_DLCData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetDLCForApps_Response_DLCData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetDLCForApps_Response_DLCData::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetDLCForApps_Response_DLCData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetDLCForApps_Response_DLCData *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetDLCForApps_Response_DLCData &>(from));
}


void CStoreBrowse_GetDLCForApps_Response_DLCData::MergeFrom(const CStoreBrowse_GetDLCForApps_Response_DLCData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetDLCForApps_Response.DLCData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      parentappid_ = from.parentappid_;
    }
    if (cached_has_bits & 0x00000004u) {
      release_date_ = from.release_date_;
    }
    if (cached_has_bits & 0x00000008u) {
      coming_soon_ = from.coming_soon_;
    }
    if (cached_has_bits & 0x00000010u) {
      free_ = from.free_;
    }
    if (cached_has_bits & 0x00000020u) {
      price_ = from.price_;
    }
    if (cached_has_bits & 0x00000040u) {
      discount_ = from.discount_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetDLCForApps_Response_DLCData::CopyFrom(const CStoreBrowse_GetDLCForApps_Response_DLCData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetDLCForApps_Response.DLCData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetDLCForApps_Response_DLCData::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetDLCForApps_Response_DLCData::InternalSwap(CStoreBrowse_GetDLCForApps_Response_DLCData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetDLCForApps_Response_DLCData, discount_)
      + sizeof(CStoreBrowse_GetDLCForApps_Response_DLCData::discount_)
      - PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetDLCForApps_Response_DLCData, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetDLCForApps_Response_DLCData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[31]);
}

// ===================================================================

class CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_Internal {
 public:
  using HasBits = decltype(std::declval<CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_playtime(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_last_played(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
}
CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp(const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&last_played_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(last_played_));
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
}

inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&last_played_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(last_played_));
}

CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::~CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::ArenaDtor(void* object) {
  CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* _this = reinterpret_cast< CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* >(object);
  (void)_this;
}
void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&last_played_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(last_played_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 playtime = 2 [(.description) = "Total time played over all time."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playtime(&has_bits);
          playtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_played = 3 [(.description) = "Time last played on any platform."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_last_played(&has_bits);
          last_played_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 playtime = 2 [(.description) = "Total time played over all time."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_playtime(), target);
  }

  // optional uint32 last_played = 3 [(.description) = "Time last played on any platform."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_last_played(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
  return target;
}

size_t CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 playtime = 2 [(.description) = "Total time played over all time."];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_playtime());
    }

    // optional uint32 last_played = 3 [(.description) = "Time last played on any platform."];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_last_played());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp &>(from));
}


void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::MergeFrom(const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      playtime_ = from.playtime_;
    }
    if (cached_has_bits & 0x00000004u) {
      last_played_ = from.last_played_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::CopyFrom(const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::InternalSwap(CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp, last_played_)
      + sizeof(CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::last_played_)
      - PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[32]);
}

// ===================================================================

class CStoreBrowse_GetDLCForApps_Response::_Internal {
 public:
};

CStoreBrowse_GetDLCForApps_Response::CStoreBrowse_GetDLCForApps_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  dlc_data_(arena),
  playtime_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetDLCForApps_Response)
}
CStoreBrowse_GetDLCForApps_Response::CStoreBrowse_GetDLCForApps_Response(const CStoreBrowse_GetDLCForApps_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      dlc_data_(from.dlc_data_),
      playtime_(from.playtime_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetDLCForApps_Response)
}

inline void CStoreBrowse_GetDLCForApps_Response::SharedCtor() {
}

CStoreBrowse_GetDLCForApps_Response::~CStoreBrowse_GetDLCForApps_Response() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetDLCForApps_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetDLCForApps_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStoreBrowse_GetDLCForApps_Response::ArenaDtor(void* object) {
  CStoreBrowse_GetDLCForApps_Response* _this = reinterpret_cast< CStoreBrowse_GetDLCForApps_Response* >(object);
  (void)_this;
}
void CStoreBrowse_GetDLCForApps_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetDLCForApps_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetDLCForApps_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetDLCForApps_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dlc_data_.Clear();
  playtime_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetDLCForApps_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CStoreBrowse_GetDLCForApps_Response.DLCData dlc_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dlc_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp playtime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_playtime(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetDLCForApps_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetDLCForApps_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CStoreBrowse_GetDLCForApps_Response.DLCData dlc_data = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_dlc_data_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_dlc_data(i), target, stream);
  }

  // repeated .CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp playtime = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_playtime_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_playtime(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetDLCForApps_Response)
  return target;
}

size_t CStoreBrowse_GetDLCForApps_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetDLCForApps_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CStoreBrowse_GetDLCForApps_Response.DLCData dlc_data = 1;
  total_size += 1UL * this->_internal_dlc_data_size();
  for (const auto& msg : this->dlc_data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp playtime = 2;
  total_size += 1UL * this->_internal_playtime_size();
  for (const auto& msg : this->playtime_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetDLCForApps_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetDLCForApps_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetDLCForApps_Response::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetDLCForApps_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetDLCForApps_Response *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetDLCForApps_Response &>(from));
}


void CStoreBrowse_GetDLCForApps_Response::MergeFrom(const CStoreBrowse_GetDLCForApps_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetDLCForApps_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dlc_data_.MergeFrom(from.dlc_data_);
  playtime_.MergeFrom(from.playtime_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetDLCForApps_Response::CopyFrom(const CStoreBrowse_GetDLCForApps_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetDLCForApps_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetDLCForApps_Response::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetDLCForApps_Response::InternalSwap(CStoreBrowse_GetDLCForApps_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  dlc_data_.InternalSwap(&other->dlc_data_);
  playtime_.InternalSwap(&other->playtime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetDLCForApps_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[33]);
}

// ===================================================================

class CStoreBrowse_GetDLCForAppsSolr_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CStoreBrowse_GetDLCForAppsSolr_Request>()._has_bits_);
  static const ::StoreBrowseContext& context(const CStoreBrowse_GetDLCForAppsSolr_Request* msg);
  static void set_has_context(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flavor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CStorePageFilter& store_page_filter(const CStoreBrowse_GetDLCForAppsSolr_Request* msg);
  static void set_has_store_page_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::StoreBrowseContext&
CStoreBrowse_GetDLCForAppsSolr_Request::_Internal::context(const CStoreBrowse_GetDLCForAppsSolr_Request* msg) {
  return *msg->context_;
}
const ::CStorePageFilter&
CStoreBrowse_GetDLCForAppsSolr_Request::_Internal::store_page_filter(const CStoreBrowse_GetDLCForAppsSolr_Request* msg) {
  return *msg->store_page_filter_;
}
void CStoreBrowse_GetDLCForAppsSolr_Request::clear_store_page_filter() {
  if (store_page_filter_ != nullptr) store_page_filter_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
CStoreBrowse_GetDLCForAppsSolr_Request::CStoreBrowse_GetDLCForAppsSolr_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  appids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetDLCForAppsSolr_Request)
}
CStoreBrowse_GetDLCForAppsSolr_Request::CStoreBrowse_GetDLCForAppsSolr_Request(const CStoreBrowse_GetDLCForAppsSolr_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      appids_(from.appids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  flavor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    flavor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_flavor()) {
    flavor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_flavor(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_context()) {
    context_ = new ::StoreBrowseContext(*from.context_);
  } else {
    context_ = nullptr;
  }
  if (from._internal_has_store_page_filter()) {
    store_page_filter_ = new ::CStorePageFilter(*from.store_page_filter_);
  } else {
    store_page_filter_ = nullptr;
  }
  count_ = from.count_;
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetDLCForAppsSolr_Request)
}

inline void CStoreBrowse_GetDLCForAppsSolr_Request::SharedCtor() {
flavor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  flavor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&context_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&context_)) + sizeof(count_));
}

CStoreBrowse_GetDLCForAppsSolr_Request::~CStoreBrowse_GetDLCForAppsSolr_Request() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetDLCForAppsSolr_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetDLCForAppsSolr_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  flavor_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete context_;
  if (this != internal_default_instance()) delete store_page_filter_;
}

void CStoreBrowse_GetDLCForAppsSolr_Request::ArenaDtor(void* object) {
  CStoreBrowse_GetDLCForAppsSolr_Request* _this = reinterpret_cast< CStoreBrowse_GetDLCForAppsSolr_Request* >(object);
  (void)_this;
}
void CStoreBrowse_GetDLCForAppsSolr_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetDLCForAppsSolr_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetDLCForAppsSolr_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetDLCForAppsSolr_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  appids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      flavor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(context_ != nullptr);
      context_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(store_page_filter_ != nullptr);
      store_page_filter_->Clear();
    }
  }
  count_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetDLCForAppsSolr_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .StoreBrowseContext context = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 appids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_appids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_appids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string flavor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_flavor();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CStoreBrowse_GetDLCForAppsSolr_Request.flavor");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CStorePageFilter store_page_filter = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_store_page_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetDLCForAppsSolr_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetDLCForAppsSolr_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .StoreBrowseContext context = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::context(this), target, stream);
  }

  // repeated uint32 appids = 2;
  for (int i = 0, n = this->_internal_appids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_appids(i), target);
  }

  // optional string flavor = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_flavor().data(), static_cast<int>(this->_internal_flavor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CStoreBrowse_GetDLCForAppsSolr_Request.flavor");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_flavor(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
  }

  // optional .CStorePageFilter store_page_filter = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::store_page_filter(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetDLCForAppsSolr_Request)
  return target;
}

size_t CStoreBrowse_GetDLCForAppsSolr_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetDLCForAppsSolr_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 appids = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->appids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_appids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string flavor = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_flavor());
    }

    // optional .StoreBrowseContext context = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *context_);
    }

    // optional .CStorePageFilter store_page_filter = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *store_page_filter_);
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetDLCForAppsSolr_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetDLCForAppsSolr_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetDLCForAppsSolr_Request::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetDLCForAppsSolr_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetDLCForAppsSolr_Request *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetDLCForAppsSolr_Request &>(from));
}


void CStoreBrowse_GetDLCForAppsSolr_Request::MergeFrom(const CStoreBrowse_GetDLCForAppsSolr_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetDLCForAppsSolr_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  appids_.MergeFrom(from.appids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_flavor(from._internal_flavor());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_context()->::StoreBrowseContext::MergeFrom(from._internal_context());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_store_page_filter()->::CStorePageFilter::MergeFrom(from._internal_store_page_filter());
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetDLCForAppsSolr_Request::CopyFrom(const CStoreBrowse_GetDLCForAppsSolr_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetDLCForAppsSolr_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetDLCForAppsSolr_Request::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetDLCForAppsSolr_Request::InternalSwap(CStoreBrowse_GetDLCForAppsSolr_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  appids_.InternalSwap(&other->appids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &flavor_, lhs_arena,
      &other->flavor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetDLCForAppsSolr_Request, count_)
      + sizeof(CStoreBrowse_GetDLCForAppsSolr_Request::count_)
      - PROTOBUF_FIELD_OFFSET(CStoreBrowse_GetDLCForAppsSolr_Request, context_)>(
          reinterpret_cast<char*>(&context_),
          reinterpret_cast<char*>(&other->context_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetDLCForAppsSolr_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[34]);
}

// ===================================================================

class CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_Internal {
 public:
  using HasBits = decltype(std::declval<CStoreBrowse_GetDLCForAppsSolr_Response_DLCList>()._has_bits_);
  static void set_has_parent_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  dlc_appids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
}
CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList(const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      dlc_appids_(from.dlc_appids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  parent_appid_ = from.parent_appid_;
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
}

inline void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::SharedCtor() {
parent_appid_ = 0u;
}

CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::~CStoreBrowse_GetDLCForAppsSolr_Response_DLCList() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::ArenaDtor(void* object) {
  CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* _this = reinterpret_cast< CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* >(object);
  (void)_this;
}
void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dlc_appids_.Clear();
  parent_appid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 parent_appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_parent_appid(&has_bits);
          parent_appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 dlc_appids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dlc_appids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_dlc_appids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 parent_appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_parent_appid(), target);
  }

  // repeated uint32 dlc_appids = 2;
  for (int i = 0, n = this->_internal_dlc_appids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_dlc_appids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
  return target;
}

size_t CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 dlc_appids = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->dlc_appids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_dlc_appids_size());
    total_size += data_size;
  }

  // optional uint32 parent_appid = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_appid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetDLCForAppsSolr_Response_DLCList *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList &>(from));
}


void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::MergeFrom(const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dlc_appids_.MergeFrom(from.dlc_appids_);
  if (from._internal_has_parent_appid()) {
    _internal_set_parent_appid(from._internal_parent_appid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::CopyFrom(const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::InternalSwap(CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  dlc_appids_.InternalSwap(&other->dlc_appids_);
  swap(parent_appid_, other->parent_appid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[35]);
}

// ===================================================================

class CStoreBrowse_GetDLCForAppsSolr_Response::_Internal {
 public:
};

CStoreBrowse_GetDLCForAppsSolr_Response::CStoreBrowse_GetDLCForAppsSolr_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  dlc_lists_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStoreBrowse_GetDLCForAppsSolr_Response)
}
CStoreBrowse_GetDLCForAppsSolr_Response::CStoreBrowse_GetDLCForAppsSolr_Response(const CStoreBrowse_GetDLCForAppsSolr_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      dlc_lists_(from.dlc_lists_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CStoreBrowse_GetDLCForAppsSolr_Response)
}

inline void CStoreBrowse_GetDLCForAppsSolr_Response::SharedCtor() {
}

CStoreBrowse_GetDLCForAppsSolr_Response::~CStoreBrowse_GetDLCForAppsSolr_Response() {
  // @@protoc_insertion_point(destructor:CStoreBrowse_GetDLCForAppsSolr_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStoreBrowse_GetDLCForAppsSolr_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStoreBrowse_GetDLCForAppsSolr_Response::ArenaDtor(void* object) {
  CStoreBrowse_GetDLCForAppsSolr_Response* _this = reinterpret_cast< CStoreBrowse_GetDLCForAppsSolr_Response* >(object);
  (void)_this;
}
void CStoreBrowse_GetDLCForAppsSolr_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStoreBrowse_GetDLCForAppsSolr_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStoreBrowse_GetDLCForAppsSolr_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CStoreBrowse_GetDLCForAppsSolr_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dlc_lists_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStoreBrowse_GetDLCForAppsSolr_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CStoreBrowse_GetDLCForAppsSolr_Response.DLCList dlc_lists = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dlc_lists(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStoreBrowse_GetDLCForAppsSolr_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStoreBrowse_GetDLCForAppsSolr_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CStoreBrowse_GetDLCForAppsSolr_Response.DLCList dlc_lists = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_dlc_lists_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_dlc_lists(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStoreBrowse_GetDLCForAppsSolr_Response)
  return target;
}

size_t CStoreBrowse_GetDLCForAppsSolr_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStoreBrowse_GetDLCForAppsSolr_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CStoreBrowse_GetDLCForAppsSolr_Response.DLCList dlc_lists = 1;
  total_size += 1UL * this->_internal_dlc_lists_size();
  for (const auto& msg : this->dlc_lists_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStoreBrowse_GetDLCForAppsSolr_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStoreBrowse_GetDLCForAppsSolr_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStoreBrowse_GetDLCForAppsSolr_Response::GetClassData() const { return &_class_data_; }

void CStoreBrowse_GetDLCForAppsSolr_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStoreBrowse_GetDLCForAppsSolr_Response *>(to)->MergeFrom(
      static_cast<const CStoreBrowse_GetDLCForAppsSolr_Response &>(from));
}


void CStoreBrowse_GetDLCForAppsSolr_Response::MergeFrom(const CStoreBrowse_GetDLCForAppsSolr_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStoreBrowse_GetDLCForAppsSolr_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  dlc_lists_.MergeFrom(from.dlc_lists_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStoreBrowse_GetDLCForAppsSolr_Response::CopyFrom(const CStoreBrowse_GetDLCForAppsSolr_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStoreBrowse_GetDLCForAppsSolr_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStoreBrowse_GetDLCForAppsSolr_Response::IsInitialized() const {
  return true;
}

void CStoreBrowse_GetDLCForAppsSolr_Response::InternalSwap(CStoreBrowse_GetDLCForAppsSolr_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  dlc_lists_.InternalSwap(&other->dlc_lists_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStoreBrowse_GetDLCForAppsSolr_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fstorebrowse_2esteamclient_2eproto[36]);
}

// ===================================================================

StoreBrowse::~StoreBrowse() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* StoreBrowse::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fstorebrowse_2esteamclient_2eproto[0];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* StoreBrowse::GetDescriptor() {
  return descriptor();
}

void StoreBrowse::GetItems(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CStoreBrowse_GetItems_Request*,
                         ::CStoreBrowse_GetItems_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetItems() not implemented.");
  done->Run();
}

void StoreBrowse::GetStoreCategories(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CStoreBrowse_GetStoreCategories_Request*,
                         ::CStoreBrowse_GetStoreCategories_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetStoreCategories() not implemented.");
  done->Run();
}

void StoreBrowse::GetDLCForApps(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CStoreBrowse_GetDLCForApps_Request*,
                         ::CStoreBrowse_GetDLCForApps_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetDLCForApps() not implemented.");
  done->Run();
}

void StoreBrowse::GetDLCForAppsSolr(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CStoreBrowse_GetDLCForAppsSolr_Request*,
                         ::CStoreBrowse_GetDLCForAppsSolr_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetDLCForAppsSolr() not implemented.");
  done->Run();
}

void StoreBrowse::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fstorebrowse_2esteamclient_2eproto[0]);
  switch(method->index()) {
    case 0:
      GetItems(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CStoreBrowse_GetItems_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CStoreBrowse_GetItems_Response*>(
                 response),
             done);
      break;
    case 1:
      GetStoreCategories(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CStoreBrowse_GetStoreCategories_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CStoreBrowse_GetStoreCategories_Response*>(
                 response),
             done);
      break;
    case 2:
      GetDLCForApps(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CStoreBrowse_GetDLCForApps_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CStoreBrowse_GetDLCForApps_Response*>(
                 response),
             done);
      break;
    case 3:
      GetDLCForAppsSolr(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CStoreBrowse_GetDLCForAppsSolr_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CStoreBrowse_GetDLCForAppsSolr_Response*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& StoreBrowse::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CStoreBrowse_GetItems_Request::default_instance();
    case 1:
      return ::CStoreBrowse_GetStoreCategories_Request::default_instance();
    case 2:
      return ::CStoreBrowse_GetDLCForApps_Request::default_instance();
    case 3:
      return ::CStoreBrowse_GetDLCForAppsSolr_Request::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& StoreBrowse::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CStoreBrowse_GetItems_Response::default_instance();
    case 1:
      return ::CStoreBrowse_GetStoreCategories_Response::default_instance();
    case 2:
      return ::CStoreBrowse_GetDLCForApps_Response::default_instance();
    case 3:
      return ::CStoreBrowse_GetDLCForAppsSolr_Response::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

StoreBrowse_Stub::StoreBrowse_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
StoreBrowse_Stub::StoreBrowse_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
StoreBrowse_Stub::~StoreBrowse_Stub() {
  if (owns_channel_) delete channel_;
}

void StoreBrowse_Stub::GetItems(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CStoreBrowse_GetItems_Request* request,
                              ::CStoreBrowse_GetItems_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void StoreBrowse_Stub::GetStoreCategories(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CStoreBrowse_GetStoreCategories_Request* request,
                              ::CStoreBrowse_GetStoreCategories_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void StoreBrowse_Stub::GetDLCForApps(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CStoreBrowse_GetDLCForApps_Request* request,
                              ::CStoreBrowse_GetDLCForApps_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void StoreBrowse_Stub::GetDLCForAppsSolr(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CStoreBrowse_GetDLCForAppsSolr_Request* request,
                              ::CStoreBrowse_GetDLCForAppsSolr_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::StoreItemID* Arena::CreateMaybeMessage< ::StoreItemID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItemID >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreBrowseContext* Arena::CreateMaybeMessage< ::StoreBrowseContext >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreBrowseContext >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreBrowseItemDataRequest* Arena::CreateMaybeMessage< ::StoreBrowseItemDataRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreBrowseItemDataRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetItems_Request* Arena::CreateMaybeMessage< ::CStoreBrowse_GetItems_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetItems_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreGameRating* Arena::CreateMaybeMessage< ::StoreGameRating >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreGameRating >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_RelatedItems* Arena::CreateMaybeMessage< ::StoreItem_RelatedItems >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_RelatedItems >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Categories* Arena::CreateMaybeMessage< ::StoreItem_Categories >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Categories >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Reviews_StoreReviewSummary* Arena::CreateMaybeMessage< ::StoreItem_Reviews_StoreReviewSummary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Reviews_StoreReviewSummary >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Reviews* Arena::CreateMaybeMessage< ::StoreItem_Reviews >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Reviews >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_BasicInfo_CreatorHomeLink* Arena::CreateMaybeMessage< ::StoreItem_BasicInfo_CreatorHomeLink >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_BasicInfo_CreatorHomeLink >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_BasicInfo* Arena::CreateMaybeMessage< ::StoreItem_BasicInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_BasicInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Tag* Arena::CreateMaybeMessage< ::StoreItem_Tag >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Tag >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Assets* Arena::CreateMaybeMessage< ::StoreItem_Assets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Assets >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_ReleaseInfo* Arena::CreateMaybeMessage< ::StoreItem_ReleaseInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_ReleaseInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Platforms_VRSupport* Arena::CreateMaybeMessage< ::StoreItem_Platforms_VRSupport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Platforms_VRSupport >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Platforms* Arena::CreateMaybeMessage< ::StoreItem_Platforms >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Platforms >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_PurchaseOption_Discount* Arena::CreateMaybeMessage< ::StoreItem_PurchaseOption_Discount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_PurchaseOption_Discount >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_PurchaseOption* Arena::CreateMaybeMessage< ::StoreItem_PurchaseOption >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_PurchaseOption >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Screenshots_Screenshot* Arena::CreateMaybeMessage< ::StoreItem_Screenshots_Screenshot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Screenshots_Screenshot >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Screenshots* Arena::CreateMaybeMessage< ::StoreItem_Screenshots >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Screenshots >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Trailers_VideoSource* Arena::CreateMaybeMessage< ::StoreItem_Trailers_VideoSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Trailers_VideoSource >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Trailers_Trailer* Arena::CreateMaybeMessage< ::StoreItem_Trailers_Trailer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Trailers_Trailer >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_Trailers* Arena::CreateMaybeMessage< ::StoreItem_Trailers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_Trailers >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_SupportedLanguage* Arena::CreateMaybeMessage< ::StoreItem_SupportedLanguage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_SupportedLanguage >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem_FreeWeekend* Arena::CreateMaybeMessage< ::StoreItem_FreeWeekend >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem_FreeWeekend >(arena);
}
template<> PROTOBUF_NOINLINE ::StoreItem* Arena::CreateMaybeMessage< ::StoreItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StoreItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetItems_Response* Arena::CreateMaybeMessage< ::CStoreBrowse_GetItems_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetItems_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetStoreCategories_Request* Arena::CreateMaybeMessage< ::CStoreBrowse_GetStoreCategories_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetStoreCategories_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetStoreCategories_Response_Category* Arena::CreateMaybeMessage< ::CStoreBrowse_GetStoreCategories_Response_Category >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetStoreCategories_Response_Category >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetStoreCategories_Response* Arena::CreateMaybeMessage< ::CStoreBrowse_GetStoreCategories_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetStoreCategories_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetDLCForApps_Request* Arena::CreateMaybeMessage< ::CStoreBrowse_GetDLCForApps_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetDLCForApps_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetDLCForApps_Response_DLCData* Arena::CreateMaybeMessage< ::CStoreBrowse_GetDLCForApps_Response_DLCData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetDLCForApps_Response_DLCData >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* Arena::CreateMaybeMessage< ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetDLCForApps_Response* Arena::CreateMaybeMessage< ::CStoreBrowse_GetDLCForApps_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetDLCForApps_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetDLCForAppsSolr_Request* Arena::CreateMaybeMessage< ::CStoreBrowse_GetDLCForAppsSolr_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetDLCForAppsSolr_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* Arena::CreateMaybeMessage< ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList >(arena);
}
template<> PROTOBUF_NOINLINE ::CStoreBrowse_GetDLCForAppsSolr_Response* Arena::CreateMaybeMessage< ::CStoreBrowse_GetDLCForAppsSolr_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStoreBrowse_GetDLCForAppsSolr_Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
