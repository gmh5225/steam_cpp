// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_contentsystem.steamclient.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fcontentsystem_2esteamclient_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fcontentsystem_2esteamclient_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "steammessages_base.pb.h"
#include "steammessages_unified_base.steamclient.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fcontentsystem_2esteamclient_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto;
class CContentServerDirectory_GetCDNAuthToken_Request;
struct CContentServerDirectory_GetCDNAuthToken_RequestDefaultTypeInternal;
extern CContentServerDirectory_GetCDNAuthToken_RequestDefaultTypeInternal _CContentServerDirectory_GetCDNAuthToken_Request_default_instance_;
class CContentServerDirectory_GetCDNAuthToken_Response;
struct CContentServerDirectory_GetCDNAuthToken_ResponseDefaultTypeInternal;
extern CContentServerDirectory_GetCDNAuthToken_ResponseDefaultTypeInternal _CContentServerDirectory_GetCDNAuthToken_Response_default_instance_;
class CContentServerDirectory_GetClientUpdateHosts_Request;
struct CContentServerDirectory_GetClientUpdateHosts_RequestDefaultTypeInternal;
extern CContentServerDirectory_GetClientUpdateHosts_RequestDefaultTypeInternal _CContentServerDirectory_GetClientUpdateHosts_Request_default_instance_;
class CContentServerDirectory_GetClientUpdateHosts_Response;
struct CContentServerDirectory_GetClientUpdateHosts_ResponseDefaultTypeInternal;
extern CContentServerDirectory_GetClientUpdateHosts_ResponseDefaultTypeInternal _CContentServerDirectory_GetClientUpdateHosts_Response_default_instance_;
class CContentServerDirectory_GetDepotPatchInfo_Request;
struct CContentServerDirectory_GetDepotPatchInfo_RequestDefaultTypeInternal;
extern CContentServerDirectory_GetDepotPatchInfo_RequestDefaultTypeInternal _CContentServerDirectory_GetDepotPatchInfo_Request_default_instance_;
class CContentServerDirectory_GetDepotPatchInfo_Response;
struct CContentServerDirectory_GetDepotPatchInfo_ResponseDefaultTypeInternal;
extern CContentServerDirectory_GetDepotPatchInfo_ResponseDefaultTypeInternal _CContentServerDirectory_GetDepotPatchInfo_Response_default_instance_;
class CContentServerDirectory_GetManifestRequestCode_Request;
struct CContentServerDirectory_GetManifestRequestCode_RequestDefaultTypeInternal;
extern CContentServerDirectory_GetManifestRequestCode_RequestDefaultTypeInternal _CContentServerDirectory_GetManifestRequestCode_Request_default_instance_;
class CContentServerDirectory_GetManifestRequestCode_Response;
struct CContentServerDirectory_GetManifestRequestCode_ResponseDefaultTypeInternal;
extern CContentServerDirectory_GetManifestRequestCode_ResponseDefaultTypeInternal _CContentServerDirectory_GetManifestRequestCode_Response_default_instance_;
class CContentServerDirectory_GetPeerContentInfo_Request;
struct CContentServerDirectory_GetPeerContentInfo_RequestDefaultTypeInternal;
extern CContentServerDirectory_GetPeerContentInfo_RequestDefaultTypeInternal _CContentServerDirectory_GetPeerContentInfo_Request_default_instance_;
class CContentServerDirectory_GetPeerContentInfo_Response;
struct CContentServerDirectory_GetPeerContentInfo_ResponseDefaultTypeInternal;
extern CContentServerDirectory_GetPeerContentInfo_ResponseDefaultTypeInternal _CContentServerDirectory_GetPeerContentInfo_Response_default_instance_;
class CContentServerDirectory_GetServersForSteamPipe_Request;
struct CContentServerDirectory_GetServersForSteamPipe_RequestDefaultTypeInternal;
extern CContentServerDirectory_GetServersForSteamPipe_RequestDefaultTypeInternal _CContentServerDirectory_GetServersForSteamPipe_Request_default_instance_;
class CContentServerDirectory_GetServersForSteamPipe_Response;
struct CContentServerDirectory_GetServersForSteamPipe_ResponseDefaultTypeInternal;
extern CContentServerDirectory_GetServersForSteamPipe_ResponseDefaultTypeInternal _CContentServerDirectory_GetServersForSteamPipe_Response_default_instance_;
class CContentServerDirectory_RequestPeerContentServer_Request;
struct CContentServerDirectory_RequestPeerContentServer_RequestDefaultTypeInternal;
extern CContentServerDirectory_RequestPeerContentServer_RequestDefaultTypeInternal _CContentServerDirectory_RequestPeerContentServer_Request_default_instance_;
class CContentServerDirectory_RequestPeerContentServer_Response;
struct CContentServerDirectory_RequestPeerContentServer_ResponseDefaultTypeInternal;
extern CContentServerDirectory_RequestPeerContentServer_ResponseDefaultTypeInternal _CContentServerDirectory_RequestPeerContentServer_Response_default_instance_;
class CContentServerDirectory_ServerInfo;
struct CContentServerDirectory_ServerInfoDefaultTypeInternal;
extern CContentServerDirectory_ServerInfoDefaultTypeInternal _CContentServerDirectory_ServerInfo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CContentServerDirectory_GetCDNAuthToken_Request* Arena::CreateMaybeMessage<::CContentServerDirectory_GetCDNAuthToken_Request>(Arena*);
template<> ::CContentServerDirectory_GetCDNAuthToken_Response* Arena::CreateMaybeMessage<::CContentServerDirectory_GetCDNAuthToken_Response>(Arena*);
template<> ::CContentServerDirectory_GetClientUpdateHosts_Request* Arena::CreateMaybeMessage<::CContentServerDirectory_GetClientUpdateHosts_Request>(Arena*);
template<> ::CContentServerDirectory_GetClientUpdateHosts_Response* Arena::CreateMaybeMessage<::CContentServerDirectory_GetClientUpdateHosts_Response>(Arena*);
template<> ::CContentServerDirectory_GetDepotPatchInfo_Request* Arena::CreateMaybeMessage<::CContentServerDirectory_GetDepotPatchInfo_Request>(Arena*);
template<> ::CContentServerDirectory_GetDepotPatchInfo_Response* Arena::CreateMaybeMessage<::CContentServerDirectory_GetDepotPatchInfo_Response>(Arena*);
template<> ::CContentServerDirectory_GetManifestRequestCode_Request* Arena::CreateMaybeMessage<::CContentServerDirectory_GetManifestRequestCode_Request>(Arena*);
template<> ::CContentServerDirectory_GetManifestRequestCode_Response* Arena::CreateMaybeMessage<::CContentServerDirectory_GetManifestRequestCode_Response>(Arena*);
template<> ::CContentServerDirectory_GetPeerContentInfo_Request* Arena::CreateMaybeMessage<::CContentServerDirectory_GetPeerContentInfo_Request>(Arena*);
template<> ::CContentServerDirectory_GetPeerContentInfo_Response* Arena::CreateMaybeMessage<::CContentServerDirectory_GetPeerContentInfo_Response>(Arena*);
template<> ::CContentServerDirectory_GetServersForSteamPipe_Request* Arena::CreateMaybeMessage<::CContentServerDirectory_GetServersForSteamPipe_Request>(Arena*);
template<> ::CContentServerDirectory_GetServersForSteamPipe_Response* Arena::CreateMaybeMessage<::CContentServerDirectory_GetServersForSteamPipe_Response>(Arena*);
template<> ::CContentServerDirectory_RequestPeerContentServer_Request* Arena::CreateMaybeMessage<::CContentServerDirectory_RequestPeerContentServer_Request>(Arena*);
template<> ::CContentServerDirectory_RequestPeerContentServer_Response* Arena::CreateMaybeMessage<::CContentServerDirectory_RequestPeerContentServer_Response>(Arena*);
template<> ::CContentServerDirectory_ServerInfo* Arena::CreateMaybeMessage<::CContentServerDirectory_ServerInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class CContentServerDirectory_GetServersForSteamPipe_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetServersForSteamPipe_Request) */ {
 public:
  inline CContentServerDirectory_GetServersForSteamPipe_Request() : CContentServerDirectory_GetServersForSteamPipe_Request(nullptr) {}
  ~CContentServerDirectory_GetServersForSteamPipe_Request() override;
  explicit constexpr CContentServerDirectory_GetServersForSteamPipe_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetServersForSteamPipe_Request(const CContentServerDirectory_GetServersForSteamPipe_Request& from);
  CContentServerDirectory_GetServersForSteamPipe_Request(CContentServerDirectory_GetServersForSteamPipe_Request&& from) noexcept
    : CContentServerDirectory_GetServersForSteamPipe_Request() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetServersForSteamPipe_Request& operator=(const CContentServerDirectory_GetServersForSteamPipe_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetServersForSteamPipe_Request& operator=(CContentServerDirectory_GetServersForSteamPipe_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetServersForSteamPipe_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetServersForSteamPipe_Request* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetServersForSteamPipe_Request*>(
               &_CContentServerDirectory_GetServersForSteamPipe_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CContentServerDirectory_GetServersForSteamPipe_Request& a, CContentServerDirectory_GetServersForSteamPipe_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetServersForSteamPipe_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetServersForSteamPipe_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetServersForSteamPipe_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetServersForSteamPipe_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetServersForSteamPipe_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetServersForSteamPipe_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetServersForSteamPipe_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetServersForSteamPipe_Request";
  }
  protected:
  explicit CContentServerDirectory_GetServersForSteamPipe_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpOverrideFieldNumber = 3,
    kIpv6PublicFieldNumber = 5,
    kCellIdFieldNumber = 1,
    kLauncherTypeFieldNumber = 4,
    kMaxServersFieldNumber = 2,
  };
  // optional string ip_override = 3 [(.description) = "client IP address"];
  bool has_ip_override() const;
  private:
  bool _internal_has_ip_override() const;
  public:
  void clear_ip_override();
  const std::string& ip_override() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_override(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_override();
  PROTOBUF_NODISCARD std::string* release_ip_override();
  void set_allocated_ip_override(std::string* ip_override);
  private:
  const std::string& _internal_ip_override() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_override(const std::string& value);
  std::string* _internal_mutable_ip_override();
  public:

  // optional string ipv6_public = 5 [(.description) = "client public ipv6 address if it knows it"];
  bool has_ipv6_public() const;
  private:
  bool _internal_has_ipv6_public() const;
  public:
  void clear_ipv6_public();
  const std::string& ipv6_public() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipv6_public(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipv6_public();
  PROTOBUF_NODISCARD std::string* release_ipv6_public();
  void set_allocated_ipv6_public(std::string* ipv6_public);
  private:
  const std::string& _internal_ipv6_public() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipv6_public(const std::string& value);
  std::string* _internal_mutable_ipv6_public();
  public:

  // optional uint32 cell_id = 1 [(.description) = "client Cell ID"];
  bool has_cell_id() const;
  private:
  bool _internal_has_cell_id() const;
  public:
  void clear_cell_id();
  uint32_t cell_id() const;
  void set_cell_id(uint32_t value);
  private:
  uint32_t _internal_cell_id() const;
  void _internal_set_cell_id(uint32_t value);
  public:

  // optional int32 launcher_type = 4 [default = 0, (.description) = "launcher type"];
  bool has_launcher_type() const;
  private:
  bool _internal_has_launcher_type() const;
  public:
  void clear_launcher_type();
  int32_t launcher_type() const;
  void set_launcher_type(int32_t value);
  private:
  int32_t _internal_launcher_type() const;
  void _internal_set_launcher_type(int32_t value);
  public:

  // optional uint32 max_servers = 2 [default = 20, (.description) = "max servers in response list"];
  bool has_max_servers() const;
  private:
  bool _internal_has_max_servers() const;
  public:
  void clear_max_servers();
  uint32_t max_servers() const;
  void set_max_servers(uint32_t value);
  private:
  uint32_t _internal_max_servers() const;
  void _internal_set_max_servers(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetServersForSteamPipe_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_override_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipv6_public_;
  uint32_t cell_id_;
  int32_t launcher_type_;
  uint32_t max_servers_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_ServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_ServerInfo) */ {
 public:
  inline CContentServerDirectory_ServerInfo() : CContentServerDirectory_ServerInfo(nullptr) {}
  ~CContentServerDirectory_ServerInfo() override;
  explicit constexpr CContentServerDirectory_ServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_ServerInfo(const CContentServerDirectory_ServerInfo& from);
  CContentServerDirectory_ServerInfo(CContentServerDirectory_ServerInfo&& from) noexcept
    : CContentServerDirectory_ServerInfo() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_ServerInfo& operator=(const CContentServerDirectory_ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_ServerInfo& operator=(CContentServerDirectory_ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_ServerInfo* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_ServerInfo*>(
               &_CContentServerDirectory_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CContentServerDirectory_ServerInfo& a, CContentServerDirectory_ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_ServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_ServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_ServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_ServerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_ServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_ServerInfo";
  }
  protected:
  explicit CContentServerDirectory_ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedAppIdsFieldNumber = 13,
    kTypeFieldNumber = 1,
    kHostFieldNumber = 8,
    kVhostFieldNumber = 9,
    kProxyRequestPathTemplateFieldNumber = 11,
    kHttpsSupportFieldNumber = 12,
    kSourceIdFieldNumber = 2,
    kCellIdFieldNumber = 3,
    kLoadFieldNumber = 4,
    kWeightedLoadFieldNumber = 5,
    kNumEntriesInClientListFieldNumber = 6,
    kSteamChinaOnlyFieldNumber = 7,
    kUseAsProxyFieldNumber = 10,
    kPreferredServerFieldNumber = 14,
  };
  // repeated uint32 allowed_app_ids = 13;
  int allowed_app_ids_size() const;
  private:
  int _internal_allowed_app_ids_size() const;
  public:
  void clear_allowed_app_ids();
  private:
  uint32_t _internal_allowed_app_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_allowed_app_ids() const;
  void _internal_add_allowed_app_ids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_allowed_app_ids();
  public:
  uint32_t allowed_app_ids(int index) const;
  void set_allowed_app_ids(int index, uint32_t value);
  void add_allowed_app_ids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      allowed_app_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_allowed_app_ids();

  // optional string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string host = 8;
  bool has_host() const;
  private:
  bool _internal_has_host() const;
  public:
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // optional string vhost = 9;
  bool has_vhost() const;
  private:
  bool _internal_has_vhost() const;
  public:
  void clear_vhost();
  const std::string& vhost() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vhost(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vhost();
  PROTOBUF_NODISCARD std::string* release_vhost();
  void set_allocated_vhost(std::string* vhost);
  private:
  const std::string& _internal_vhost() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vhost(const std::string& value);
  std::string* _internal_mutable_vhost();
  public:

  // optional string proxy_request_path_template = 11;
  bool has_proxy_request_path_template() const;
  private:
  bool _internal_has_proxy_request_path_template() const;
  public:
  void clear_proxy_request_path_template();
  const std::string& proxy_request_path_template() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proxy_request_path_template(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proxy_request_path_template();
  PROTOBUF_NODISCARD std::string* release_proxy_request_path_template();
  void set_allocated_proxy_request_path_template(std::string* proxy_request_path_template);
  private:
  const std::string& _internal_proxy_request_path_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proxy_request_path_template(const std::string& value);
  std::string* _internal_mutable_proxy_request_path_template();
  public:

  // optional string https_support = 12;
  bool has_https_support() const;
  private:
  bool _internal_has_https_support() const;
  public:
  void clear_https_support();
  const std::string& https_support() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_https_support(ArgT0&& arg0, ArgT... args);
  std::string* mutable_https_support();
  PROTOBUF_NODISCARD std::string* release_https_support();
  void set_allocated_https_support(std::string* https_support);
  private:
  const std::string& _internal_https_support() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_https_support(const std::string& value);
  std::string* _internal_mutable_https_support();
  public:

  // optional int32 source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  int32_t source_id() const;
  void set_source_id(int32_t value);
  private:
  int32_t _internal_source_id() const;
  void _internal_set_source_id(int32_t value);
  public:

  // optional int32 cell_id = 3;
  bool has_cell_id() const;
  private:
  bool _internal_has_cell_id() const;
  public:
  void clear_cell_id();
  int32_t cell_id() const;
  void set_cell_id(int32_t value);
  private:
  int32_t _internal_cell_id() const;
  void _internal_set_cell_id(int32_t value);
  public:

  // optional int32 load = 4;
  bool has_load() const;
  private:
  bool _internal_has_load() const;
  public:
  void clear_load();
  int32_t load() const;
  void set_load(int32_t value);
  private:
  int32_t _internal_load() const;
  void _internal_set_load(int32_t value);
  public:

  // optional float weighted_load = 5;
  bool has_weighted_load() const;
  private:
  bool _internal_has_weighted_load() const;
  public:
  void clear_weighted_load();
  float weighted_load() const;
  void set_weighted_load(float value);
  private:
  float _internal_weighted_load() const;
  void _internal_set_weighted_load(float value);
  public:

  // optional int32 num_entries_in_client_list = 6;
  bool has_num_entries_in_client_list() const;
  private:
  bool _internal_has_num_entries_in_client_list() const;
  public:
  void clear_num_entries_in_client_list();
  int32_t num_entries_in_client_list() const;
  void set_num_entries_in_client_list(int32_t value);
  private:
  int32_t _internal_num_entries_in_client_list() const;
  void _internal_set_num_entries_in_client_list(int32_t value);
  public:

  // optional bool steam_china_only = 7;
  bool has_steam_china_only() const;
  private:
  bool _internal_has_steam_china_only() const;
  public:
  void clear_steam_china_only();
  bool steam_china_only() const;
  void set_steam_china_only(bool value);
  private:
  bool _internal_steam_china_only() const;
  void _internal_set_steam_china_only(bool value);
  public:

  // optional bool use_as_proxy = 10;
  bool has_use_as_proxy() const;
  private:
  bool _internal_has_use_as_proxy() const;
  public:
  void clear_use_as_proxy();
  bool use_as_proxy() const;
  void set_use_as_proxy(bool value);
  private:
  bool _internal_use_as_proxy() const;
  void _internal_set_use_as_proxy(bool value);
  public:

  // optional bool preferred_server = 14;
  bool has_preferred_server() const;
  private:
  bool _internal_has_preferred_server() const;
  public:
  void clear_preferred_server();
  bool preferred_server() const;
  void set_preferred_server(bool value);
  private:
  bool _internal_preferred_server() const;
  void _internal_set_preferred_server(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > allowed_app_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vhost_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proxy_request_path_template_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr https_support_;
  int32_t source_id_;
  int32_t cell_id_;
  int32_t load_;
  float weighted_load_;
  int32_t num_entries_in_client_list_;
  bool steam_china_only_;
  bool use_as_proxy_;
  bool preferred_server_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetServersForSteamPipe_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetServersForSteamPipe_Response) */ {
 public:
  inline CContentServerDirectory_GetServersForSteamPipe_Response() : CContentServerDirectory_GetServersForSteamPipe_Response(nullptr) {}
  ~CContentServerDirectory_GetServersForSteamPipe_Response() override;
  explicit constexpr CContentServerDirectory_GetServersForSteamPipe_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetServersForSteamPipe_Response(const CContentServerDirectory_GetServersForSteamPipe_Response& from);
  CContentServerDirectory_GetServersForSteamPipe_Response(CContentServerDirectory_GetServersForSteamPipe_Response&& from) noexcept
    : CContentServerDirectory_GetServersForSteamPipe_Response() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetServersForSteamPipe_Response& operator=(const CContentServerDirectory_GetServersForSteamPipe_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetServersForSteamPipe_Response& operator=(CContentServerDirectory_GetServersForSteamPipe_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetServersForSteamPipe_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetServersForSteamPipe_Response* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetServersForSteamPipe_Response*>(
               &_CContentServerDirectory_GetServersForSteamPipe_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CContentServerDirectory_GetServersForSteamPipe_Response& a, CContentServerDirectory_GetServersForSteamPipe_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetServersForSteamPipe_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetServersForSteamPipe_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetServersForSteamPipe_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetServersForSteamPipe_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetServersForSteamPipe_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetServersForSteamPipe_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetServersForSteamPipe_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetServersForSteamPipe_Response";
  }
  protected:
  explicit CContentServerDirectory_GetServersForSteamPipe_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServersFieldNumber = 1,
  };
  // repeated .CContentServerDirectory_ServerInfo servers = 1;
  int servers_size() const;
  private:
  int _internal_servers_size() const;
  public:
  void clear_servers();
  ::CContentServerDirectory_ServerInfo* mutable_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CContentServerDirectory_ServerInfo >*
      mutable_servers();
  private:
  const ::CContentServerDirectory_ServerInfo& _internal_servers(int index) const;
  ::CContentServerDirectory_ServerInfo* _internal_add_servers();
  public:
  const ::CContentServerDirectory_ServerInfo& servers(int index) const;
  ::CContentServerDirectory_ServerInfo* add_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CContentServerDirectory_ServerInfo >&
      servers() const;

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetServersForSteamPipe_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CContentServerDirectory_ServerInfo > servers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetDepotPatchInfo_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetDepotPatchInfo_Request) */ {
 public:
  inline CContentServerDirectory_GetDepotPatchInfo_Request() : CContentServerDirectory_GetDepotPatchInfo_Request(nullptr) {}
  ~CContentServerDirectory_GetDepotPatchInfo_Request() override;
  explicit constexpr CContentServerDirectory_GetDepotPatchInfo_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetDepotPatchInfo_Request(const CContentServerDirectory_GetDepotPatchInfo_Request& from);
  CContentServerDirectory_GetDepotPatchInfo_Request(CContentServerDirectory_GetDepotPatchInfo_Request&& from) noexcept
    : CContentServerDirectory_GetDepotPatchInfo_Request() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetDepotPatchInfo_Request& operator=(const CContentServerDirectory_GetDepotPatchInfo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetDepotPatchInfo_Request& operator=(CContentServerDirectory_GetDepotPatchInfo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetDepotPatchInfo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetDepotPatchInfo_Request* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetDepotPatchInfo_Request*>(
               &_CContentServerDirectory_GetDepotPatchInfo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CContentServerDirectory_GetDepotPatchInfo_Request& a, CContentServerDirectory_GetDepotPatchInfo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetDepotPatchInfo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetDepotPatchInfo_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetDepotPatchInfo_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetDepotPatchInfo_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetDepotPatchInfo_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetDepotPatchInfo_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetDepotPatchInfo_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetDepotPatchInfo_Request";
  }
  protected:
  explicit CContentServerDirectory_GetDepotPatchInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
    kDepotidFieldNumber = 2,
    kSourceManifestidFieldNumber = 3,
    kTargetManifestidFieldNumber = 4,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint32 depotid = 2;
  bool has_depotid() const;
  private:
  bool _internal_has_depotid() const;
  public:
  void clear_depotid();
  uint32_t depotid() const;
  void set_depotid(uint32_t value);
  private:
  uint32_t _internal_depotid() const;
  void _internal_set_depotid(uint32_t value);
  public:

  // optional uint64 source_manifestid = 3;
  bool has_source_manifestid() const;
  private:
  bool _internal_has_source_manifestid() const;
  public:
  void clear_source_manifestid();
  uint64_t source_manifestid() const;
  void set_source_manifestid(uint64_t value);
  private:
  uint64_t _internal_source_manifestid() const;
  void _internal_set_source_manifestid(uint64_t value);
  public:

  // optional uint64 target_manifestid = 4;
  bool has_target_manifestid() const;
  private:
  bool _internal_has_target_manifestid() const;
  public:
  void clear_target_manifestid();
  uint64_t target_manifestid() const;
  void set_target_manifestid(uint64_t value);
  private:
  uint64_t _internal_target_manifestid() const;
  void _internal_set_target_manifestid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetDepotPatchInfo_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  uint32_t depotid_;
  uint64_t source_manifestid_;
  uint64_t target_manifestid_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetDepotPatchInfo_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetDepotPatchInfo_Response) */ {
 public:
  inline CContentServerDirectory_GetDepotPatchInfo_Response() : CContentServerDirectory_GetDepotPatchInfo_Response(nullptr) {}
  ~CContentServerDirectory_GetDepotPatchInfo_Response() override;
  explicit constexpr CContentServerDirectory_GetDepotPatchInfo_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetDepotPatchInfo_Response(const CContentServerDirectory_GetDepotPatchInfo_Response& from);
  CContentServerDirectory_GetDepotPatchInfo_Response(CContentServerDirectory_GetDepotPatchInfo_Response&& from) noexcept
    : CContentServerDirectory_GetDepotPatchInfo_Response() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetDepotPatchInfo_Response& operator=(const CContentServerDirectory_GetDepotPatchInfo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetDepotPatchInfo_Response& operator=(CContentServerDirectory_GetDepotPatchInfo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetDepotPatchInfo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetDepotPatchInfo_Response* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetDepotPatchInfo_Response*>(
               &_CContentServerDirectory_GetDepotPatchInfo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CContentServerDirectory_GetDepotPatchInfo_Response& a, CContentServerDirectory_GetDepotPatchInfo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetDepotPatchInfo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetDepotPatchInfo_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetDepotPatchInfo_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetDepotPatchInfo_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetDepotPatchInfo_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetDepotPatchInfo_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetDepotPatchInfo_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetDepotPatchInfo_Response";
  }
  protected:
  explicit CContentServerDirectory_GetDepotPatchInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPatchSizeFieldNumber = 2,
    kPatchedChunksSizeFieldNumber = 3,
    kIsAvailableFieldNumber = 1,
  };
  // optional uint64 patch_size = 2;
  bool has_patch_size() const;
  private:
  bool _internal_has_patch_size() const;
  public:
  void clear_patch_size();
  uint64_t patch_size() const;
  void set_patch_size(uint64_t value);
  private:
  uint64_t _internal_patch_size() const;
  void _internal_set_patch_size(uint64_t value);
  public:

  // optional uint64 patched_chunks_size = 3;
  bool has_patched_chunks_size() const;
  private:
  bool _internal_has_patched_chunks_size() const;
  public:
  void clear_patched_chunks_size();
  uint64_t patched_chunks_size() const;
  void set_patched_chunks_size(uint64_t value);
  private:
  uint64_t _internal_patched_chunks_size() const;
  void _internal_set_patched_chunks_size(uint64_t value);
  public:

  // optional bool is_available = 1;
  bool has_is_available() const;
  private:
  bool _internal_has_is_available() const;
  public:
  void clear_is_available();
  bool is_available() const;
  void set_is_available(bool value);
  private:
  bool _internal_is_available() const;
  void _internal_set_is_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetDepotPatchInfo_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t patch_size_;
  uint64_t patched_chunks_size_;
  bool is_available_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetClientUpdateHosts_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetClientUpdateHosts_Request) */ {
 public:
  inline CContentServerDirectory_GetClientUpdateHosts_Request() : CContentServerDirectory_GetClientUpdateHosts_Request(nullptr) {}
  ~CContentServerDirectory_GetClientUpdateHosts_Request() override;
  explicit constexpr CContentServerDirectory_GetClientUpdateHosts_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetClientUpdateHosts_Request(const CContentServerDirectory_GetClientUpdateHosts_Request& from);
  CContentServerDirectory_GetClientUpdateHosts_Request(CContentServerDirectory_GetClientUpdateHosts_Request&& from) noexcept
    : CContentServerDirectory_GetClientUpdateHosts_Request() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetClientUpdateHosts_Request& operator=(const CContentServerDirectory_GetClientUpdateHosts_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetClientUpdateHosts_Request& operator=(CContentServerDirectory_GetClientUpdateHosts_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetClientUpdateHosts_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetClientUpdateHosts_Request* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetClientUpdateHosts_Request*>(
               &_CContentServerDirectory_GetClientUpdateHosts_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CContentServerDirectory_GetClientUpdateHosts_Request& a, CContentServerDirectory_GetClientUpdateHosts_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetClientUpdateHosts_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetClientUpdateHosts_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetClientUpdateHosts_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetClientUpdateHosts_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetClientUpdateHosts_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetClientUpdateHosts_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetClientUpdateHosts_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetClientUpdateHosts_Request";
  }
  protected:
  explicit CContentServerDirectory_GetClientUpdateHosts_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCachedSignatureFieldNumber = 1,
  };
  // optional string cached_signature = 1;
  bool has_cached_signature() const;
  private:
  bool _internal_has_cached_signature() const;
  public:
  void clear_cached_signature();
  const std::string& cached_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cached_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cached_signature();
  PROTOBUF_NODISCARD std::string* release_cached_signature();
  void set_allocated_cached_signature(std::string* cached_signature);
  private:
  const std::string& _internal_cached_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cached_signature(const std::string& value);
  std::string* _internal_mutable_cached_signature();
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetClientUpdateHosts_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cached_signature_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetClientUpdateHosts_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetClientUpdateHosts_Response) */ {
 public:
  inline CContentServerDirectory_GetClientUpdateHosts_Response() : CContentServerDirectory_GetClientUpdateHosts_Response(nullptr) {}
  ~CContentServerDirectory_GetClientUpdateHosts_Response() override;
  explicit constexpr CContentServerDirectory_GetClientUpdateHosts_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetClientUpdateHosts_Response(const CContentServerDirectory_GetClientUpdateHosts_Response& from);
  CContentServerDirectory_GetClientUpdateHosts_Response(CContentServerDirectory_GetClientUpdateHosts_Response&& from) noexcept
    : CContentServerDirectory_GetClientUpdateHosts_Response() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetClientUpdateHosts_Response& operator=(const CContentServerDirectory_GetClientUpdateHosts_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetClientUpdateHosts_Response& operator=(CContentServerDirectory_GetClientUpdateHosts_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetClientUpdateHosts_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetClientUpdateHosts_Response* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetClientUpdateHosts_Response*>(
               &_CContentServerDirectory_GetClientUpdateHosts_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CContentServerDirectory_GetClientUpdateHosts_Response& a, CContentServerDirectory_GetClientUpdateHosts_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetClientUpdateHosts_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetClientUpdateHosts_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetClientUpdateHosts_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetClientUpdateHosts_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetClientUpdateHosts_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetClientUpdateHosts_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetClientUpdateHosts_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetClientUpdateHosts_Response";
  }
  protected:
  explicit CContentServerDirectory_GetClientUpdateHosts_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostsKvFieldNumber = 1,
    kIpCountryFieldNumber = 3,
    kValidUntilTimeFieldNumber = 2,
  };
  // optional string hosts_kv = 1;
  bool has_hosts_kv() const;
  private:
  bool _internal_has_hosts_kv() const;
  public:
  void clear_hosts_kv();
  const std::string& hosts_kv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hosts_kv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hosts_kv();
  PROTOBUF_NODISCARD std::string* release_hosts_kv();
  void set_allocated_hosts_kv(std::string* hosts_kv);
  private:
  const std::string& _internal_hosts_kv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hosts_kv(const std::string& value);
  std::string* _internal_mutable_hosts_kv();
  public:

  // optional string ip_country = 3;
  bool has_ip_country() const;
  private:
  bool _internal_has_ip_country() const;
  public:
  void clear_ip_country();
  const std::string& ip_country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_country();
  PROTOBUF_NODISCARD std::string* release_ip_country();
  void set_allocated_ip_country(std::string* ip_country);
  private:
  const std::string& _internal_ip_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_country(const std::string& value);
  std::string* _internal_mutable_ip_country();
  public:

  // optional uint64 valid_until_time = 2;
  bool has_valid_until_time() const;
  private:
  bool _internal_has_valid_until_time() const;
  public:
  void clear_valid_until_time();
  uint64_t valid_until_time() const;
  void set_valid_until_time(uint64_t value);
  private:
  uint64_t _internal_valid_until_time() const;
  void _internal_set_valid_until_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetClientUpdateHosts_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hosts_kv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_country_;
  uint64_t valid_until_time_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetManifestRequestCode_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetManifestRequestCode_Request) */ {
 public:
  inline CContentServerDirectory_GetManifestRequestCode_Request() : CContentServerDirectory_GetManifestRequestCode_Request(nullptr) {}
  ~CContentServerDirectory_GetManifestRequestCode_Request() override;
  explicit constexpr CContentServerDirectory_GetManifestRequestCode_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetManifestRequestCode_Request(const CContentServerDirectory_GetManifestRequestCode_Request& from);
  CContentServerDirectory_GetManifestRequestCode_Request(CContentServerDirectory_GetManifestRequestCode_Request&& from) noexcept
    : CContentServerDirectory_GetManifestRequestCode_Request() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetManifestRequestCode_Request& operator=(const CContentServerDirectory_GetManifestRequestCode_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetManifestRequestCode_Request& operator=(CContentServerDirectory_GetManifestRequestCode_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetManifestRequestCode_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetManifestRequestCode_Request* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetManifestRequestCode_Request*>(
               &_CContentServerDirectory_GetManifestRequestCode_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CContentServerDirectory_GetManifestRequestCode_Request& a, CContentServerDirectory_GetManifestRequestCode_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetManifestRequestCode_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetManifestRequestCode_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetManifestRequestCode_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetManifestRequestCode_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetManifestRequestCode_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetManifestRequestCode_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetManifestRequestCode_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetManifestRequestCode_Request";
  }
  protected:
  explicit CContentServerDirectory_GetManifestRequestCode_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppBranchFieldNumber = 4,
    kBranchPasswordHashFieldNumber = 5,
    kAppIdFieldNumber = 1,
    kDepotIdFieldNumber = 2,
    kManifestIdFieldNumber = 3,
  };
  // optional string app_branch = 4;
  bool has_app_branch() const;
  private:
  bool _internal_has_app_branch() const;
  public:
  void clear_app_branch();
  const std::string& app_branch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_branch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_branch();
  PROTOBUF_NODISCARD std::string* release_app_branch();
  void set_allocated_app_branch(std::string* app_branch);
  private:
  const std::string& _internal_app_branch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_branch(const std::string& value);
  std::string* _internal_mutable_app_branch();
  public:

  // optional string branch_password_hash = 5;
  bool has_branch_password_hash() const;
  private:
  bool _internal_has_branch_password_hash() const;
  public:
  void clear_branch_password_hash();
  const std::string& branch_password_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_branch_password_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_branch_password_hash();
  PROTOBUF_NODISCARD std::string* release_branch_password_hash();
  void set_allocated_branch_password_hash(std::string* branch_password_hash);
  private:
  const std::string& _internal_branch_password_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_branch_password_hash(const std::string& value);
  std::string* _internal_mutable_branch_password_hash();
  public:

  // optional uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // optional uint32 depot_id = 2;
  bool has_depot_id() const;
  private:
  bool _internal_has_depot_id() const;
  public:
  void clear_depot_id();
  uint32_t depot_id() const;
  void set_depot_id(uint32_t value);
  private:
  uint32_t _internal_depot_id() const;
  void _internal_set_depot_id(uint32_t value);
  public:

  // optional uint64 manifest_id = 3;
  bool has_manifest_id() const;
  private:
  bool _internal_has_manifest_id() const;
  public:
  void clear_manifest_id();
  uint64_t manifest_id() const;
  void set_manifest_id(uint64_t value);
  private:
  uint64_t _internal_manifest_id() const;
  void _internal_set_manifest_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetManifestRequestCode_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_branch_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr branch_password_hash_;
  uint32_t app_id_;
  uint32_t depot_id_;
  uint64_t manifest_id_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetManifestRequestCode_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetManifestRequestCode_Response) */ {
 public:
  inline CContentServerDirectory_GetManifestRequestCode_Response() : CContentServerDirectory_GetManifestRequestCode_Response(nullptr) {}
  ~CContentServerDirectory_GetManifestRequestCode_Response() override;
  explicit constexpr CContentServerDirectory_GetManifestRequestCode_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetManifestRequestCode_Response(const CContentServerDirectory_GetManifestRequestCode_Response& from);
  CContentServerDirectory_GetManifestRequestCode_Response(CContentServerDirectory_GetManifestRequestCode_Response&& from) noexcept
    : CContentServerDirectory_GetManifestRequestCode_Response() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetManifestRequestCode_Response& operator=(const CContentServerDirectory_GetManifestRequestCode_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetManifestRequestCode_Response& operator=(CContentServerDirectory_GetManifestRequestCode_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetManifestRequestCode_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetManifestRequestCode_Response* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetManifestRequestCode_Response*>(
               &_CContentServerDirectory_GetManifestRequestCode_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CContentServerDirectory_GetManifestRequestCode_Response& a, CContentServerDirectory_GetManifestRequestCode_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetManifestRequestCode_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetManifestRequestCode_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetManifestRequestCode_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetManifestRequestCode_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetManifestRequestCode_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetManifestRequestCode_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetManifestRequestCode_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetManifestRequestCode_Response";
  }
  protected:
  explicit CContentServerDirectory_GetManifestRequestCode_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManifestRequestCodeFieldNumber = 1,
  };
  // optional uint64 manifest_request_code = 1;
  bool has_manifest_request_code() const;
  private:
  bool _internal_has_manifest_request_code() const;
  public:
  void clear_manifest_request_code();
  uint64_t manifest_request_code() const;
  void set_manifest_request_code(uint64_t value);
  private:
  uint64_t _internal_manifest_request_code() const;
  void _internal_set_manifest_request_code(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetManifestRequestCode_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t manifest_request_code_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetCDNAuthToken_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetCDNAuthToken_Request) */ {
 public:
  inline CContentServerDirectory_GetCDNAuthToken_Request() : CContentServerDirectory_GetCDNAuthToken_Request(nullptr) {}
  ~CContentServerDirectory_GetCDNAuthToken_Request() override;
  explicit constexpr CContentServerDirectory_GetCDNAuthToken_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetCDNAuthToken_Request(const CContentServerDirectory_GetCDNAuthToken_Request& from);
  CContentServerDirectory_GetCDNAuthToken_Request(CContentServerDirectory_GetCDNAuthToken_Request&& from) noexcept
    : CContentServerDirectory_GetCDNAuthToken_Request() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetCDNAuthToken_Request& operator=(const CContentServerDirectory_GetCDNAuthToken_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetCDNAuthToken_Request& operator=(CContentServerDirectory_GetCDNAuthToken_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetCDNAuthToken_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetCDNAuthToken_Request* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetCDNAuthToken_Request*>(
               &_CContentServerDirectory_GetCDNAuthToken_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CContentServerDirectory_GetCDNAuthToken_Request& a, CContentServerDirectory_GetCDNAuthToken_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetCDNAuthToken_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetCDNAuthToken_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetCDNAuthToken_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetCDNAuthToken_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetCDNAuthToken_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetCDNAuthToken_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetCDNAuthToken_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetCDNAuthToken_Request";
  }
  protected:
  explicit CContentServerDirectory_GetCDNAuthToken_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostNameFieldNumber = 2,
    kDepotIdFieldNumber = 1,
    kAppIdFieldNumber = 3,
  };
  // optional string host_name = 2;
  bool has_host_name() const;
  private:
  bool _internal_has_host_name() const;
  public:
  void clear_host_name();
  const std::string& host_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_name();
  PROTOBUF_NODISCARD std::string* release_host_name();
  void set_allocated_host_name(std::string* host_name);
  private:
  const std::string& _internal_host_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_name(const std::string& value);
  std::string* _internal_mutable_host_name();
  public:

  // optional uint32 depot_id = 1;
  bool has_depot_id() const;
  private:
  bool _internal_has_depot_id() const;
  public:
  void clear_depot_id();
  uint32_t depot_id() const;
  void set_depot_id(uint32_t value);
  private:
  uint32_t _internal_depot_id() const;
  void _internal_set_depot_id(uint32_t value);
  public:

  // optional uint32 app_id = 3;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetCDNAuthToken_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_name_;
  uint32_t depot_id_;
  uint32_t app_id_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetCDNAuthToken_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetCDNAuthToken_Response) */ {
 public:
  inline CContentServerDirectory_GetCDNAuthToken_Response() : CContentServerDirectory_GetCDNAuthToken_Response(nullptr) {}
  ~CContentServerDirectory_GetCDNAuthToken_Response() override;
  explicit constexpr CContentServerDirectory_GetCDNAuthToken_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetCDNAuthToken_Response(const CContentServerDirectory_GetCDNAuthToken_Response& from);
  CContentServerDirectory_GetCDNAuthToken_Response(CContentServerDirectory_GetCDNAuthToken_Response&& from) noexcept
    : CContentServerDirectory_GetCDNAuthToken_Response() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetCDNAuthToken_Response& operator=(const CContentServerDirectory_GetCDNAuthToken_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetCDNAuthToken_Response& operator=(CContentServerDirectory_GetCDNAuthToken_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetCDNAuthToken_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetCDNAuthToken_Response* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetCDNAuthToken_Response*>(
               &_CContentServerDirectory_GetCDNAuthToken_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CContentServerDirectory_GetCDNAuthToken_Response& a, CContentServerDirectory_GetCDNAuthToken_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetCDNAuthToken_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetCDNAuthToken_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetCDNAuthToken_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetCDNAuthToken_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetCDNAuthToken_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetCDNAuthToken_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetCDNAuthToken_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetCDNAuthToken_Response";
  }
  protected:
  explicit CContentServerDirectory_GetCDNAuthToken_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kExpirationTimeFieldNumber = 2,
  };
  // optional string token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional uint32 expiration_time = 2;
  bool has_expiration_time() const;
  private:
  bool _internal_has_expiration_time() const;
  public:
  void clear_expiration_time();
  uint32_t expiration_time() const;
  void set_expiration_time(uint32_t value);
  private:
  uint32_t _internal_expiration_time() const;
  void _internal_set_expiration_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetCDNAuthToken_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  uint32_t expiration_time_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_RequestPeerContentServer_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_RequestPeerContentServer_Request) */ {
 public:
  inline CContentServerDirectory_RequestPeerContentServer_Request() : CContentServerDirectory_RequestPeerContentServer_Request(nullptr) {}
  ~CContentServerDirectory_RequestPeerContentServer_Request() override;
  explicit constexpr CContentServerDirectory_RequestPeerContentServer_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_RequestPeerContentServer_Request(const CContentServerDirectory_RequestPeerContentServer_Request& from);
  CContentServerDirectory_RequestPeerContentServer_Request(CContentServerDirectory_RequestPeerContentServer_Request&& from) noexcept
    : CContentServerDirectory_RequestPeerContentServer_Request() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_RequestPeerContentServer_Request& operator=(const CContentServerDirectory_RequestPeerContentServer_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_RequestPeerContentServer_Request& operator=(CContentServerDirectory_RequestPeerContentServer_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_RequestPeerContentServer_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_RequestPeerContentServer_Request* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_RequestPeerContentServer_Request*>(
               &_CContentServerDirectory_RequestPeerContentServer_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CContentServerDirectory_RequestPeerContentServer_Request& a, CContentServerDirectory_RequestPeerContentServer_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_RequestPeerContentServer_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_RequestPeerContentServer_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_RequestPeerContentServer_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_RequestPeerContentServer_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_RequestPeerContentServer_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_RequestPeerContentServer_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_RequestPeerContentServer_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_RequestPeerContentServer_Request";
  }
  protected:
  explicit CContentServerDirectory_RequestPeerContentServer_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteClientIdFieldNumber = 1,
    kSteamidFieldNumber = 2,
    kServerRemoteClientIdFieldNumber = 3,
    kAppIdFieldNumber = 4,
    kCurrentBuildIdFieldNumber = 5,
  };
  // optional uint64 remote_client_id = 1;
  bool has_remote_client_id() const;
  private:
  bool _internal_has_remote_client_id() const;
  public:
  void clear_remote_client_id();
  uint64_t remote_client_id() const;
  void set_remote_client_id(uint64_t value);
  private:
  uint64_t _internal_remote_client_id() const;
  void _internal_set_remote_client_id(uint64_t value);
  public:

  // optional uint64 steamid = 2;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // optional uint64 server_remote_client_id = 3;
  bool has_server_remote_client_id() const;
  private:
  bool _internal_has_server_remote_client_id() const;
  public:
  void clear_server_remote_client_id();
  uint64_t server_remote_client_id() const;
  void set_server_remote_client_id(uint64_t value);
  private:
  uint64_t _internal_server_remote_client_id() const;
  void _internal_set_server_remote_client_id(uint64_t value);
  public:

  // optional uint32 app_id = 4;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // optional uint32 current_build_id = 5;
  bool has_current_build_id() const;
  private:
  bool _internal_has_current_build_id() const;
  public:
  void clear_current_build_id();
  uint32_t current_build_id() const;
  void set_current_build_id(uint32_t value);
  private:
  uint32_t _internal_current_build_id() const;
  void _internal_set_current_build_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_RequestPeerContentServer_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t remote_client_id_;
  uint64_t steamid_;
  uint64_t server_remote_client_id_;
  uint32_t app_id_;
  uint32_t current_build_id_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_RequestPeerContentServer_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_RequestPeerContentServer_Response) */ {
 public:
  inline CContentServerDirectory_RequestPeerContentServer_Response() : CContentServerDirectory_RequestPeerContentServer_Response(nullptr) {}
  ~CContentServerDirectory_RequestPeerContentServer_Response() override;
  explicit constexpr CContentServerDirectory_RequestPeerContentServer_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_RequestPeerContentServer_Response(const CContentServerDirectory_RequestPeerContentServer_Response& from);
  CContentServerDirectory_RequestPeerContentServer_Response(CContentServerDirectory_RequestPeerContentServer_Response&& from) noexcept
    : CContentServerDirectory_RequestPeerContentServer_Response() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_RequestPeerContentServer_Response& operator=(const CContentServerDirectory_RequestPeerContentServer_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_RequestPeerContentServer_Response& operator=(CContentServerDirectory_RequestPeerContentServer_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_RequestPeerContentServer_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_RequestPeerContentServer_Response* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_RequestPeerContentServer_Response*>(
               &_CContentServerDirectory_RequestPeerContentServer_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CContentServerDirectory_RequestPeerContentServer_Response& a, CContentServerDirectory_RequestPeerContentServer_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_RequestPeerContentServer_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_RequestPeerContentServer_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_RequestPeerContentServer_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_RequestPeerContentServer_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_RequestPeerContentServer_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_RequestPeerContentServer_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_RequestPeerContentServer_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_RequestPeerContentServer_Response";
  }
  protected:
  explicit CContentServerDirectory_RequestPeerContentServer_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstalledDepotsFieldNumber = 2,
    kServerPortFieldNumber = 1,
  };
  // repeated uint32 installed_depots = 2;
  int installed_depots_size() const;
  private:
  int _internal_installed_depots_size() const;
  public:
  void clear_installed_depots();
  private:
  uint32_t _internal_installed_depots(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_installed_depots() const;
  void _internal_add_installed_depots(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_installed_depots();
  public:
  uint32_t installed_depots(int index) const;
  void set_installed_depots(int index, uint32_t value);
  void add_installed_depots(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      installed_depots() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_installed_depots();

  // optional uint32 server_port = 1;
  bool has_server_port() const;
  private:
  bool _internal_has_server_port() const;
  public:
  void clear_server_port();
  uint32_t server_port() const;
  void set_server_port(uint32_t value);
  private:
  uint32_t _internal_server_port() const;
  void _internal_set_server_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_RequestPeerContentServer_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > installed_depots_;
  uint32_t server_port_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetPeerContentInfo_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetPeerContentInfo_Request) */ {
 public:
  inline CContentServerDirectory_GetPeerContentInfo_Request() : CContentServerDirectory_GetPeerContentInfo_Request(nullptr) {}
  ~CContentServerDirectory_GetPeerContentInfo_Request() override;
  explicit constexpr CContentServerDirectory_GetPeerContentInfo_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetPeerContentInfo_Request(const CContentServerDirectory_GetPeerContentInfo_Request& from);
  CContentServerDirectory_GetPeerContentInfo_Request(CContentServerDirectory_GetPeerContentInfo_Request&& from) noexcept
    : CContentServerDirectory_GetPeerContentInfo_Request() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetPeerContentInfo_Request& operator=(const CContentServerDirectory_GetPeerContentInfo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetPeerContentInfo_Request& operator=(CContentServerDirectory_GetPeerContentInfo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetPeerContentInfo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetPeerContentInfo_Request* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetPeerContentInfo_Request*>(
               &_CContentServerDirectory_GetPeerContentInfo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CContentServerDirectory_GetPeerContentInfo_Request& a, CContentServerDirectory_GetPeerContentInfo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetPeerContentInfo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetPeerContentInfo_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetPeerContentInfo_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetPeerContentInfo_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetPeerContentInfo_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetPeerContentInfo_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetPeerContentInfo_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetPeerContentInfo_Request";
  }
  protected:
  explicit CContentServerDirectory_GetPeerContentInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteClientIdFieldNumber = 1,
    kSteamidFieldNumber = 2,
    kServerRemoteClientIdFieldNumber = 3,
  };
  // optional uint64 remote_client_id = 1;
  bool has_remote_client_id() const;
  private:
  bool _internal_has_remote_client_id() const;
  public:
  void clear_remote_client_id();
  uint64_t remote_client_id() const;
  void set_remote_client_id(uint64_t value);
  private:
  uint64_t _internal_remote_client_id() const;
  void _internal_set_remote_client_id(uint64_t value);
  public:

  // optional uint64 steamid = 2;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // optional uint64 server_remote_client_id = 3;
  bool has_server_remote_client_id() const;
  private:
  bool _internal_has_server_remote_client_id() const;
  public:
  void clear_server_remote_client_id();
  uint64_t server_remote_client_id() const;
  void set_server_remote_client_id(uint64_t value);
  private:
  uint64_t _internal_server_remote_client_id() const;
  void _internal_set_server_remote_client_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetPeerContentInfo_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t remote_client_id_;
  uint64_t steamid_;
  uint64_t server_remote_client_id_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CContentServerDirectory_GetPeerContentInfo_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContentServerDirectory_GetPeerContentInfo_Response) */ {
 public:
  inline CContentServerDirectory_GetPeerContentInfo_Response() : CContentServerDirectory_GetPeerContentInfo_Response(nullptr) {}
  ~CContentServerDirectory_GetPeerContentInfo_Response() override;
  explicit constexpr CContentServerDirectory_GetPeerContentInfo_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContentServerDirectory_GetPeerContentInfo_Response(const CContentServerDirectory_GetPeerContentInfo_Response& from);
  CContentServerDirectory_GetPeerContentInfo_Response(CContentServerDirectory_GetPeerContentInfo_Response&& from) noexcept
    : CContentServerDirectory_GetPeerContentInfo_Response() {
    *this = ::std::move(from);
  }

  inline CContentServerDirectory_GetPeerContentInfo_Response& operator=(const CContentServerDirectory_GetPeerContentInfo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContentServerDirectory_GetPeerContentInfo_Response& operator=(CContentServerDirectory_GetPeerContentInfo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContentServerDirectory_GetPeerContentInfo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContentServerDirectory_GetPeerContentInfo_Response* internal_default_instance() {
    return reinterpret_cast<const CContentServerDirectory_GetPeerContentInfo_Response*>(
               &_CContentServerDirectory_GetPeerContentInfo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CContentServerDirectory_GetPeerContentInfo_Response& a, CContentServerDirectory_GetPeerContentInfo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CContentServerDirectory_GetPeerContentInfo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContentServerDirectory_GetPeerContentInfo_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContentServerDirectory_GetPeerContentInfo_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContentServerDirectory_GetPeerContentInfo_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContentServerDirectory_GetPeerContentInfo_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CContentServerDirectory_GetPeerContentInfo_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContentServerDirectory_GetPeerContentInfo_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContentServerDirectory_GetPeerContentInfo_Response";
  }
  protected:
  explicit CContentServerDirectory_GetPeerContentInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidsFieldNumber = 1,
    kIpPublicFieldNumber = 2,
  };
  // repeated uint32 appids = 1;
  int appids_size() const;
  private:
  int _internal_appids_size() const;
  public:
  void clear_appids();
  private:
  uint32_t _internal_appids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_appids() const;
  void _internal_add_appids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_appids();
  public:
  uint32_t appids(int index) const;
  void set_appids(int index, uint32_t value);
  void add_appids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      appids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_appids();

  // optional string ip_public = 2;
  bool has_ip_public() const;
  private:
  bool _internal_has_ip_public() const;
  public:
  void clear_ip_public();
  const std::string& ip_public() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_public(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_public();
  PROTOBUF_NODISCARD std::string* release_ip_public();
  void set_allocated_ip_public(std::string* ip_public);
  private:
  const std::string& _internal_ip_public() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_public(const std::string& value);
  std::string* _internal_mutable_ip_public();
  public:

  // @@protoc_insertion_point(class_scope:CContentServerDirectory_GetPeerContentInfo_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > appids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_public_;
  friend struct ::TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto;
};
// ===================================================================

class ContentServerDirectory_Stub;

class ContentServerDirectory : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline ContentServerDirectory() {};
 public:
  virtual ~ContentServerDirectory();

  typedef ContentServerDirectory_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void GetServersForSteamPipe(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetServersForSteamPipe_Request* request,
                       ::CContentServerDirectory_GetServersForSteamPipe_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetDepotPatchInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetDepotPatchInfo_Request* request,
                       ::CContentServerDirectory_GetDepotPatchInfo_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetClientUpdateHosts(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetClientUpdateHosts_Request* request,
                       ::CContentServerDirectory_GetClientUpdateHosts_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetManifestRequestCode(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetManifestRequestCode_Request* request,
                       ::CContentServerDirectory_GetManifestRequestCode_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetCDNAuthToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetCDNAuthToken_Request* request,
                       ::CContentServerDirectory_GetCDNAuthToken_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void RequestPeerContentServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_RequestPeerContentServer_Request* request,
                       ::CContentServerDirectory_RequestPeerContentServer_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetPeerContentInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetPeerContentInfo_Request* request,
                       ::CContentServerDirectory_GetPeerContentInfo_Response* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ContentServerDirectory);
};

class ContentServerDirectory_Stub : public ContentServerDirectory {
 public:
  ContentServerDirectory_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  ContentServerDirectory_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~ContentServerDirectory_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements ContentServerDirectory ------------------------------------------

  void GetServersForSteamPipe(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetServersForSteamPipe_Request* request,
                       ::CContentServerDirectory_GetServersForSteamPipe_Response* response,
                       ::google::protobuf::Closure* done);
  void GetDepotPatchInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetDepotPatchInfo_Request* request,
                       ::CContentServerDirectory_GetDepotPatchInfo_Response* response,
                       ::google::protobuf::Closure* done);
  void GetClientUpdateHosts(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetClientUpdateHosts_Request* request,
                       ::CContentServerDirectory_GetClientUpdateHosts_Response* response,
                       ::google::protobuf::Closure* done);
  void GetManifestRequestCode(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetManifestRequestCode_Request* request,
                       ::CContentServerDirectory_GetManifestRequestCode_Response* response,
                       ::google::protobuf::Closure* done);
  void GetCDNAuthToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetCDNAuthToken_Request* request,
                       ::CContentServerDirectory_GetCDNAuthToken_Response* response,
                       ::google::protobuf::Closure* done);
  void RequestPeerContentServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_RequestPeerContentServer_Request* request,
                       ::CContentServerDirectory_RequestPeerContentServer_Response* response,
                       ::google::protobuf::Closure* done);
  void GetPeerContentInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CContentServerDirectory_GetPeerContentInfo_Request* request,
                       ::CContentServerDirectory_GetPeerContentInfo_Response* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ContentServerDirectory_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CContentServerDirectory_GetServersForSteamPipe_Request

// optional uint32 cell_id = 1 [(.description) = "client Cell ID"];
inline bool CContentServerDirectory_GetServersForSteamPipe_Request::_internal_has_cell_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetServersForSteamPipe_Request::has_cell_id() const {
  return _internal_has_cell_id();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::clear_cell_id() {
  cell_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CContentServerDirectory_GetServersForSteamPipe_Request::_internal_cell_id() const {
  return cell_id_;
}
inline uint32_t CContentServerDirectory_GetServersForSteamPipe_Request::cell_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetServersForSteamPipe_Request.cell_id)
  return _internal_cell_id();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::_internal_set_cell_id(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  cell_id_ = value;
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::set_cell_id(uint32_t value) {
  _internal_set_cell_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetServersForSteamPipe_Request.cell_id)
}

// optional uint32 max_servers = 2 [default = 20, (.description) = "max servers in response list"];
inline bool CContentServerDirectory_GetServersForSteamPipe_Request::_internal_has_max_servers() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetServersForSteamPipe_Request::has_max_servers() const {
  return _internal_has_max_servers();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::clear_max_servers() {
  max_servers_ = 20u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CContentServerDirectory_GetServersForSteamPipe_Request::_internal_max_servers() const {
  return max_servers_;
}
inline uint32_t CContentServerDirectory_GetServersForSteamPipe_Request::max_servers() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetServersForSteamPipe_Request.max_servers)
  return _internal_max_servers();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::_internal_set_max_servers(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  max_servers_ = value;
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::set_max_servers(uint32_t value) {
  _internal_set_max_servers(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetServersForSteamPipe_Request.max_servers)
}

// optional string ip_override = 3 [(.description) = "client IP address"];
inline bool CContentServerDirectory_GetServersForSteamPipe_Request::_internal_has_ip_override() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetServersForSteamPipe_Request::has_ip_override() const {
  return _internal_has_ip_override();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::clear_ip_override() {
  ip_override_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CContentServerDirectory_GetServersForSteamPipe_Request::ip_override() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetServersForSteamPipe_Request.ip_override)
  return _internal_ip_override();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_GetServersForSteamPipe_Request::set_ip_override(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ip_override_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetServersForSteamPipe_Request.ip_override)
}
inline std::string* CContentServerDirectory_GetServersForSteamPipe_Request::mutable_ip_override() {
  std::string* _s = _internal_mutable_ip_override();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetServersForSteamPipe_Request.ip_override)
  return _s;
}
inline const std::string& CContentServerDirectory_GetServersForSteamPipe_Request::_internal_ip_override() const {
  return ip_override_.Get();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::_internal_set_ip_override(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_override_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetServersForSteamPipe_Request::_internal_mutable_ip_override() {
  _has_bits_[0] |= 0x00000001u;
  return ip_override_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetServersForSteamPipe_Request::release_ip_override() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_GetServersForSteamPipe_Request.ip_override)
  if (!_internal_has_ip_override()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ip_override_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_override_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_override_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::set_allocated_ip_override(std::string* ip_override) {
  if (ip_override != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_override_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_override,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_override_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_override_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_GetServersForSteamPipe_Request.ip_override)
}

// optional int32 launcher_type = 4 [default = 0, (.description) = "launcher type"];
inline bool CContentServerDirectory_GetServersForSteamPipe_Request::_internal_has_launcher_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetServersForSteamPipe_Request::has_launcher_type() const {
  return _internal_has_launcher_type();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::clear_launcher_type() {
  launcher_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CContentServerDirectory_GetServersForSteamPipe_Request::_internal_launcher_type() const {
  return launcher_type_;
}
inline int32_t CContentServerDirectory_GetServersForSteamPipe_Request::launcher_type() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetServersForSteamPipe_Request.launcher_type)
  return _internal_launcher_type();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::_internal_set_launcher_type(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  launcher_type_ = value;
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::set_launcher_type(int32_t value) {
  _internal_set_launcher_type(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetServersForSteamPipe_Request.launcher_type)
}

// optional string ipv6_public = 5 [(.description) = "client public ipv6 address if it knows it"];
inline bool CContentServerDirectory_GetServersForSteamPipe_Request::_internal_has_ipv6_public() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetServersForSteamPipe_Request::has_ipv6_public() const {
  return _internal_has_ipv6_public();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::clear_ipv6_public() {
  ipv6_public_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CContentServerDirectory_GetServersForSteamPipe_Request::ipv6_public() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetServersForSteamPipe_Request.ipv6_public)
  return _internal_ipv6_public();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_GetServersForSteamPipe_Request::set_ipv6_public(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ipv6_public_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetServersForSteamPipe_Request.ipv6_public)
}
inline std::string* CContentServerDirectory_GetServersForSteamPipe_Request::mutable_ipv6_public() {
  std::string* _s = _internal_mutable_ipv6_public();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetServersForSteamPipe_Request.ipv6_public)
  return _s;
}
inline const std::string& CContentServerDirectory_GetServersForSteamPipe_Request::_internal_ipv6_public() const {
  return ipv6_public_.Get();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::_internal_set_ipv6_public(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ipv6_public_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetServersForSteamPipe_Request::_internal_mutable_ipv6_public() {
  _has_bits_[0] |= 0x00000002u;
  return ipv6_public_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetServersForSteamPipe_Request::release_ipv6_public() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_GetServersForSteamPipe_Request.ipv6_public)
  if (!_internal_has_ipv6_public()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ipv6_public_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ipv6_public_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ipv6_public_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_GetServersForSteamPipe_Request::set_allocated_ipv6_public(std::string* ipv6_public) {
  if (ipv6_public != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ipv6_public_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipv6_public,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ipv6_public_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ipv6_public_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_GetServersForSteamPipe_Request.ipv6_public)
}

// -------------------------------------------------------------------

// CContentServerDirectory_ServerInfo

// optional string type = 1;
inline bool CContentServerDirectory_ServerInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_type() const {
  return _internal_has_type();
}
inline void CContentServerDirectory_ServerInfo::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CContentServerDirectory_ServerInfo::type() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_ServerInfo::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.type)
}
inline std::string* CContentServerDirectory_ServerInfo::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_ServerInfo.type)
  return _s;
}
inline const std::string& CContentServerDirectory_ServerInfo::_internal_type() const {
  return type_.Get();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_ServerInfo::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_ServerInfo::release_type() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_ServerInfo.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_ServerInfo::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_ServerInfo.type)
}

// optional int32 source_id = 2;
inline bool CContentServerDirectory_ServerInfo::_internal_has_source_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_source_id() const {
  return _internal_has_source_id();
}
inline void CContentServerDirectory_ServerInfo::clear_source_id() {
  source_id_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t CContentServerDirectory_ServerInfo::_internal_source_id() const {
  return source_id_;
}
inline int32_t CContentServerDirectory_ServerInfo::source_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.source_id)
  return _internal_source_id();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_source_id(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  source_id_ = value;
}
inline void CContentServerDirectory_ServerInfo::set_source_id(int32_t value) {
  _internal_set_source_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.source_id)
}

// optional int32 cell_id = 3;
inline bool CContentServerDirectory_ServerInfo::_internal_has_cell_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_cell_id() const {
  return _internal_has_cell_id();
}
inline void CContentServerDirectory_ServerInfo::clear_cell_id() {
  cell_id_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t CContentServerDirectory_ServerInfo::_internal_cell_id() const {
  return cell_id_;
}
inline int32_t CContentServerDirectory_ServerInfo::cell_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.cell_id)
  return _internal_cell_id();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_cell_id(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  cell_id_ = value;
}
inline void CContentServerDirectory_ServerInfo::set_cell_id(int32_t value) {
  _internal_set_cell_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.cell_id)
}

// optional int32 load = 4;
inline bool CContentServerDirectory_ServerInfo::_internal_has_load() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_load() const {
  return _internal_has_load();
}
inline void CContentServerDirectory_ServerInfo::clear_load() {
  load_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t CContentServerDirectory_ServerInfo::_internal_load() const {
  return load_;
}
inline int32_t CContentServerDirectory_ServerInfo::load() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.load)
  return _internal_load();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_load(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  load_ = value;
}
inline void CContentServerDirectory_ServerInfo::set_load(int32_t value) {
  _internal_set_load(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.load)
}

// optional float weighted_load = 5;
inline bool CContentServerDirectory_ServerInfo::_internal_has_weighted_load() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_weighted_load() const {
  return _internal_has_weighted_load();
}
inline void CContentServerDirectory_ServerInfo::clear_weighted_load() {
  weighted_load_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float CContentServerDirectory_ServerInfo::_internal_weighted_load() const {
  return weighted_load_;
}
inline float CContentServerDirectory_ServerInfo::weighted_load() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.weighted_load)
  return _internal_weighted_load();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_weighted_load(float value) {
  _has_bits_[0] |= 0x00000100u;
  weighted_load_ = value;
}
inline void CContentServerDirectory_ServerInfo::set_weighted_load(float value) {
  _internal_set_weighted_load(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.weighted_load)
}

// optional int32 num_entries_in_client_list = 6;
inline bool CContentServerDirectory_ServerInfo::_internal_has_num_entries_in_client_list() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_num_entries_in_client_list() const {
  return _internal_has_num_entries_in_client_list();
}
inline void CContentServerDirectory_ServerInfo::clear_num_entries_in_client_list() {
  num_entries_in_client_list_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t CContentServerDirectory_ServerInfo::_internal_num_entries_in_client_list() const {
  return num_entries_in_client_list_;
}
inline int32_t CContentServerDirectory_ServerInfo::num_entries_in_client_list() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.num_entries_in_client_list)
  return _internal_num_entries_in_client_list();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_num_entries_in_client_list(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  num_entries_in_client_list_ = value;
}
inline void CContentServerDirectory_ServerInfo::set_num_entries_in_client_list(int32_t value) {
  _internal_set_num_entries_in_client_list(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.num_entries_in_client_list)
}

// optional bool steam_china_only = 7;
inline bool CContentServerDirectory_ServerInfo::_internal_has_steam_china_only() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_steam_china_only() const {
  return _internal_has_steam_china_only();
}
inline void CContentServerDirectory_ServerInfo::clear_steam_china_only() {
  steam_china_only_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CContentServerDirectory_ServerInfo::_internal_steam_china_only() const {
  return steam_china_only_;
}
inline bool CContentServerDirectory_ServerInfo::steam_china_only() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.steam_china_only)
  return _internal_steam_china_only();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_steam_china_only(bool value) {
  _has_bits_[0] |= 0x00000400u;
  steam_china_only_ = value;
}
inline void CContentServerDirectory_ServerInfo::set_steam_china_only(bool value) {
  _internal_set_steam_china_only(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.steam_china_only)
}

// optional string host = 8;
inline bool CContentServerDirectory_ServerInfo::_internal_has_host() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_host() const {
  return _internal_has_host();
}
inline void CContentServerDirectory_ServerInfo::clear_host() {
  host_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CContentServerDirectory_ServerInfo::host() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_ServerInfo::set_host(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.host)
}
inline std::string* CContentServerDirectory_ServerInfo::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_ServerInfo.host)
  return _s;
}
inline const std::string& CContentServerDirectory_ServerInfo::_internal_host() const {
  return host_.Get();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_host(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_ServerInfo::_internal_mutable_host() {
  _has_bits_[0] |= 0x00000002u;
  return host_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_ServerInfo::release_host() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_ServerInfo.host)
  if (!_internal_has_host()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = host_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_ServerInfo::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_ServerInfo.host)
}

// optional string vhost = 9;
inline bool CContentServerDirectory_ServerInfo::_internal_has_vhost() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_vhost() const {
  return _internal_has_vhost();
}
inline void CContentServerDirectory_ServerInfo::clear_vhost() {
  vhost_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CContentServerDirectory_ServerInfo::vhost() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.vhost)
  return _internal_vhost();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_ServerInfo::set_vhost(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 vhost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.vhost)
}
inline std::string* CContentServerDirectory_ServerInfo::mutable_vhost() {
  std::string* _s = _internal_mutable_vhost();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_ServerInfo.vhost)
  return _s;
}
inline const std::string& CContentServerDirectory_ServerInfo::_internal_vhost() const {
  return vhost_.Get();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_vhost(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  vhost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_ServerInfo::_internal_mutable_vhost() {
  _has_bits_[0] |= 0x00000004u;
  return vhost_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_ServerInfo::release_vhost() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_ServerInfo.vhost)
  if (!_internal_has_vhost()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = vhost_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vhost_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vhost_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_ServerInfo::set_allocated_vhost(std::string* vhost) {
  if (vhost != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  vhost_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vhost,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vhost_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vhost_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_ServerInfo.vhost)
}

// optional bool use_as_proxy = 10;
inline bool CContentServerDirectory_ServerInfo::_internal_has_use_as_proxy() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_use_as_proxy() const {
  return _internal_has_use_as_proxy();
}
inline void CContentServerDirectory_ServerInfo::clear_use_as_proxy() {
  use_as_proxy_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool CContentServerDirectory_ServerInfo::_internal_use_as_proxy() const {
  return use_as_proxy_;
}
inline bool CContentServerDirectory_ServerInfo::use_as_proxy() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.use_as_proxy)
  return _internal_use_as_proxy();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_use_as_proxy(bool value) {
  _has_bits_[0] |= 0x00000800u;
  use_as_proxy_ = value;
}
inline void CContentServerDirectory_ServerInfo::set_use_as_proxy(bool value) {
  _internal_set_use_as_proxy(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.use_as_proxy)
}

// optional string proxy_request_path_template = 11;
inline bool CContentServerDirectory_ServerInfo::_internal_has_proxy_request_path_template() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_proxy_request_path_template() const {
  return _internal_has_proxy_request_path_template();
}
inline void CContentServerDirectory_ServerInfo::clear_proxy_request_path_template() {
  proxy_request_path_template_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CContentServerDirectory_ServerInfo::proxy_request_path_template() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.proxy_request_path_template)
  return _internal_proxy_request_path_template();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_ServerInfo::set_proxy_request_path_template(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 proxy_request_path_template_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.proxy_request_path_template)
}
inline std::string* CContentServerDirectory_ServerInfo::mutable_proxy_request_path_template() {
  std::string* _s = _internal_mutable_proxy_request_path_template();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_ServerInfo.proxy_request_path_template)
  return _s;
}
inline const std::string& CContentServerDirectory_ServerInfo::_internal_proxy_request_path_template() const {
  return proxy_request_path_template_.Get();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_proxy_request_path_template(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  proxy_request_path_template_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_ServerInfo::_internal_mutable_proxy_request_path_template() {
  _has_bits_[0] |= 0x00000008u;
  return proxy_request_path_template_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_ServerInfo::release_proxy_request_path_template() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_ServerInfo.proxy_request_path_template)
  if (!_internal_has_proxy_request_path_template()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = proxy_request_path_template_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (proxy_request_path_template_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    proxy_request_path_template_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_ServerInfo::set_allocated_proxy_request_path_template(std::string* proxy_request_path_template) {
  if (proxy_request_path_template != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  proxy_request_path_template_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proxy_request_path_template,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (proxy_request_path_template_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    proxy_request_path_template_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_ServerInfo.proxy_request_path_template)
}

// optional string https_support = 12;
inline bool CContentServerDirectory_ServerInfo::_internal_has_https_support() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_https_support() const {
  return _internal_has_https_support();
}
inline void CContentServerDirectory_ServerInfo::clear_https_support() {
  https_support_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CContentServerDirectory_ServerInfo::https_support() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.https_support)
  return _internal_https_support();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_ServerInfo::set_https_support(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 https_support_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.https_support)
}
inline std::string* CContentServerDirectory_ServerInfo::mutable_https_support() {
  std::string* _s = _internal_mutable_https_support();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_ServerInfo.https_support)
  return _s;
}
inline const std::string& CContentServerDirectory_ServerInfo::_internal_https_support() const {
  return https_support_.Get();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_https_support(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  https_support_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_ServerInfo::_internal_mutable_https_support() {
  _has_bits_[0] |= 0x00000010u;
  return https_support_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_ServerInfo::release_https_support() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_ServerInfo.https_support)
  if (!_internal_has_https_support()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = https_support_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (https_support_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    https_support_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_ServerInfo::set_allocated_https_support(std::string* https_support) {
  if (https_support != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  https_support_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), https_support,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (https_support_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    https_support_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_ServerInfo.https_support)
}

// repeated uint32 allowed_app_ids = 13;
inline int CContentServerDirectory_ServerInfo::_internal_allowed_app_ids_size() const {
  return allowed_app_ids_.size();
}
inline int CContentServerDirectory_ServerInfo::allowed_app_ids_size() const {
  return _internal_allowed_app_ids_size();
}
inline void CContentServerDirectory_ServerInfo::clear_allowed_app_ids() {
  allowed_app_ids_.Clear();
}
inline uint32_t CContentServerDirectory_ServerInfo::_internal_allowed_app_ids(int index) const {
  return allowed_app_ids_.Get(index);
}
inline uint32_t CContentServerDirectory_ServerInfo::allowed_app_ids(int index) const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.allowed_app_ids)
  return _internal_allowed_app_ids(index);
}
inline void CContentServerDirectory_ServerInfo::set_allowed_app_ids(int index, uint32_t value) {
  allowed_app_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.allowed_app_ids)
}
inline void CContentServerDirectory_ServerInfo::_internal_add_allowed_app_ids(uint32_t value) {
  allowed_app_ids_.Add(value);
}
inline void CContentServerDirectory_ServerInfo::add_allowed_app_ids(uint32_t value) {
  _internal_add_allowed_app_ids(value);
  // @@protoc_insertion_point(field_add:CContentServerDirectory_ServerInfo.allowed_app_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CContentServerDirectory_ServerInfo::_internal_allowed_app_ids() const {
  return allowed_app_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CContentServerDirectory_ServerInfo::allowed_app_ids() const {
  // @@protoc_insertion_point(field_list:CContentServerDirectory_ServerInfo.allowed_app_ids)
  return _internal_allowed_app_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CContentServerDirectory_ServerInfo::_internal_mutable_allowed_app_ids() {
  return &allowed_app_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CContentServerDirectory_ServerInfo::mutable_allowed_app_ids() {
  // @@protoc_insertion_point(field_mutable_list:CContentServerDirectory_ServerInfo.allowed_app_ids)
  return _internal_mutable_allowed_app_ids();
}

// optional bool preferred_server = 14;
inline bool CContentServerDirectory_ServerInfo::_internal_has_preferred_server() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CContentServerDirectory_ServerInfo::has_preferred_server() const {
  return _internal_has_preferred_server();
}
inline void CContentServerDirectory_ServerInfo::clear_preferred_server() {
  preferred_server_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool CContentServerDirectory_ServerInfo::_internal_preferred_server() const {
  return preferred_server_;
}
inline bool CContentServerDirectory_ServerInfo::preferred_server() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_ServerInfo.preferred_server)
  return _internal_preferred_server();
}
inline void CContentServerDirectory_ServerInfo::_internal_set_preferred_server(bool value) {
  _has_bits_[0] |= 0x00001000u;
  preferred_server_ = value;
}
inline void CContentServerDirectory_ServerInfo::set_preferred_server(bool value) {
  _internal_set_preferred_server(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_ServerInfo.preferred_server)
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetServersForSteamPipe_Response

// repeated .CContentServerDirectory_ServerInfo servers = 1;
inline int CContentServerDirectory_GetServersForSteamPipe_Response::_internal_servers_size() const {
  return servers_.size();
}
inline int CContentServerDirectory_GetServersForSteamPipe_Response::servers_size() const {
  return _internal_servers_size();
}
inline void CContentServerDirectory_GetServersForSteamPipe_Response::clear_servers() {
  servers_.Clear();
}
inline ::CContentServerDirectory_ServerInfo* CContentServerDirectory_GetServersForSteamPipe_Response::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetServersForSteamPipe_Response.servers)
  return servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CContentServerDirectory_ServerInfo >*
CContentServerDirectory_GetServersForSteamPipe_Response::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:CContentServerDirectory_GetServersForSteamPipe_Response.servers)
  return &servers_;
}
inline const ::CContentServerDirectory_ServerInfo& CContentServerDirectory_GetServersForSteamPipe_Response::_internal_servers(int index) const {
  return servers_.Get(index);
}
inline const ::CContentServerDirectory_ServerInfo& CContentServerDirectory_GetServersForSteamPipe_Response::servers(int index) const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetServersForSteamPipe_Response.servers)
  return _internal_servers(index);
}
inline ::CContentServerDirectory_ServerInfo* CContentServerDirectory_GetServersForSteamPipe_Response::_internal_add_servers() {
  return servers_.Add();
}
inline ::CContentServerDirectory_ServerInfo* CContentServerDirectory_GetServersForSteamPipe_Response::add_servers() {
  ::CContentServerDirectory_ServerInfo* _add = _internal_add_servers();
  // @@protoc_insertion_point(field_add:CContentServerDirectory_GetServersForSteamPipe_Response.servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CContentServerDirectory_ServerInfo >&
CContentServerDirectory_GetServersForSteamPipe_Response::servers() const {
  // @@protoc_insertion_point(field_list:CContentServerDirectory_GetServersForSteamPipe_Response.servers)
  return servers_;
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetDepotPatchInfo_Request

// optional uint32 appid = 1;
inline bool CContentServerDirectory_GetDepotPatchInfo_Request::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetDepotPatchInfo_Request::has_appid() const {
  return _internal_has_appid();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CContentServerDirectory_GetDepotPatchInfo_Request::_internal_appid() const {
  return appid_;
}
inline uint32_t CContentServerDirectory_GetDepotPatchInfo_Request::appid() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetDepotPatchInfo_Request.appid)
  return _internal_appid();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetDepotPatchInfo_Request.appid)
}

// optional uint32 depotid = 2;
inline bool CContentServerDirectory_GetDepotPatchInfo_Request::_internal_has_depotid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetDepotPatchInfo_Request::has_depotid() const {
  return _internal_has_depotid();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::clear_depotid() {
  depotid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CContentServerDirectory_GetDepotPatchInfo_Request::_internal_depotid() const {
  return depotid_;
}
inline uint32_t CContentServerDirectory_GetDepotPatchInfo_Request::depotid() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetDepotPatchInfo_Request.depotid)
  return _internal_depotid();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::_internal_set_depotid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  depotid_ = value;
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::set_depotid(uint32_t value) {
  _internal_set_depotid(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetDepotPatchInfo_Request.depotid)
}

// optional uint64 source_manifestid = 3;
inline bool CContentServerDirectory_GetDepotPatchInfo_Request::_internal_has_source_manifestid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetDepotPatchInfo_Request::has_source_manifestid() const {
  return _internal_has_source_manifestid();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::clear_source_manifestid() {
  source_manifestid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CContentServerDirectory_GetDepotPatchInfo_Request::_internal_source_manifestid() const {
  return source_manifestid_;
}
inline uint64_t CContentServerDirectory_GetDepotPatchInfo_Request::source_manifestid() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetDepotPatchInfo_Request.source_manifestid)
  return _internal_source_manifestid();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::_internal_set_source_manifestid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  source_manifestid_ = value;
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::set_source_manifestid(uint64_t value) {
  _internal_set_source_manifestid(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetDepotPatchInfo_Request.source_manifestid)
}

// optional uint64 target_manifestid = 4;
inline bool CContentServerDirectory_GetDepotPatchInfo_Request::_internal_has_target_manifestid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetDepotPatchInfo_Request::has_target_manifestid() const {
  return _internal_has_target_manifestid();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::clear_target_manifestid() {
  target_manifestid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CContentServerDirectory_GetDepotPatchInfo_Request::_internal_target_manifestid() const {
  return target_manifestid_;
}
inline uint64_t CContentServerDirectory_GetDepotPatchInfo_Request::target_manifestid() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetDepotPatchInfo_Request.target_manifestid)
  return _internal_target_manifestid();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::_internal_set_target_manifestid(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  target_manifestid_ = value;
}
inline void CContentServerDirectory_GetDepotPatchInfo_Request::set_target_manifestid(uint64_t value) {
  _internal_set_target_manifestid(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetDepotPatchInfo_Request.target_manifestid)
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetDepotPatchInfo_Response

// optional bool is_available = 1;
inline bool CContentServerDirectory_GetDepotPatchInfo_Response::_internal_has_is_available() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetDepotPatchInfo_Response::has_is_available() const {
  return _internal_has_is_available();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Response::clear_is_available() {
  is_available_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CContentServerDirectory_GetDepotPatchInfo_Response::_internal_is_available() const {
  return is_available_;
}
inline bool CContentServerDirectory_GetDepotPatchInfo_Response::is_available() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetDepotPatchInfo_Response.is_available)
  return _internal_is_available();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Response::_internal_set_is_available(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_available_ = value;
}
inline void CContentServerDirectory_GetDepotPatchInfo_Response::set_is_available(bool value) {
  _internal_set_is_available(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetDepotPatchInfo_Response.is_available)
}

// optional uint64 patch_size = 2;
inline bool CContentServerDirectory_GetDepotPatchInfo_Response::_internal_has_patch_size() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetDepotPatchInfo_Response::has_patch_size() const {
  return _internal_has_patch_size();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Response::clear_patch_size() {
  patch_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CContentServerDirectory_GetDepotPatchInfo_Response::_internal_patch_size() const {
  return patch_size_;
}
inline uint64_t CContentServerDirectory_GetDepotPatchInfo_Response::patch_size() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetDepotPatchInfo_Response.patch_size)
  return _internal_patch_size();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Response::_internal_set_patch_size(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  patch_size_ = value;
}
inline void CContentServerDirectory_GetDepotPatchInfo_Response::set_patch_size(uint64_t value) {
  _internal_set_patch_size(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetDepotPatchInfo_Response.patch_size)
}

// optional uint64 patched_chunks_size = 3;
inline bool CContentServerDirectory_GetDepotPatchInfo_Response::_internal_has_patched_chunks_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetDepotPatchInfo_Response::has_patched_chunks_size() const {
  return _internal_has_patched_chunks_size();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Response::clear_patched_chunks_size() {
  patched_chunks_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CContentServerDirectory_GetDepotPatchInfo_Response::_internal_patched_chunks_size() const {
  return patched_chunks_size_;
}
inline uint64_t CContentServerDirectory_GetDepotPatchInfo_Response::patched_chunks_size() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetDepotPatchInfo_Response.patched_chunks_size)
  return _internal_patched_chunks_size();
}
inline void CContentServerDirectory_GetDepotPatchInfo_Response::_internal_set_patched_chunks_size(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  patched_chunks_size_ = value;
}
inline void CContentServerDirectory_GetDepotPatchInfo_Response::set_patched_chunks_size(uint64_t value) {
  _internal_set_patched_chunks_size(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetDepotPatchInfo_Response.patched_chunks_size)
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetClientUpdateHosts_Request

// optional string cached_signature = 1;
inline bool CContentServerDirectory_GetClientUpdateHosts_Request::_internal_has_cached_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetClientUpdateHosts_Request::has_cached_signature() const {
  return _internal_has_cached_signature();
}
inline void CContentServerDirectory_GetClientUpdateHosts_Request::clear_cached_signature() {
  cached_signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CContentServerDirectory_GetClientUpdateHosts_Request::cached_signature() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetClientUpdateHosts_Request.cached_signature)
  return _internal_cached_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_GetClientUpdateHosts_Request::set_cached_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cached_signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetClientUpdateHosts_Request.cached_signature)
}
inline std::string* CContentServerDirectory_GetClientUpdateHosts_Request::mutable_cached_signature() {
  std::string* _s = _internal_mutable_cached_signature();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetClientUpdateHosts_Request.cached_signature)
  return _s;
}
inline const std::string& CContentServerDirectory_GetClientUpdateHosts_Request::_internal_cached_signature() const {
  return cached_signature_.Get();
}
inline void CContentServerDirectory_GetClientUpdateHosts_Request::_internal_set_cached_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cached_signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetClientUpdateHosts_Request::_internal_mutable_cached_signature() {
  _has_bits_[0] |= 0x00000001u;
  return cached_signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetClientUpdateHosts_Request::release_cached_signature() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_GetClientUpdateHosts_Request.cached_signature)
  if (!_internal_has_cached_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = cached_signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cached_signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cached_signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_GetClientUpdateHosts_Request::set_allocated_cached_signature(std::string* cached_signature) {
  if (cached_signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cached_signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cached_signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cached_signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cached_signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_GetClientUpdateHosts_Request.cached_signature)
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetClientUpdateHosts_Response

// optional string hosts_kv = 1;
inline bool CContentServerDirectory_GetClientUpdateHosts_Response::_internal_has_hosts_kv() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetClientUpdateHosts_Response::has_hosts_kv() const {
  return _internal_has_hosts_kv();
}
inline void CContentServerDirectory_GetClientUpdateHosts_Response::clear_hosts_kv() {
  hosts_kv_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CContentServerDirectory_GetClientUpdateHosts_Response::hosts_kv() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetClientUpdateHosts_Response.hosts_kv)
  return _internal_hosts_kv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_GetClientUpdateHosts_Response::set_hosts_kv(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hosts_kv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetClientUpdateHosts_Response.hosts_kv)
}
inline std::string* CContentServerDirectory_GetClientUpdateHosts_Response::mutable_hosts_kv() {
  std::string* _s = _internal_mutable_hosts_kv();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetClientUpdateHosts_Response.hosts_kv)
  return _s;
}
inline const std::string& CContentServerDirectory_GetClientUpdateHosts_Response::_internal_hosts_kv() const {
  return hosts_kv_.Get();
}
inline void CContentServerDirectory_GetClientUpdateHosts_Response::_internal_set_hosts_kv(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hosts_kv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetClientUpdateHosts_Response::_internal_mutable_hosts_kv() {
  _has_bits_[0] |= 0x00000001u;
  return hosts_kv_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetClientUpdateHosts_Response::release_hosts_kv() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_GetClientUpdateHosts_Response.hosts_kv)
  if (!_internal_has_hosts_kv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = hosts_kv_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hosts_kv_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hosts_kv_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_GetClientUpdateHosts_Response::set_allocated_hosts_kv(std::string* hosts_kv) {
  if (hosts_kv != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hosts_kv_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hosts_kv,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hosts_kv_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hosts_kv_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_GetClientUpdateHosts_Response.hosts_kv)
}

// optional uint64 valid_until_time = 2;
inline bool CContentServerDirectory_GetClientUpdateHosts_Response::_internal_has_valid_until_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetClientUpdateHosts_Response::has_valid_until_time() const {
  return _internal_has_valid_until_time();
}
inline void CContentServerDirectory_GetClientUpdateHosts_Response::clear_valid_until_time() {
  valid_until_time_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CContentServerDirectory_GetClientUpdateHosts_Response::_internal_valid_until_time() const {
  return valid_until_time_;
}
inline uint64_t CContentServerDirectory_GetClientUpdateHosts_Response::valid_until_time() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetClientUpdateHosts_Response.valid_until_time)
  return _internal_valid_until_time();
}
inline void CContentServerDirectory_GetClientUpdateHosts_Response::_internal_set_valid_until_time(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  valid_until_time_ = value;
}
inline void CContentServerDirectory_GetClientUpdateHosts_Response::set_valid_until_time(uint64_t value) {
  _internal_set_valid_until_time(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetClientUpdateHosts_Response.valid_until_time)
}

// optional string ip_country = 3;
inline bool CContentServerDirectory_GetClientUpdateHosts_Response::_internal_has_ip_country() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetClientUpdateHosts_Response::has_ip_country() const {
  return _internal_has_ip_country();
}
inline void CContentServerDirectory_GetClientUpdateHosts_Response::clear_ip_country() {
  ip_country_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CContentServerDirectory_GetClientUpdateHosts_Response::ip_country() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetClientUpdateHosts_Response.ip_country)
  return _internal_ip_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_GetClientUpdateHosts_Response::set_ip_country(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ip_country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetClientUpdateHosts_Response.ip_country)
}
inline std::string* CContentServerDirectory_GetClientUpdateHosts_Response::mutable_ip_country() {
  std::string* _s = _internal_mutable_ip_country();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetClientUpdateHosts_Response.ip_country)
  return _s;
}
inline const std::string& CContentServerDirectory_GetClientUpdateHosts_Response::_internal_ip_country() const {
  return ip_country_.Get();
}
inline void CContentServerDirectory_GetClientUpdateHosts_Response::_internal_set_ip_country(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetClientUpdateHosts_Response::_internal_mutable_ip_country() {
  _has_bits_[0] |= 0x00000002u;
  return ip_country_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetClientUpdateHosts_Response::release_ip_country() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_GetClientUpdateHosts_Response.ip_country)
  if (!_internal_has_ip_country()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ip_country_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_GetClientUpdateHosts_Response::set_allocated_ip_country(std::string* ip_country) {
  if (ip_country != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_country_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_country,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_GetClientUpdateHosts_Response.ip_country)
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetManifestRequestCode_Request

// optional uint32 app_id = 1;
inline bool CContentServerDirectory_GetManifestRequestCode_Request::_internal_has_app_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetManifestRequestCode_Request::has_app_id() const {
  return _internal_has_app_id();
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::clear_app_id() {
  app_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CContentServerDirectory_GetManifestRequestCode_Request::_internal_app_id() const {
  return app_id_;
}
inline uint32_t CContentServerDirectory_GetManifestRequestCode_Request::app_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetManifestRequestCode_Request.app_id)
  return _internal_app_id();
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::_internal_set_app_id(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  app_id_ = value;
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetManifestRequestCode_Request.app_id)
}

// optional uint32 depot_id = 2;
inline bool CContentServerDirectory_GetManifestRequestCode_Request::_internal_has_depot_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetManifestRequestCode_Request::has_depot_id() const {
  return _internal_has_depot_id();
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::clear_depot_id() {
  depot_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CContentServerDirectory_GetManifestRequestCode_Request::_internal_depot_id() const {
  return depot_id_;
}
inline uint32_t CContentServerDirectory_GetManifestRequestCode_Request::depot_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetManifestRequestCode_Request.depot_id)
  return _internal_depot_id();
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::_internal_set_depot_id(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  depot_id_ = value;
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::set_depot_id(uint32_t value) {
  _internal_set_depot_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetManifestRequestCode_Request.depot_id)
}

// optional uint64 manifest_id = 3;
inline bool CContentServerDirectory_GetManifestRequestCode_Request::_internal_has_manifest_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetManifestRequestCode_Request::has_manifest_id() const {
  return _internal_has_manifest_id();
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::clear_manifest_id() {
  manifest_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t CContentServerDirectory_GetManifestRequestCode_Request::_internal_manifest_id() const {
  return manifest_id_;
}
inline uint64_t CContentServerDirectory_GetManifestRequestCode_Request::manifest_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetManifestRequestCode_Request.manifest_id)
  return _internal_manifest_id();
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::_internal_set_manifest_id(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  manifest_id_ = value;
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::set_manifest_id(uint64_t value) {
  _internal_set_manifest_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetManifestRequestCode_Request.manifest_id)
}

// optional string app_branch = 4;
inline bool CContentServerDirectory_GetManifestRequestCode_Request::_internal_has_app_branch() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetManifestRequestCode_Request::has_app_branch() const {
  return _internal_has_app_branch();
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::clear_app_branch() {
  app_branch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CContentServerDirectory_GetManifestRequestCode_Request::app_branch() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetManifestRequestCode_Request.app_branch)
  return _internal_app_branch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_GetManifestRequestCode_Request::set_app_branch(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 app_branch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetManifestRequestCode_Request.app_branch)
}
inline std::string* CContentServerDirectory_GetManifestRequestCode_Request::mutable_app_branch() {
  std::string* _s = _internal_mutable_app_branch();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetManifestRequestCode_Request.app_branch)
  return _s;
}
inline const std::string& CContentServerDirectory_GetManifestRequestCode_Request::_internal_app_branch() const {
  return app_branch_.Get();
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::_internal_set_app_branch(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  app_branch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetManifestRequestCode_Request::_internal_mutable_app_branch() {
  _has_bits_[0] |= 0x00000001u;
  return app_branch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetManifestRequestCode_Request::release_app_branch() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_GetManifestRequestCode_Request.app_branch)
  if (!_internal_has_app_branch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = app_branch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_branch_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_branch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::set_allocated_app_branch(std::string* app_branch) {
  if (app_branch != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  app_branch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_branch,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_branch_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_branch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_GetManifestRequestCode_Request.app_branch)
}

// optional string branch_password_hash = 5;
inline bool CContentServerDirectory_GetManifestRequestCode_Request::_internal_has_branch_password_hash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetManifestRequestCode_Request::has_branch_password_hash() const {
  return _internal_has_branch_password_hash();
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::clear_branch_password_hash() {
  branch_password_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CContentServerDirectory_GetManifestRequestCode_Request::branch_password_hash() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetManifestRequestCode_Request.branch_password_hash)
  return _internal_branch_password_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_GetManifestRequestCode_Request::set_branch_password_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 branch_password_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetManifestRequestCode_Request.branch_password_hash)
}
inline std::string* CContentServerDirectory_GetManifestRequestCode_Request::mutable_branch_password_hash() {
  std::string* _s = _internal_mutable_branch_password_hash();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetManifestRequestCode_Request.branch_password_hash)
  return _s;
}
inline const std::string& CContentServerDirectory_GetManifestRequestCode_Request::_internal_branch_password_hash() const {
  return branch_password_hash_.Get();
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::_internal_set_branch_password_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  branch_password_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetManifestRequestCode_Request::_internal_mutable_branch_password_hash() {
  _has_bits_[0] |= 0x00000002u;
  return branch_password_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetManifestRequestCode_Request::release_branch_password_hash() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_GetManifestRequestCode_Request.branch_password_hash)
  if (!_internal_has_branch_password_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = branch_password_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (branch_password_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    branch_password_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_GetManifestRequestCode_Request::set_allocated_branch_password_hash(std::string* branch_password_hash) {
  if (branch_password_hash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  branch_password_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), branch_password_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (branch_password_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    branch_password_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_GetManifestRequestCode_Request.branch_password_hash)
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetManifestRequestCode_Response

// optional uint64 manifest_request_code = 1;
inline bool CContentServerDirectory_GetManifestRequestCode_Response::_internal_has_manifest_request_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetManifestRequestCode_Response::has_manifest_request_code() const {
  return _internal_has_manifest_request_code();
}
inline void CContentServerDirectory_GetManifestRequestCode_Response::clear_manifest_request_code() {
  manifest_request_code_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CContentServerDirectory_GetManifestRequestCode_Response::_internal_manifest_request_code() const {
  return manifest_request_code_;
}
inline uint64_t CContentServerDirectory_GetManifestRequestCode_Response::manifest_request_code() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetManifestRequestCode_Response.manifest_request_code)
  return _internal_manifest_request_code();
}
inline void CContentServerDirectory_GetManifestRequestCode_Response::_internal_set_manifest_request_code(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  manifest_request_code_ = value;
}
inline void CContentServerDirectory_GetManifestRequestCode_Response::set_manifest_request_code(uint64_t value) {
  _internal_set_manifest_request_code(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetManifestRequestCode_Response.manifest_request_code)
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetCDNAuthToken_Request

// optional uint32 depot_id = 1;
inline bool CContentServerDirectory_GetCDNAuthToken_Request::_internal_has_depot_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetCDNAuthToken_Request::has_depot_id() const {
  return _internal_has_depot_id();
}
inline void CContentServerDirectory_GetCDNAuthToken_Request::clear_depot_id() {
  depot_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CContentServerDirectory_GetCDNAuthToken_Request::_internal_depot_id() const {
  return depot_id_;
}
inline uint32_t CContentServerDirectory_GetCDNAuthToken_Request::depot_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetCDNAuthToken_Request.depot_id)
  return _internal_depot_id();
}
inline void CContentServerDirectory_GetCDNAuthToken_Request::_internal_set_depot_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  depot_id_ = value;
}
inline void CContentServerDirectory_GetCDNAuthToken_Request::set_depot_id(uint32_t value) {
  _internal_set_depot_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetCDNAuthToken_Request.depot_id)
}

// optional string host_name = 2;
inline bool CContentServerDirectory_GetCDNAuthToken_Request::_internal_has_host_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetCDNAuthToken_Request::has_host_name() const {
  return _internal_has_host_name();
}
inline void CContentServerDirectory_GetCDNAuthToken_Request::clear_host_name() {
  host_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CContentServerDirectory_GetCDNAuthToken_Request::host_name() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetCDNAuthToken_Request.host_name)
  return _internal_host_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_GetCDNAuthToken_Request::set_host_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 host_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetCDNAuthToken_Request.host_name)
}
inline std::string* CContentServerDirectory_GetCDNAuthToken_Request::mutable_host_name() {
  std::string* _s = _internal_mutable_host_name();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetCDNAuthToken_Request.host_name)
  return _s;
}
inline const std::string& CContentServerDirectory_GetCDNAuthToken_Request::_internal_host_name() const {
  return host_name_.Get();
}
inline void CContentServerDirectory_GetCDNAuthToken_Request::_internal_set_host_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  host_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetCDNAuthToken_Request::_internal_mutable_host_name() {
  _has_bits_[0] |= 0x00000001u;
  return host_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetCDNAuthToken_Request::release_host_name() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_GetCDNAuthToken_Request.host_name)
  if (!_internal_has_host_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = host_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    host_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_GetCDNAuthToken_Request::set_allocated_host_name(std::string* host_name) {
  if (host_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  host_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    host_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_GetCDNAuthToken_Request.host_name)
}

// optional uint32 app_id = 3;
inline bool CContentServerDirectory_GetCDNAuthToken_Request::_internal_has_app_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetCDNAuthToken_Request::has_app_id() const {
  return _internal_has_app_id();
}
inline void CContentServerDirectory_GetCDNAuthToken_Request::clear_app_id() {
  app_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CContentServerDirectory_GetCDNAuthToken_Request::_internal_app_id() const {
  return app_id_;
}
inline uint32_t CContentServerDirectory_GetCDNAuthToken_Request::app_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetCDNAuthToken_Request.app_id)
  return _internal_app_id();
}
inline void CContentServerDirectory_GetCDNAuthToken_Request::_internal_set_app_id(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  app_id_ = value;
}
inline void CContentServerDirectory_GetCDNAuthToken_Request::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetCDNAuthToken_Request.app_id)
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetCDNAuthToken_Response

// optional string token = 1;
inline bool CContentServerDirectory_GetCDNAuthToken_Response::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetCDNAuthToken_Response::has_token() const {
  return _internal_has_token();
}
inline void CContentServerDirectory_GetCDNAuthToken_Response::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CContentServerDirectory_GetCDNAuthToken_Response::token() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetCDNAuthToken_Response.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_GetCDNAuthToken_Response::set_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetCDNAuthToken_Response.token)
}
inline std::string* CContentServerDirectory_GetCDNAuthToken_Response::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetCDNAuthToken_Response.token)
  return _s;
}
inline const std::string& CContentServerDirectory_GetCDNAuthToken_Response::_internal_token() const {
  return token_.Get();
}
inline void CContentServerDirectory_GetCDNAuthToken_Response::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetCDNAuthToken_Response::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetCDNAuthToken_Response::release_token() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_GetCDNAuthToken_Response.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_GetCDNAuthToken_Response::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_GetCDNAuthToken_Response.token)
}

// optional uint32 expiration_time = 2;
inline bool CContentServerDirectory_GetCDNAuthToken_Response::_internal_has_expiration_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetCDNAuthToken_Response::has_expiration_time() const {
  return _internal_has_expiration_time();
}
inline void CContentServerDirectory_GetCDNAuthToken_Response::clear_expiration_time() {
  expiration_time_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CContentServerDirectory_GetCDNAuthToken_Response::_internal_expiration_time() const {
  return expiration_time_;
}
inline uint32_t CContentServerDirectory_GetCDNAuthToken_Response::expiration_time() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetCDNAuthToken_Response.expiration_time)
  return _internal_expiration_time();
}
inline void CContentServerDirectory_GetCDNAuthToken_Response::_internal_set_expiration_time(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  expiration_time_ = value;
}
inline void CContentServerDirectory_GetCDNAuthToken_Response::set_expiration_time(uint32_t value) {
  _internal_set_expiration_time(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetCDNAuthToken_Response.expiration_time)
}

// -------------------------------------------------------------------

// CContentServerDirectory_RequestPeerContentServer_Request

// optional uint64 remote_client_id = 1;
inline bool CContentServerDirectory_RequestPeerContentServer_Request::_internal_has_remote_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_RequestPeerContentServer_Request::has_remote_client_id() const {
  return _internal_has_remote_client_id();
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::clear_remote_client_id() {
  remote_client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CContentServerDirectory_RequestPeerContentServer_Request::_internal_remote_client_id() const {
  return remote_client_id_;
}
inline uint64_t CContentServerDirectory_RequestPeerContentServer_Request::remote_client_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_RequestPeerContentServer_Request.remote_client_id)
  return _internal_remote_client_id();
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::_internal_set_remote_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  remote_client_id_ = value;
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::set_remote_client_id(uint64_t value) {
  _internal_set_remote_client_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_RequestPeerContentServer_Request.remote_client_id)
}

// optional uint64 steamid = 2;
inline bool CContentServerDirectory_RequestPeerContentServer_Request::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CContentServerDirectory_RequestPeerContentServer_Request::has_steamid() const {
  return _internal_has_steamid();
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CContentServerDirectory_RequestPeerContentServer_Request::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CContentServerDirectory_RequestPeerContentServer_Request::steamid() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_RequestPeerContentServer_Request.steamid)
  return _internal_steamid();
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  steamid_ = value;
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_RequestPeerContentServer_Request.steamid)
}

// optional uint64 server_remote_client_id = 3;
inline bool CContentServerDirectory_RequestPeerContentServer_Request::_internal_has_server_remote_client_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CContentServerDirectory_RequestPeerContentServer_Request::has_server_remote_client_id() const {
  return _internal_has_server_remote_client_id();
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::clear_server_remote_client_id() {
  server_remote_client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CContentServerDirectory_RequestPeerContentServer_Request::_internal_server_remote_client_id() const {
  return server_remote_client_id_;
}
inline uint64_t CContentServerDirectory_RequestPeerContentServer_Request::server_remote_client_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_RequestPeerContentServer_Request.server_remote_client_id)
  return _internal_server_remote_client_id();
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::_internal_set_server_remote_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  server_remote_client_id_ = value;
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::set_server_remote_client_id(uint64_t value) {
  _internal_set_server_remote_client_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_RequestPeerContentServer_Request.server_remote_client_id)
}

// optional uint32 app_id = 4;
inline bool CContentServerDirectory_RequestPeerContentServer_Request::_internal_has_app_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CContentServerDirectory_RequestPeerContentServer_Request::has_app_id() const {
  return _internal_has_app_id();
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::clear_app_id() {
  app_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CContentServerDirectory_RequestPeerContentServer_Request::_internal_app_id() const {
  return app_id_;
}
inline uint32_t CContentServerDirectory_RequestPeerContentServer_Request::app_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_RequestPeerContentServer_Request.app_id)
  return _internal_app_id();
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::_internal_set_app_id(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  app_id_ = value;
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_RequestPeerContentServer_Request.app_id)
}

// optional uint32 current_build_id = 5;
inline bool CContentServerDirectory_RequestPeerContentServer_Request::_internal_has_current_build_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CContentServerDirectory_RequestPeerContentServer_Request::has_current_build_id() const {
  return _internal_has_current_build_id();
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::clear_current_build_id() {
  current_build_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CContentServerDirectory_RequestPeerContentServer_Request::_internal_current_build_id() const {
  return current_build_id_;
}
inline uint32_t CContentServerDirectory_RequestPeerContentServer_Request::current_build_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_RequestPeerContentServer_Request.current_build_id)
  return _internal_current_build_id();
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::_internal_set_current_build_id(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  current_build_id_ = value;
}
inline void CContentServerDirectory_RequestPeerContentServer_Request::set_current_build_id(uint32_t value) {
  _internal_set_current_build_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_RequestPeerContentServer_Request.current_build_id)
}

// -------------------------------------------------------------------

// CContentServerDirectory_RequestPeerContentServer_Response

// optional uint32 server_port = 1;
inline bool CContentServerDirectory_RequestPeerContentServer_Response::_internal_has_server_port() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_RequestPeerContentServer_Response::has_server_port() const {
  return _internal_has_server_port();
}
inline void CContentServerDirectory_RequestPeerContentServer_Response::clear_server_port() {
  server_port_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CContentServerDirectory_RequestPeerContentServer_Response::_internal_server_port() const {
  return server_port_;
}
inline uint32_t CContentServerDirectory_RequestPeerContentServer_Response::server_port() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_RequestPeerContentServer_Response.server_port)
  return _internal_server_port();
}
inline void CContentServerDirectory_RequestPeerContentServer_Response::_internal_set_server_port(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  server_port_ = value;
}
inline void CContentServerDirectory_RequestPeerContentServer_Response::set_server_port(uint32_t value) {
  _internal_set_server_port(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_RequestPeerContentServer_Response.server_port)
}

// repeated uint32 installed_depots = 2;
inline int CContentServerDirectory_RequestPeerContentServer_Response::_internal_installed_depots_size() const {
  return installed_depots_.size();
}
inline int CContentServerDirectory_RequestPeerContentServer_Response::installed_depots_size() const {
  return _internal_installed_depots_size();
}
inline void CContentServerDirectory_RequestPeerContentServer_Response::clear_installed_depots() {
  installed_depots_.Clear();
}
inline uint32_t CContentServerDirectory_RequestPeerContentServer_Response::_internal_installed_depots(int index) const {
  return installed_depots_.Get(index);
}
inline uint32_t CContentServerDirectory_RequestPeerContentServer_Response::installed_depots(int index) const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_RequestPeerContentServer_Response.installed_depots)
  return _internal_installed_depots(index);
}
inline void CContentServerDirectory_RequestPeerContentServer_Response::set_installed_depots(int index, uint32_t value) {
  installed_depots_.Set(index, value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_RequestPeerContentServer_Response.installed_depots)
}
inline void CContentServerDirectory_RequestPeerContentServer_Response::_internal_add_installed_depots(uint32_t value) {
  installed_depots_.Add(value);
}
inline void CContentServerDirectory_RequestPeerContentServer_Response::add_installed_depots(uint32_t value) {
  _internal_add_installed_depots(value);
  // @@protoc_insertion_point(field_add:CContentServerDirectory_RequestPeerContentServer_Response.installed_depots)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CContentServerDirectory_RequestPeerContentServer_Response::_internal_installed_depots() const {
  return installed_depots_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CContentServerDirectory_RequestPeerContentServer_Response::installed_depots() const {
  // @@protoc_insertion_point(field_list:CContentServerDirectory_RequestPeerContentServer_Response.installed_depots)
  return _internal_installed_depots();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CContentServerDirectory_RequestPeerContentServer_Response::_internal_mutable_installed_depots() {
  return &installed_depots_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CContentServerDirectory_RequestPeerContentServer_Response::mutable_installed_depots() {
  // @@protoc_insertion_point(field_mutable_list:CContentServerDirectory_RequestPeerContentServer_Response.installed_depots)
  return _internal_mutable_installed_depots();
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetPeerContentInfo_Request

// optional uint64 remote_client_id = 1;
inline bool CContentServerDirectory_GetPeerContentInfo_Request::_internal_has_remote_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetPeerContentInfo_Request::has_remote_client_id() const {
  return _internal_has_remote_client_id();
}
inline void CContentServerDirectory_GetPeerContentInfo_Request::clear_remote_client_id() {
  remote_client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CContentServerDirectory_GetPeerContentInfo_Request::_internal_remote_client_id() const {
  return remote_client_id_;
}
inline uint64_t CContentServerDirectory_GetPeerContentInfo_Request::remote_client_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetPeerContentInfo_Request.remote_client_id)
  return _internal_remote_client_id();
}
inline void CContentServerDirectory_GetPeerContentInfo_Request::_internal_set_remote_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  remote_client_id_ = value;
}
inline void CContentServerDirectory_GetPeerContentInfo_Request::set_remote_client_id(uint64_t value) {
  _internal_set_remote_client_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetPeerContentInfo_Request.remote_client_id)
}

// optional uint64 steamid = 2;
inline bool CContentServerDirectory_GetPeerContentInfo_Request::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetPeerContentInfo_Request::has_steamid() const {
  return _internal_has_steamid();
}
inline void CContentServerDirectory_GetPeerContentInfo_Request::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CContentServerDirectory_GetPeerContentInfo_Request::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CContentServerDirectory_GetPeerContentInfo_Request::steamid() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetPeerContentInfo_Request.steamid)
  return _internal_steamid();
}
inline void CContentServerDirectory_GetPeerContentInfo_Request::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  steamid_ = value;
}
inline void CContentServerDirectory_GetPeerContentInfo_Request::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetPeerContentInfo_Request.steamid)
}

// optional uint64 server_remote_client_id = 3;
inline bool CContentServerDirectory_GetPeerContentInfo_Request::_internal_has_server_remote_client_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetPeerContentInfo_Request::has_server_remote_client_id() const {
  return _internal_has_server_remote_client_id();
}
inline void CContentServerDirectory_GetPeerContentInfo_Request::clear_server_remote_client_id() {
  server_remote_client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CContentServerDirectory_GetPeerContentInfo_Request::_internal_server_remote_client_id() const {
  return server_remote_client_id_;
}
inline uint64_t CContentServerDirectory_GetPeerContentInfo_Request::server_remote_client_id() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetPeerContentInfo_Request.server_remote_client_id)
  return _internal_server_remote_client_id();
}
inline void CContentServerDirectory_GetPeerContentInfo_Request::_internal_set_server_remote_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  server_remote_client_id_ = value;
}
inline void CContentServerDirectory_GetPeerContentInfo_Request::set_server_remote_client_id(uint64_t value) {
  _internal_set_server_remote_client_id(value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetPeerContentInfo_Request.server_remote_client_id)
}

// -------------------------------------------------------------------

// CContentServerDirectory_GetPeerContentInfo_Response

// repeated uint32 appids = 1;
inline int CContentServerDirectory_GetPeerContentInfo_Response::_internal_appids_size() const {
  return appids_.size();
}
inline int CContentServerDirectory_GetPeerContentInfo_Response::appids_size() const {
  return _internal_appids_size();
}
inline void CContentServerDirectory_GetPeerContentInfo_Response::clear_appids() {
  appids_.Clear();
}
inline uint32_t CContentServerDirectory_GetPeerContentInfo_Response::_internal_appids(int index) const {
  return appids_.Get(index);
}
inline uint32_t CContentServerDirectory_GetPeerContentInfo_Response::appids(int index) const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetPeerContentInfo_Response.appids)
  return _internal_appids(index);
}
inline void CContentServerDirectory_GetPeerContentInfo_Response::set_appids(int index, uint32_t value) {
  appids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetPeerContentInfo_Response.appids)
}
inline void CContentServerDirectory_GetPeerContentInfo_Response::_internal_add_appids(uint32_t value) {
  appids_.Add(value);
}
inline void CContentServerDirectory_GetPeerContentInfo_Response::add_appids(uint32_t value) {
  _internal_add_appids(value);
  // @@protoc_insertion_point(field_add:CContentServerDirectory_GetPeerContentInfo_Response.appids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CContentServerDirectory_GetPeerContentInfo_Response::_internal_appids() const {
  return appids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CContentServerDirectory_GetPeerContentInfo_Response::appids() const {
  // @@protoc_insertion_point(field_list:CContentServerDirectory_GetPeerContentInfo_Response.appids)
  return _internal_appids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CContentServerDirectory_GetPeerContentInfo_Response::_internal_mutable_appids() {
  return &appids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CContentServerDirectory_GetPeerContentInfo_Response::mutable_appids() {
  // @@protoc_insertion_point(field_mutable_list:CContentServerDirectory_GetPeerContentInfo_Response.appids)
  return _internal_mutable_appids();
}

// optional string ip_public = 2;
inline bool CContentServerDirectory_GetPeerContentInfo_Response::_internal_has_ip_public() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CContentServerDirectory_GetPeerContentInfo_Response::has_ip_public() const {
  return _internal_has_ip_public();
}
inline void CContentServerDirectory_GetPeerContentInfo_Response::clear_ip_public() {
  ip_public_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CContentServerDirectory_GetPeerContentInfo_Response::ip_public() const {
  // @@protoc_insertion_point(field_get:CContentServerDirectory_GetPeerContentInfo_Response.ip_public)
  return _internal_ip_public();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CContentServerDirectory_GetPeerContentInfo_Response::set_ip_public(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ip_public_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CContentServerDirectory_GetPeerContentInfo_Response.ip_public)
}
inline std::string* CContentServerDirectory_GetPeerContentInfo_Response::mutable_ip_public() {
  std::string* _s = _internal_mutable_ip_public();
  // @@protoc_insertion_point(field_mutable:CContentServerDirectory_GetPeerContentInfo_Response.ip_public)
  return _s;
}
inline const std::string& CContentServerDirectory_GetPeerContentInfo_Response::_internal_ip_public() const {
  return ip_public_.Get();
}
inline void CContentServerDirectory_GetPeerContentInfo_Response::_internal_set_ip_public(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_public_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetPeerContentInfo_Response::_internal_mutable_ip_public() {
  _has_bits_[0] |= 0x00000001u;
  return ip_public_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CContentServerDirectory_GetPeerContentInfo_Response::release_ip_public() {
  // @@protoc_insertion_point(field_release:CContentServerDirectory_GetPeerContentInfo_Response.ip_public)
  if (!_internal_has_ip_public()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ip_public_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_public_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_public_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CContentServerDirectory_GetPeerContentInfo_Response::set_allocated_ip_public(std::string* ip_public) {
  if (ip_public != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_public_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_public,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_public_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_public_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CContentServerDirectory_GetPeerContentInfo_Response.ip_public)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_steammessages_5fcontentsystem_2esteamclient_2eproto
